<!DOCTYPE html>
<html lang="en">
<head>
    <title>Proc</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
<link rel="stylesheet" href="/css/reset.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/panel.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/github.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<script src="/js/jquery-3.5.1.min.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/main.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/highlight.pack.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/turbolinks.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/search_index.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searcher.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/panel/tree.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searchdoc.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>

<meta name="data-rel-prefix" content="/">
<meta name="data-tree-keys" content='["Proc"]'>


    <meta property="og:title" value="Proc">

  
    
    <meta name="description" content="A Proc object is an encapsulation of a block of code, which can be stored in a local variable, passed to a method or another Proc, and can be called.">
    <meta property="og:description" content="A Proc object is an encapsulation of a block of code, which can be stored in a local variable, passed to a method or another Proc, and can be called.">
  

    <meta name="keywords" content="Proc class, new, call, [], ===, yield, to_proc, arity, hash, to_s, lambda?, binding, curry, <<, >>, source_location, parameters, ruby2_keywords, inspect">
</head>

<body>
    <a class="sr-only sr-only-focusable" href="#content" data-turbolinks="false">Skip to Content</a>
    <a class="sr-only sr-only-focusable" href="#search" data-turbolinks="false">Skip to Search</a>

    <input type="checkbox" id="hamburger" class="panel_checkbox">
<label class="panel_mobile_button" for="hamburger"><span></span> Menu</label>
<nav class="panel panel_tree" id="panel" data-turbolinks-permanent>
  <div class="header">
    <input type="text" placeholder="Search (/) for a class, method, ..." autosave="searchdoc" results="10" id="search" autocomplete="off" tabindex="-1" />
    <label class="panel_mobile_button_close" for="hamburger"><span></span> Close</label>
  </div>
  <div class="tree">
    <ul>
    </ul>
  </div>
  <div class="result">
    <ul>
    </ul>
  </div>
  <a href="links.html" id="links">index</a>
</nav>


    <div class="banner">
        
        <h2>
            <span class="type">Class</span>
            Proc
            
                <span class="parent">&lt;
                    
                    <a href="Object.html">Object</a>
                    
                </span>
            
        </h2>
        <ul class="files">
            
            <li><a href="../files/ruby/proc_c.html">ruby/proc.c</a></li>
            
        </ul>
    </div>

    <main id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>A <code>Proc</code> object is an encapsulation of a block of code, which can be stored in a local variable, passed to a method or another <a href="Proc.html"><code>Proc</code></a>, and can be called. <a href="Proc.html"><code>Proc</code></a> is an essential concept in Ruby and a core of its functional programming features.</p>

<pre><code>square = Proc.new {|x| x**2 }

square.call(3)  #=&gt; 9
# shorthands:
square.(3)      #=&gt; 9
square[3]       #=&gt; 9
</code></pre>

<p><a href="Proc.html"><code>Proc</code></a> objects are <em>closures</em>, meaning they remember and can use the entire context in which they were created.</p>

<pre><code>def gen_times(factor)
  Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
end

times3 = gen_times(3)
times5 = gen_times(5)

times3.call(12)               #=&gt; 36
times5.call(5)                #=&gt; 25
times3.call(times5.call(4))   #=&gt; 60
</code></pre>

<h2 id="class-Proc-label-Creation">Creation</h2>

<p>There are several methods to create a <a href="Proc.html"><code>Proc</code></a></p>
<ul><li>
<p>Use the <a href="Proc.html"><code>Proc</code></a> class constructor:</p>

<pre><code>proc1 = Proc.new {|x| x**2 }
</code></pre>
</li><li>
<p>Use the <a href="Kernel.html#method-i-proc"><code>Kernel#proc</code></a> method as a shorthand of <a href="Proc.html#method-c-new"><code>Proc.new</code></a>:</p>

<pre><code>proc2 = proc {|x| x**2 }
</code></pre>
</li><li>
<p>Receiving a block of code into proc argument (note the <code>&amp;</code>):</p>

<pre><code>def make_proc(&amp;block)
  block
end

proc3 = make_proc {|x| x**2 }
</code></pre>
</li><li>
<p>Construct a proc with lambda semantics using the <a href="Kernel.html#method-i-lambda"><code>Kernel#lambda</code></a> method (see below for explanations about lambdas):</p>

<pre><code>lambda1 = lambda {|x| x**2 }
</code></pre>
</li><li>
<p>Use the Lambda literal syntax (also constructs a proc with lambda semantics):</p>

<pre><code>lambda2 = -&gt;(x) { x**2 }
</code></pre>
</li></ul>

<h2 id="class-Proc-label-Lambda+and+non-lambda+semantics">Lambda and non-lambda semantics</h2>

<p>Procs are coming in two flavors: lambda and non-lambda (regular procs). Differences are:</p>
<ul><li>
<p>In lambdas, <code>return</code> and <code>break</code> means exit from this lambda;</p>
</li><li>
<p>In non-lambda procs, <code>return</code> means exit from embracing method (and will throw <code>LocalJumpError</code> if invoked outside the method);</p>
</li><li>
<p>In non-lambda procs, <code>break</code> means exit from the method which the block given for. (and will throw <code>LocalJumpError</code> if invoked after the method returns);</p>
</li><li>
<p>In lambdas, arguments are treated in the same way as in methods: strict, with <code>ArgumentError</code> for mismatching argument number, and no additional argument processing;</p>
</li><li>
<p>Regular procs accept arguments more generously: missing arguments are filled with <code>nil</code>, single <a href="Array.html"><code>Array</code></a> arguments are deconstructed if the proc has multiple arguments, and there is no error raised on extra arguments.</p>
</li></ul>

<p>Examples:</p>

<pre><code># +return+ in non-lambda proc, +b+, exits +m2+.
# (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1 { return }; $a &lt;&lt; :m2 end; m2; p $a
#=&gt; []

# +break+ in non-lambda proc, +b+, exits +m1+.
# (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1 { break }; $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m2]

# +next+ in non-lambda proc, +b+, exits the block.
# (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1 { next }; $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]

# Using +proc+ method changes the behavior as follows because
# The block is given for +proc+ method and embraced by +m2+.
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;proc { return }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; []
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;proc { break }); $a &lt;&lt; :m2 end; m2; p $a
# break from proc-closure (LocalJumpError)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;proc { next }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]

# +return+, +break+ and +next+ in the stubby lambda exits the block.
# (+lambda+ method behaves same.)
# (The block is given for stubby lambda syntax and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;-&gt; { return }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;-&gt; { break }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;-&gt; { next }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]

p = proc {|x, y| &quot;x=#{x}, y=#{y}&quot; }
p.call(1, 2)      #=&gt; &quot;x=1, y=2&quot;
p.call([1, 2])    #=&gt; &quot;x=1, y=2&quot;, array deconstructed
p.call(1, 2, 8)   #=&gt; &quot;x=1, y=2&quot;, extra argument discarded
p.call(1)         #=&gt; &quot;x=1, y=&quot;, nil substituted instead of error

l = lambda {|x, y| &quot;x=#{x}, y=#{y}&quot; }
l.call(1, 2)      #=&gt; &quot;x=1, y=2&quot;
l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)

def test_return
  -&gt; { return 3 }.call      # just returns from lambda into method body
  proc { return 4 }.call    # returns from method
  return 5
end

test_return # =&gt; 4, return from proc
</code></pre>

<p>Lambdas are useful as self-sufficient functions, in particular useful as arguments to higher-order functions, behaving exactly like Ruby methods.</p>

<p>Procs are useful for implementing iterators:</p>

<pre><code>def test
  [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b &gt; 10 }
                            #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
end
</code></pre>

<p>Inside <code>map</code>, the block of code is treated as a regular (non-lambda) proc, which means that the internal arrays will be deconstructed to pairs of arguments, and <code>return</code> will exit from the method <code>test</code>. That would not be possible with a stricter lambda.</p>

<p>You can tell a lambda from a regular proc by using the <a href="Proc.html#method-i-lambda-3F"><code>lambda?</code></a> instance method.</p>

<p>Lambda semantics is typically preserved during the proc lifetime, including <code>&amp;</code>-deconstruction to a block of code:</p>

<pre><code>p = proc {|x, y| x }
l = lambda {|x, y| x }
[[1, 2], [3, 4]].map(&amp;p) #=&gt; [1, 2]
[[1, 2], [3, 4]].map(&amp;l) # ArgumentError: wrong number of arguments (given 1, expected 2)
</code></pre>

<p>The only exception is dynamic method definition: even if defined by passing a non-lambda proc, methods still have normal semantics of argument checking.</p>

<pre><code>class C
  define_method(:e, &amp;proc {})
end
C.new.e(1,2)       #=&gt; ArgumentError
C.new.method(:e).to_proc.lambda?   #=&gt; true
</code></pre>

<p>This exception ensures that methods never have unusual argument passing conventions, and makes it easy to have wrappers defining methods that behave as usual.</p>

<pre><code>class C
  def self.def2(name, &amp;body)
    define_method(name, &amp;body)
  end

  def2(:f) {}
end
C.new.f(1,2)       #=&gt; ArgumentError
</code></pre>

<p>The wrapper <code>def2</code> receives <em>body</em> as a non-lambda proc, yet defines a method which has normal semantics.</p>

<h2 id="class-Proc-label-Conversion+of+other+objects+to+procs">Conversion of other objects to procs</h2>

<p>Any object that implements the <code>to_proc</code> method can be converted into a proc by the <code>&amp;</code> operator, and therefore con be consumed by iterators.</p>

<pre><code>class Greeter
  def initialize(greeting)
    @greeting = greeting
  end

  def to_proc
    proc {|name| &quot;#{@greeting}, #{name}!&quot; }
  end
end

hi = Greeter.new(&quot;Hi&quot;)
hey = Greeter.new(&quot;Hey&quot;)
[&quot;Bob&quot;, &quot;Jane&quot;].map(&amp;hi)    #=&gt; [&quot;Hi, Bob!&quot;, &quot;Hi, Jane!&quot;]
[&quot;Bob&quot;, &quot;Jane&quot;].map(&amp;hey)   #=&gt; [&quot;Hey, Bob!&quot;, &quot;Hey, Jane!&quot;]
</code></pre>

<p>Of the Ruby core classes, this method is implemented by <a href="Symbol.html"><code>Symbol</code></a>, <a href="Method.html"><code>Method</code></a>, and <a href="Hash.html"><code>Hash</code></a>.</p>

<pre><code>:to_s.to_proc.call(1)           #=&gt; &quot;1&quot;
[1, 2].map(&amp;:to_s)              #=&gt; [&quot;1&quot;, &quot;2&quot;]

method(:puts).to_proc.call(1)   # prints 1
[1, 2].each(&amp;method(:puts))     # prints 1, 2

{test: 1}.to_proc.call(:test)       #=&gt; 1
%i[test many keys].map(&amp;{test: 1})  #=&gt; [1, nil, nil]
</code></pre>

<h2 id="class-Proc-label-Orphaned+Proc">Orphaned <a href="Proc.html"><code>Proc</code></a></h2>

<p><code>return</code> and <code>break</code> in a block exit a method. If a <a href="Proc.html"><code>Proc</code></a> object is generated from the block and the <a href="Proc.html"><code>Proc</code></a> object survives until the method is returned, <code>return</code> and <code>break</code> cannot work. In such case, <code>return</code> and <code>break</code> raises <a href="LocalJumpError.html"><code>LocalJumpError</code></a>. A <a href="Proc.html"><code>Proc</code></a> object in such situation is called as orphaned <a href="Proc.html"><code>Proc</code></a> object.</p>

<p>Note that the method to exit is different for <code>return</code> and <code>break</code>. There is a situation that orphaned for <code>break</code> but not orphaned for <code>return</code>.</p>

<pre><code>def m1(&amp;b) b.call end; def m2(); m1 { return } end; m2 # ok
def m1(&amp;b) b.call end; def m2(); m1 { break } end; m2 # ok

def m1(&amp;b) b end; def m2(); m1 { return }.call end; m2 # ok
def m1(&amp;b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError

def m1(&amp;b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
def m1(&amp;b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError
</code></pre>

<p>Since <code>return</code> and <code>break</code> exits the block itself in lambdas, lambdas cannot be orphaned.</p>

<h2 id="class-Proc-label-Numbered+parameters">Numbered parameters</h2>

<p>Numbered parameters are implicitly defined block parameters intended to simplify writing short blocks:</p>

<pre><code># Explicit parameter:
%w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
(1..5).map { |i| i**2 } # =&gt; [1, 4, 9, 16, 25]

# Implicit parameter:
%w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
(1..5).map { _1**2 } # =&gt; [1, 4, 9, 16, 25]
</code></pre>

<p>Parameter names from <code>_1</code> to <code>_9</code> are supported:</p>

<pre><code>[10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
# =&gt; [120, 150, 180]
</code></pre>

<p>Though, it is advised to resort to them wisely, probably limiting yourself to <code>_1</code> and <code>_2</code>, and to one-line blocks.</p>

<p>Numbered parameters can’t be used together with explicitly named ones:</p>

<pre><code>[10, 20, 30].map { |x| _1**2 }
# SyntaxError (ordinary parameter is defined)
</code></pre>

<p>To avoid conflicts, naming local variables or method arguments <code>_1</code>, <code>_2</code> and so on, causes a warning.</p>

<pre><code>_1 = &#39;test&#39;
# warning: `_1&#39; is reserved as numbered parameter
</code></pre>

<p>Using implicit numbered parameters affects block’s arity:</p>

<pre><code>p = proc { _1 + _2 }
l = lambda { _1 + _2 }
p.parameters     # =&gt; [[:opt, :_1], [:opt, :_2]]
p.arity          # =&gt; 2
l.parameters     # =&gt; [[:req, :_1], [:req, :_2]]
l.arity          # =&gt; 2
</code></pre>

<p>Blocks with numbered parameters can’t be nested:</p>

<pre><code>%w[test me].each { _1.each_char { p _1 } }
# SyntaxError (numbered parameter is already used in outer block here)
# %w[test me].each { _1.each_char { p _1 } }
#                    ^~
</code></pre>

<p>Numbered parameters were introduced in Ruby 2.7.</p>

    </div>
  


  


  
  


  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>#</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-3C-3C">&lt;&lt;</a>,
              </li>
            
              
              <li>
                <a href="#method-i-3D-3D-3D">===</a>,
              </li>
            
              
              <li>
                <a href="#method-i-3E-3E">&gt;&gt;</a>,
              </li>
            
              
              <li>
                <a href="#method-i-5B-5D">[]</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>A</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-arity">arity</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>B</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-binding">binding</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>C</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-call">call</a>,
              </li>
            
              
              <li>
                <a href="#method-i-curry">curry</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>H</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-hash">hash</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>I</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-inspect">inspect</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>L</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-lambda-3F">lambda?</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>N</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-new">new</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>P</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-parameters">parameters</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>R</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-ruby2_keywords">ruby2_keywords</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>S</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-source_location">source_location</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>T</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-to_proc">to_proc</a>,
              </li>
            
              
              <li>
                <a href="#method-i-to_s">to_s</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>Y</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-yield">yield</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    


    


    <!-- Methods -->
    
      <h2 class="sectiontitle">Class Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-c-new">
            
              <b>Proc.new {|...| block } &rarr; a_proc<br />Proc.new                &rarr; a_proc
</b>
            
            <a href="../classes/Proc.html#method-c-new" name="method-c-new" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Creates a new <a href="Proc.html"><code>Proc</code></a> object, bound to the current context. <a href="Proc.html#method-c-new"><code>Proc::new</code></a> may be called without a block only within a method with an attached block, in which case that block is converted to the <a href="Proc.html"><code>Proc</code></a> object.</p>

<pre><code>def proc_from
  Proc.new
end
proc = proc_from { &quot;hello&quot; }
proc.call   #=&gt; &quot;hello&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-new_source')" id="l_method-c-new_source">show</a>
                
              </p>
              <div id="method-c-new_source" class="dyn-source">
                <pre>static VALUE
rb_proc_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE block = proc_new(klass, FALSE, FALSE);

    rb_obj_call_init_kw(block, argc, argv, RB_PASS_CALLED_KEYWORDS);
    return block;
}</pre>
              </div>
            </div>
            
          </div>
        
      
    
      <h2 class="sectiontitle">Instance Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-i-3C-3C">
            
              <b>prc << g &rarr; a_proc
</b>
            
            <a href="../classes/Proc.html#method-i-3C-3C" name="method-i-3C-3C" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a proc that is the composition of this proc and the given <em>g</em>. The returned proc takes a variable number of arguments, calls <em>g</em> with them then calls this proc with the result.</p>

<pre><code>f = proc {|x| x * x }
g = proc {|x| x + x }
p (f &lt;&lt; g).call(2) #=&gt; 16
</code></pre>

<p>See <a href="Proc.html#method-i-3E-3E"><code>Proc#&gt;&gt;</code></a> for detailed explanations.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-3C-3C_source')" id="l_method-i-3C-3C_source">show</a>
                
              </p>
              <div id="method-i-3C-3C_source" class="dyn-source">
                <pre>static VALUE
proc_compose_to_left(VALUE self, VALUE g)
{
    return rb_proc_compose_to_left(self, to_callable(g));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-3D-3D-3D">
            
              <b>prc.(params,...)       &rarr; obj</b>
            
            <a href="../classes/Proc.html#method-i-3D-3D-3D" name="method-i-3D-3D-3D" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p>

<pre><code>a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</code></pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given.  It’s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc.  For procs created using <a href="Proc.html#method-c-new"><code>Proc.new</code></a> or <a href="Kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre><code>a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</code></pre>

<p>See also <a href="Proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Proc.html#method-i-call">call</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-3E-3E">
            
              <b>prc >> g &rarr; a_proc
</b>
            
            <a href="../classes/Proc.html#method-i-3E-3E" name="method-i-3E-3E" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a proc that is the composition of this proc and the given <em>g</em>. The returned proc takes a variable number of arguments, calls this proc with them then calls <em>g</em> with the result.</p>

<pre><code>f = proc {|x| x * x }
g = proc {|x| x + x }
p (f &gt;&gt; g).call(2) #=&gt; 8
</code></pre>

<p><em>g</em> could be other <a href="Proc.html"><code>Proc</code></a>, or <a href="Method.html"><code>Method</code></a>, or any other object responding to <code>call</code> method:</p>

<pre><code>class Parser
  def self.call(text)
     # ...some complicated parsing logic...
  end
end

pipeline = File.method(:read) &gt;&gt; Parser &gt;&gt; proc { |data| puts &quot;data size: #{data.count}&quot; }
pipeline.call(&#39;data.json&#39;)
</code></pre>

<p>See also <a href="Method.html#method-i-3E-3E"><code>Method#&gt;&gt;</code></a> and <a href="Method.html#method-i-3C-3C"><code>Method#&lt;&lt;</code></a>.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-3E-3E_source')" id="l_method-i-3E-3E_source">show</a>
                
              </p>
              <div id="method-i-3E-3E_source" class="dyn-source">
                <pre>static VALUE
proc_compose_to_right(VALUE self, VALUE g)
{
    return rb_proc_compose_to_right(self, to_callable(g));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-5B-5D">
            
              <b>prc[params,...]        &rarr; obj<br />prc.(params,...)       &rarr; obj</b>
            
            <a href="../classes/Proc.html#method-i-5B-5D" name="method-i-5B-5D" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p>

<pre><code>a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</code></pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given.  It’s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc.  For procs created using <a href="Proc.html#method-c-new"><code>Proc.new</code></a> or <a href="Kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre><code>a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</code></pre>

<p>See also <a href="Proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Proc.html#method-i-call">call</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-arity">
            
              <b>prc.arity &rarr; integer
</b>
            
            <a href="../classes/Proc.html#method-i-arity" name="method-i-arity" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the number of mandatory arguments. If the block is declared to take no arguments, returns 0. If the block is known to take exactly n arguments, returns n. If the block has optional arguments, returns -n-1, where n is the number of mandatory arguments, with the exception for blocks that are not lambdas and have only a finite number of optional arguments; in this latter case, returns n. Keyword arguments will be considered as a single additional argument, that argument being mandatory if any keyword argument is mandatory. A <a href="Kernel.html#method-i-proc"><code>proc</code></a> with no argument declarations is the same as a block declaring <code>||</code> as its arguments.</p>

<pre><code>proc {}.arity                  #=&gt;  0
proc { || }.arity              #=&gt;  0
proc { |a| }.arity             #=&gt;  1
proc { |a, b| }.arity          #=&gt;  2
proc { |a, b, c| }.arity       #=&gt;  3
proc { |*a| }.arity            #=&gt; -1
proc { |a, *b| }.arity         #=&gt; -2
proc { |a, *b, c| }.arity      #=&gt; -3
proc { |x:, y:, z:0| }.arity   #=&gt;  1
proc { |*a, x:, y:0| }.arity   #=&gt; -2

proc   { |a=0| }.arity         #=&gt;  0
lambda { |a=0| }.arity         #=&gt; -1
proc   { |a=0, b| }.arity      #=&gt;  1
lambda { |a=0, b| }.arity      #=&gt; -2
proc   { |a=0, b=0| }.arity    #=&gt;  0
lambda { |a=0, b=0| }.arity    #=&gt; -1
proc   { |a, b=0| }.arity      #=&gt;  1
lambda { |a, b=0| }.arity      #=&gt; -2
proc   { |(a, b), c=0| }.arity #=&gt;  1
lambda { |(a, b), c=0| }.arity #=&gt; -2
proc   { |a, x:0, y:0| }.arity #=&gt;  1
lambda { |a, x:0, y:0| }.arity #=&gt; -2
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-arity_source')" id="l_method-i-arity_source">show</a>
                
              </p>
              <div id="method-i-arity_source" class="dyn-source">
                <pre>static VALUE
proc_arity(VALUE self)
{
    int arity = rb_proc_arity(self);
    return INT2FIX(arity);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-binding">
            
              <b>prc.binding    &rarr; binding
</b>
            
            <a href="../classes/Proc.html#method-i-binding" name="method-i-binding" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the binding associated with <em>prc</em>.</p>

<pre><code>def fred(param)
  proc {}
end

b = fred(99)
eval(&quot;param&quot;, b.binding)   #=&gt; 99
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-binding_source')" id="l_method-i-binding_source">show</a>
                
              </p>
              <div id="method-i-binding_source" class="dyn-source">
                <pre>static VALUE
proc_binding(VALUE self)
{
    VALUE bindval, binding_self = Qundef;
    rb_binding_t *bind;
    const rb_proc_t *proc;
    const rb_iseq_t *iseq = NULL;
    const struct rb_block *block;
    const rb_env_t *env = NULL;

    GetProcPtr(self, proc);
    block = &amp;proc-&gt;block;

  again:
    switch (vm_block_type(block)) {
      case block_type_iseq:
        iseq = block-&gt;as.captured.code.iseq;
        binding_self = block-&gt;as.captured.self;
        env = VM_ENV_ENVVAL_PTR(block-&gt;as.captured.ep);
        break;
      case block_type_proc:
        GetProcPtr(block-&gt;as.proc, proc);
        block = &amp;proc-&gt;block;
        goto again;
      case block_type_symbol:
        goto error;
      case block_type_ifunc:
        {
            const struct vm_ifunc *ifunc = block-&gt;as.captured.code.ifunc;
            if (IS_METHOD_PROC_IFUNC(ifunc)) {
                VALUE method = (VALUE)ifunc-&gt;data;
                VALUE name = rb_fstring_lit(&quot;&lt;empty_iseq&gt;&quot;);
                rb_iseq_t *empty;
                binding_self = method_receiver(method);
                iseq = rb_method_iseq(method);
                env = VM_ENV_ENVVAL_PTR(block-&gt;as.captured.ep);
                env = env_clone(env, method_cref(method));
                /* set empty iseq */
                empty = rb_iseq_new(NULL, name, name, Qnil, 0, ISEQ_TYPE_TOP);
                RB_OBJ_WRITE(env, &amp;env-&gt;iseq, empty);
                break;
            }
            else {
              error:
                rb_raise(rb_eArgError, &quot;Can&#39;t create Binding from C level Proc&quot;);
                return Qnil;
            }
        }
    }

    bindval = rb_binding_alloc(rb_cBinding);
    GetBindingPtr(bindval, bind);
    RB_OBJ_WRITE(bindval, &amp;bind-&gt;block.as.captured.self, binding_self);
    RB_OBJ_WRITE(bindval, &amp;bind-&gt;block.as.captured.code.iseq, env-&gt;iseq);
    rb_vm_block_ep_update(bindval, &amp;bind-&gt;block, env-&gt;ep);
    RB_OBJ_WRITTEN(bindval, Qundef, VM_ENV_ENVVAL(env-&gt;ep));

    if (iseq) {
        rb_iseq_check(iseq);
        RB_OBJ_WRITE(bindval, &amp;bind-&gt;pathobj, iseq-&gt;body-&gt;location.pathobj);
        bind-&gt;first_lineno = FIX2INT(rb_iseq_first_lineno(iseq));
    }
    else {
        RB_OBJ_WRITE(bindval, &amp;bind-&gt;pathobj,
                     rb_iseq_pathobj_new(rb_fstring_lit(&quot;(binding)&quot;), Qnil));
        bind-&gt;first_lineno = 1;
    }

    return bindval;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-call">
            
              <b>prc.call(params,...)   &rarr; obj<br />prc.(params,...)       &rarr; obj</b>
            
            <a href="../classes/Proc.html#method-i-call" name="method-i-call" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p>

<pre><code>a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</code></pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given.  It’s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc.  For procs created using <a href="Proc.html#method-c-new"><code>Proc.new</code></a> or <a href="Kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre><code>a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</code></pre>

<p>See also <a href="Proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Proc.html#method-i-5B-5D">[]</a>, <a href="Proc.html#method-i-3D-3D-3D">===</a>, <a href="Proc.html#method-i-yield">yield</a>
            </div>
          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-call_source')" id="l_method-i-call_source">show</a>
                
              </p>
              <div id="method-i-call_source" class="dyn-source">
                <pre>static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    /* removed */
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-curry">
            
              <b>prc.curry         &rarr; a_proc<br />prc.curry(arity)  &rarr; a_proc
</b>
            
            <a href="../classes/Proc.html#method-i-curry" name="method-i-curry" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a curried proc. If the optional <em>arity</em> argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments.</p>

<pre><code>b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; 6
p b.curry(5)[1][2][3][4][5]  #=&gt; 6
p b.curry(5)[1, 2][3, 4][5]  #=&gt; 6
p b.curry(1)[1]              #=&gt; 1

b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; 10
p b.curry(5)[1][2][3][4][5]  #=&gt; 15
p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
p b.curry(1)[1]              #=&gt; 1

b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; wrong number of arguments (given 4, expected 3)
p b.curry(5)                 #=&gt; wrong number of arguments (given 5, expected 3)
p b.curry(1)                 #=&gt; wrong number of arguments (given 1, expected 3)

b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; 10
p b.curry(5)[1][2][3][4][5]  #=&gt; 15
p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
p b.curry(1)                 #=&gt; wrong number of arguments (given 1, expected 3)

b = proc { :foo }
p b.curry[]                  #=&gt; :foo
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-curry_source')" id="l_method-i-curry_source">show</a>
                
              </p>
              <div id="method-i-curry_source" class="dyn-source">
                <pre>static VALUE
proc_curry(int argc, const VALUE *argv, VALUE self)
{
    int sarity, max_arity, min_arity = rb_proc_min_max_arity(self, &amp;max_arity);
    VALUE arity;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(arity = argv[0])) {
        arity = INT2FIX(min_arity);
    }
    else {
        sarity = FIX2INT(arity);
        if (rb_proc_lambda_p(self)) {
            rb_check_arity(sarity, min_arity, max_arity);
        }
    }

    return make_curry_proc(self, rb_ary_new(), arity);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-hash">
            
              <b>prc.hash   &rarr;  integer
</b>
            
            <a href="../classes/Proc.html#method-i-hash" name="method-i-hash" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a hash value corresponding to proc body.</p>

<p>See also <a href="Object.html#method-i-hash"><code>Object#hash</code></a>.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-hash_source')" id="l_method-i-hash_source">show</a>
                
              </p>
              <div id="method-i-hash_source" class="dyn-source">
                <pre>static VALUE
proc_hash(VALUE self)
{
    st_index_t hash;
    hash = rb_hash_start(0);
    hash = rb_hash_proc(hash, self);
    hash = rb_hash_end(hash);
    return ST2FIX(hash);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-inspect">
            
              <b>inspect</b>()
            
            <a href="../classes/Proc.html#method-i-inspect" name="method-i-inspect" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the unique identifier for this proc, along with an indication of where the proc was defined.</p>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Proc.html#method-i-to_s">to_s</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-lambda-3F">
            
              <b>prc.lambda? &rarr; true or false
</b>
            
            <a href="../classes/Proc.html#method-i-lambda-3F" name="method-i-lambda-3F" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns <code>true</code> if a <a href="Proc.html"><code>Proc</code></a> object is lambda. <code>false</code> if non-lambda.</p>

<p>The lambda-ness affects argument handling and the behavior of <code>return</code> and <code>break</code>.</p>

<p>A <a href="Proc.html"><code>Proc</code></a> object generated by <code>proc</code> ignores extra arguments.</p>

<pre><code>proc {|a,b| [a,b] }.call(1,2,3)    #=&gt; [1,2]
</code></pre>

<p>It provides <code>nil</code> for missing arguments.</p>

<pre><code>proc {|a,b| [a,b] }.call(1)        #=&gt; [1,nil]
</code></pre>

<p>It expands a single array argument.</p>

<pre><code>proc {|a,b| [a,b] }.call([1,2])    #=&gt; [1,2]
</code></pre>

<p>A <a href="Proc.html"><code>Proc</code></a> object generated by <code>lambda</code> doesn’t have such tricks.</p>

<pre><code>lambda {|a,b| [a,b] }.call(1,2,3)  #=&gt; ArgumentError
lambda {|a,b| [a,b] }.call(1)      #=&gt; ArgumentError
lambda {|a,b| [a,b] }.call([1,2])  #=&gt; ArgumentError
</code></pre>

<p><a href="Proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a> is a predicate for the tricks. It returns <code>true</code> if no tricks apply.</p>

<pre><code>lambda {}.lambda?            #=&gt; true
proc {}.lambda?              #=&gt; false
</code></pre>

<p><a href="Proc.html#method-c-new"><code>Proc.new</code></a> is the same as <code>proc</code>.</p>

<pre><code>Proc.new {}.lambda?          #=&gt; false
</code></pre>

<p><code>lambda</code>, <code>proc</code> and <a href="Proc.html#method-c-new"><code>Proc.new</code></a> preserve the tricks of a <a href="Proc.html"><code>Proc</code></a> object given by <code>&amp;</code> argument.</p>

<pre><code>lambda(&amp;lambda {}).lambda?   #=&gt; true
proc(&amp;lambda {}).lambda?     #=&gt; true
Proc.new(&amp;lambda {}).lambda? #=&gt; true

lambda(&amp;proc {}).lambda?     #=&gt; false
proc(&amp;proc {}).lambda?       #=&gt; false
Proc.new(&amp;proc {}).lambda?   #=&gt; false
</code></pre>

<p>A <a href="Proc.html"><code>Proc</code></a> object generated by <code>&amp;</code> argument has the tricks</p>

<pre><code>def n(&amp;b) b.lambda? end
n {}                         #=&gt; false
</code></pre>

<p>The <code>&amp;</code> argument preserves the tricks if a <a href="Proc.html"><code>Proc</code></a> object is given by <code>&amp;</code> argument.</p>

<pre><code>n(&amp;lambda {})                #=&gt; true
n(&amp;proc {})                  #=&gt; false
n(&amp;Proc.new {})              #=&gt; false
</code></pre>

<p>A <a href="Proc.html"><code>Proc</code></a> object converted from a method has no tricks.</p>

<pre><code>def m() end
method(:m).to_proc.lambda?   #=&gt; true

n(&amp;method(:m))               #=&gt; true
n(&amp;method(:m).to_proc)       #=&gt; true
</code></pre>

<p><code>define_method</code> is treated the same as method definition. The defined method has no tricks.</p>

<pre><code>class C
  define_method(:d) {}
end
C.new.d(1,2)       #=&gt; ArgumentError
C.new.method(:d).to_proc.lambda?   #=&gt; true
</code></pre>

<p><code>define_method</code> always defines a method without the tricks, even if a non-lambda <a href="Proc.html"><code>Proc</code></a> object is given. This is the only exception for which the tricks are not preserved.</p>

<pre><code>class C
  define_method(:e, &amp;proc {})
end
C.new.e(1,2)       #=&gt; ArgumentError
C.new.method(:e).to_proc.lambda?   #=&gt; true
</code></pre>

<p>This exception ensures that methods never have tricks and makes it easy to have wrappers to define methods that behave as usual.</p>

<pre><code>class C
  def self.def2(name, &amp;body)
    define_method(name, &amp;body)
  end

  def2(:f) {}
end
C.new.f(1,2)       #=&gt; ArgumentError
</code></pre>

<p>The wrapper <em>def2</em> defines a method which has no tricks.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-lambda-3F_source')" id="l_method-i-lambda-3F_source">show</a>
                
              </p>
              <div id="method-i-lambda-3F_source" class="dyn-source">
                <pre>VALUE
rb_proc_lambda_p(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    return proc-&gt;is_lambda ? Qtrue : Qfalse;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-parameters">
            
              <b>prc.parameters  &rarr; array
</b>
            
            <a href="../classes/Proc.html#method-i-parameters" name="method-i-parameters" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the parameter information of this proc.</p>

<pre><code>prc = lambda{|x, y=42, *other|}
prc.parameters  #=&gt; [[:req, :x], [:opt, :y], [:rest, :other]]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-parameters_source')" id="l_method-i-parameters_source">show</a>
                
              </p>
              <div id="method-i-parameters_source" class="dyn-source">
                <pre>static VALUE
rb_proc_parameters(VALUE self)
{
    int is_proc;
    const rb_iseq_t *iseq = rb_proc_get_iseq(self, &amp;is_proc);
    if (!iseq) {
        return rb_unnamed_parameters(rb_proc_arity(self));
    }
    return rb_iseq_parameters(iseq, is_proc);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-ruby2_keywords">
            
              <b>proc.ruby2_keywords &rarr; proc
</b>
            
            <a href="../classes/Proc.html#method-i-ruby2_keywords" name="method-i-ruby2_keywords" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Marks the proc as passing keywords through a normal argument splat. This should only be called on procs that accept an argument splat (<code>*args</code>) but not explicit keywords or a keyword splat.  It marks the proc such that if the proc is called with keyword arguments, the final hash argument is marked with a special flag such that if it is the final element of a normal argument splat to another method call, and that method call does not include explicit keywords or a keyword splat, the final element is interpreted as keywords.  In other words, keywords will be passed through the proc to other methods.</p>

<p>This should only be used for procs that delegate keywords to another method, and only for backwards compatibility with Ruby versions before 2.7.</p>

<p>This method will probably be removed at some point, as it exists only for backwards compatibility. As it does not exist in Ruby versions before 2.7, check that the proc responds to this method before calling it. Also, be aware that if this method is removed, the behavior of the proc will change so that it does not pass through keywords.</p>

<pre><code>module Mod
  foo = -&gt;(meth, *args, &amp;block) do
    send(:&quot;do_#{meth}&quot;, *args, &amp;block)
  end
  foo.ruby2_keywords if foo.respond_to?(:ruby2_keywords)
end
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-ruby2_keywords_source')" id="l_method-i-ruby2_keywords_source">show</a>
                
              </p>
              <div id="method-i-ruby2_keywords_source" class="dyn-source">
                <pre>static VALUE
proc_ruby2_keywords(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    rb_check_frozen(procval);

    if (proc-&gt;is_from_method) {
            rb_warn(&quot;Skipping set of ruby2_keywords flag for proc (proc created from method)&quot;);
            return procval;
    }

    switch (proc-&gt;block.type) {
      case block_type_iseq:
        if (proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.has_rest &amp;&amp;
                !proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.has_kw &amp;&amp;
                !proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.has_kwrest) {
            proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.ruby2_keywords = 1;
        }
        else {
            rb_warn(&quot;Skipping set of ruby2_keywords flag for proc (proc accepts keywords or proc does not accept argument splat)&quot;);
        }
        break;
      default:
        rb_warn(&quot;Skipping set of ruby2_keywords flag for proc (proc not defined in Ruby)&quot;);
        break;
    }

    return procval;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-source_location">
            
              <b>prc.source_location  &rarr; [String, Integer]
</b>
            
            <a href="../classes/Proc.html#method-i-source_location" name="method-i-source_location" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the Ruby source filename and line number containing this proc or <code>nil</code> if this proc was not defined in Ruby (i.e. native).</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-source_location_source')" id="l_method-i-source_location_source">show</a>
                
              </p>
              <div id="method-i-source_location_source" class="dyn-source">
                <pre>VALUE
rb_proc_location(VALUE self)
{
    return iseq_location(rb_proc_get_iseq(self, 0));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-to_proc">
            
              <b>prc.to_proc &rarr; proc
</b>
            
            <a href="../classes/Proc.html#method-i-to_proc" name="method-i-to_proc" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Part of the protocol for converting objects to <a href="Proc.html"><code>Proc</code></a> objects. Instances of class <a href="Proc.html"><code>Proc</code></a> simply return themselves.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-to_proc_source')" id="l_method-i-to_proc_source">show</a>
                
              </p>
              <div id="method-i-to_proc_source" class="dyn-source">
                <pre>static VALUE
proc_to_proc(VALUE self)
{
    return self;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-to_s">
            
              <b>prc.to_s   &rarr; string</b>
            
            <a href="../classes/Proc.html#method-i-to_s" name="method-i-to_s" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the unique identifier for this proc, along with an indication of where the proc was defined.</p>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Proc.html#method-i-inspect">inspect</a>
            </div>
          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-to_s_source')" id="l_method-i-to_s_source">show</a>
                
              </p>
              <div id="method-i-to_s_source" class="dyn-source">
                <pre>static VALUE
proc_to_s(VALUE self)
{
    const rb_proc_t *proc;
    GetProcPtr(self, proc);
    return rb_block_to_s(self, &amp;proc-&gt;block, proc-&gt;is_lambda ? &quot; (lambda)&quot; : NULL);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-yield">
            
              <b>prc.(params,...)       &rarr; obj<br />prc.yield(params,...)  &rarr; obj</b>
            
            <a href="../classes/Proc.html#method-i-yield" name="method-i-yield" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p>

<pre><code>a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</code></pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given.  It’s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc.  For procs created using <a href="Proc.html#method-c-new"><code>Proc.new</code></a> or <a href="Kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre><code>a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</code></pre>

<p>See also <a href="Proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Proc.html#method-i-call">call</a>
            </div>
          

          
          </div>
        
      
    
  
</div>

    </main>
  </body>
</html>
