<!DOCTYPE html>
<html lang="en">
<head>
    <title>ractor.md</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
<link rel="stylesheet" href="/css/reset.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/panel.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/github.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<script src="/js/jquery-3.5.1.min.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/main.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/highlight.pack.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/turbolinks.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/search_index.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searcher.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/panel/tree.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searchdoc.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>

<meta name="data-rel-prefix" content="/">
<meta name="data-tree-keys" content='[]'>

</head>

<body>
    <a class="sr-only sr-only-focusable" href="#content" data-turbolinks="false">Skip to Content</a>
    <a class="sr-only sr-only-focusable" href="#search" data-turbolinks="false">Skip to Search</a>

    <input type="checkbox" id="hamburger" class="panel_checkbox">
<label class="panel_mobile_button" for="hamburger"><span></span> Menu</label>
<nav class="panel panel_tree" id="panel" data-turbolinks-permanent>
  <div class="header">
    <input type="text" placeholder="Search (/) for a class, method, ..." autosave="searchdoc" results="10" id="search" autocomplete="off" tabindex="-1" />
    <label class="panel_mobile_button_close" for="hamburger"><span></span> Close</label>
  </div>
  <div class="tree">
    <ul>
    </ul>
  </div>
  <div class="result">
    <ul>
    </ul>
  </div>
  <a href="links.html" id="links">index</a>
</nav>


    <div class="banner">
        
        <h2>
            ractor.md
        </h2>
        <ul class="files">
            
            <li>
                ruby/doc/ractor.md
                
                    <a href="https://github.com/ruby/ruby/blob/9650d254d4539ed8201394bc9f639e78bac24b20/doc/ractor.md" target="_blank" class="github_url">on GitHub</a>
                
            </li>
            <li>Last modified: 2022-09-06 00:52:29 +0300</li>
        </ul>
    </div>

    <main id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Ractor+-+Ruby-27s+Actor-like+concurrent+abstraction"><a href="../../../classes/Ractor.html"><code>Ractor</code></a> - Ruby’s Actor-like concurrent abstraction</h1>

<p><a href="../../../classes/Ractor.html"><code>Ractor</code></a> is designed to provide a parallel execution feature of Ruby without thread-safety concerns.</p>

<h2 id="label-Summary">Summary</h2>

<h3 id="label-Multiple+Ractors+in+an+interpreter+process">Multiple Ractors in an interpreter process</h3>

<p>You can make multiple Ractors and they run in parallel.</p>
<ul><li>
<p><code>Ractor.new{ expr }</code> creates a new <a href="../../../classes/Ractor.html"><code>Ractor</code></a> and <code>expr</code> is run in parallel on a parallel computer.</p>
</li><li>
<p>Interpreter invokes with the first <a href="../../../classes/Ractor.html"><code>Ractor</code></a> (called <em>main Ractor</em>).</p>
</li><li>
<p>If main <a href="../../../classes/Ractor.html"><code>Ractor</code></a> terminated, all Ractors receive terminate request like Threads (if main thread (first invoked <a href="../../../classes/Thread.html"><code>Thread</code></a>), Ruby interpreter sends all running threads to terminate execution).</p>
</li><li>
<p>Each <a href="../../../classes/Ractor.html"><code>Ractor</code></a> has 1 or more Threads.</p>
</li><li>
<p>Threads in a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> shares a Ractor-wide global lock like GIL (GVL in MRI terminology), so they can’t run in parallel (without releasing GVL explicitly in C-level). Threads in different ractors run in parallel.</p>
</li><li>
<p>The overhead of creating a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> is similar to overhead of one <a href="../../../classes/Thread.html"><code>Thread</code></a> creation.</p>
</li></ul>

<h3 id="label-Limited+sharing+between+multiple+ractors">Limited sharing between multiple ractors</h3>

<p>Ractors don’t share everything, unlike threads.</p>
<ul><li>
<p>Most objects are <em>Unshareable objects</em>, so you don’t need to care about thread-safety problems which are caused by sharing.</p>
</li><li>
<p>Some objects are <em>Shareable objects</em>.</p>
</li><li>
<p>Immutable objects: frozen objects which don’t refer to unshareable-objects.</p>
<ul><li>
<p><code>i = 123</code>: <code>i</code> is an immutable object.</p>
</li><li>
<p><code>s = &quot;str&quot;.freeze</code>: <code>s</code> is an immutable object.</p>
</li><li>
<p><code>a = [1, [2], 3].freeze</code>: <code>a</code> is not an immutable object because <code>a</code> refers unshareable-object <code>[2]</code> (which is not frozen).</p>
</li><li>
<p><code>h = {c: Object}.freeze</code>: <code>h</code> is an immutable object because <code>h</code> refers <a href="../../../classes/Symbol.html"><code>Symbol</code></a> <code>:c</code> and shareable <code>Object</code> class object which is not frozen.</p>
</li></ul>
</li><li>
<p>Class/Module objects</p>
</li><li>
<p>Special shareable objects</p>
<ul><li>
<p><a href="../../../classes/Ractor.html"><code>Ractor</code></a> object itself.</p>
</li><li>
<p>And more…</p>
</li></ul>
</li></ul>

<h3 id="label-Two-types+communication+between+Ractors">Two-types communication between Ractors</h3>

<p>Ractors communicate with each other and synchronize the execution by message exchanging between Ractors. There are two message exchange protocols: push type (message passing) and pull type.</p>
<ul><li>
<p>Push type message passing: <code>Ractor#send(obj)</code> and <code>Ractor.receive()</code> pair.</p>
</li><li>
<p>Sender ractor passes the <code>obj</code> to the ractor <code>r</code> by <code>r.send(obj)</code> and receiver ractor receives the message with <code>Ractor.receive</code>.</p>
</li><li>
<p>Sender knows the destination <a href="../../../classes/Ractor.html"><code>Ractor</code></a> <code>r</code> and the receiver does not know the sender (accept all messages from any ractors).</p>
</li><li>
<p>Receiver has infinite queue and sender enqueues the message. Sender doesn’t block to put message into this queue.</p>
</li><li>
<p>This type of message exchanging is employed by many other Actor-based languages.</p>
</li><li>
<p><code>Ractor.receive_if{ filter_expr }</code> is a variant of <code>Ractor.receive</code> to select a message.</p>
</li><li>
<p>Pull type communication: <code>Ractor.yield(obj)</code> and <code>Ractor#take()</code> pair.</p>
</li><li>
<p>Sender ractor declare to yield the <code>obj</code> by <code>Ractor.yield(obj)</code> and receiver <a href="../../../classes/Ractor.html"><code>Ractor</code></a> take it with <code>r.take</code>.</p>
</li><li>
<p>Sender doesn’t know a destination <a href="../../../classes/Ractor.html"><code>Ractor</code></a> and receiver knows the sender <a href="../../../classes/Ractor.html"><code>Ractor</code></a> <code>r</code>.</p>
</li><li>
<p>Sender or receiver will block if there is no other side.</p>
</li></ul>

<h3 id="label-Copy+-26+Move+semantics+to+send+messages">Copy &amp; Move semantics to send messages</h3>

<p>To send unshareable objects as messages, objects are copied or moved.</p>
<ul><li>
<p>Copy: use deep-copy.</p>
</li><li>
<p>Move: move membership.</p>
</li><li>
<p>Sender can not access the moved object after moving the object.</p>
</li><li>
<p>Guarantee that at least only 1 <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can access the object.</p>
</li></ul>

<h3 id="label-Thread-safety">Thread-safety</h3>

<p><a href="../../../classes/Ractor.html"><code>Ractor</code></a> helps to write a thread-safe concurrent program, but we can make thread-unsafe programs with Ractors.</p>
<ul><li>
<p>GOOD: Sharing limitation</p>
</li><li>
<p>Most objects are unshareable, so we can’t make data-racy and race-conditional programs.</p>
</li><li>
<p>Shareable objects are protected by an interpreter or locking mechanism.</p>
</li><li>
<p>BAD: Class/Module can violate this assumption</p>
</li><li>
<p>To make it compatible with old behavior, classes and modules can introduce data-race and so on.</p>
</li><li>
<p>Ruby programmers should take care if they modify class/module objects on multi <a href="../../../classes/Ractor.html"><code>Ractor</code></a> programs.</p>
</li><li>
<p>BAD: <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can’t solve all thread-safety problems</p>
</li><li>
<p>There are several blocking operations (waiting send, waiting yield and waiting take) so you can make a program which has dead-lock and live-lock issues.</p>
</li><li>
<p>Some kind of shareable objects can introduce transactions (STM, for example). However, misusing transactions will generate inconsistent state.</p>
</li></ul>

<p>Without <a href="../../../classes/Ractor.html"><code>Ractor</code></a>, we need to trace all state-mutations to debug thread-safety issues. With <a href="../../../classes/Ractor.html"><code>Ractor</code></a>, you can concentrate on suspicious code which are shared with Ractors.</p>

<h2 id="label-Creation+and+termination">Creation and termination</h2>

<h3 id="label-Ractor.new"><code>Ractor.new</code></h3>
<ul><li>
<p><code>Ractor.new{ expr }</code> generates another <a href="../../../classes/Ractor.html"><code>Ractor</code></a>.</p>
</li></ul>

<pre><code># Ractor.new with a block creates new Ractor
r = Ractor.new do
  # This block will be run in parallel with other ractors
end

# You can name a Ractor with `name:` argument.
r = Ractor.new name: &#39;test-name&#39; do
end

# and Ractor#name returns its name.
r.name #=&gt; &#39;test-name&#39;
</code></pre>

<h3 id="label-Given+block+isolation">Given block isolation</h3>

<p>The <a href="../../../classes/Ractor.html"><code>Ractor</code></a> executes given <code>expr</code> in a given block. Given block will be isolated from outer scope by the <code>Proc#isolate</code> method (not exposed yet for Ruby users). To prevent sharing unshareable objects between ractors, block outer-variables, <code>self</code> and other information are isolated.</p>

<p><code>Proc#isolate</code> is called at <a href="../../../classes/Ractor.html"><code>Ractor</code></a> creation time (when <code>Ractor.new</code> is called). If given <a href="../../../classes/Proc.html"><code>Proc</code></a> object is not able to isolate because of outer variables and so on, an error will be raised.</p>

<pre><code>begin
  a = true
  r = Ractor.new do
    a #=&gt; ArgumentError because this block accesses `a`.
  end
  r.take # see later
rescue ArgumentError
end
</code></pre>
<ul><li>
<p>The <code>self</code> of the given block is the <code>Ractor</code> object itself.</p>
</li></ul>

<pre><code>r = Ractor.new do
  p self.class #=&gt; Ractor
  self.object_id
end
r.take == self.object_id #=&gt; false
</code></pre>

<p>Passed arguments to <code>Ractor.new()</code> becomes block parameters for the given block. However, an interpreter does not pass the parameter object references, but send them as messages (see below for details).</p>

<pre><code>r = Ractor.new &#39;ok&#39; do |msg|
  msg #=&gt; &#39;ok&#39;
end
r.take #=&gt; &#39;ok&#39;
</code></pre>

<pre><code># almost similar to the last example
r = Ractor.new do
  msg = Ractor.receive
  msg
end
r.send &#39;ok&#39;
r.take #=&gt; &#39;ok&#39;
</code></pre>

<h3 id="label-An+execution+result+of+given+block">An execution result of given block</h3>

<p>Return value of the given block becomes an outgoing message (see below for details).</p>

<pre><code>r = Ractor.new do
  &#39;ok&#39;
end
r.take #=&gt; `ok`
</code></pre>

<pre><code># almost similar to the last example
r = Ractor.new do
  Ractor.yield &#39;ok&#39;
end
r.take #=&gt; &#39;ok&#39;
</code></pre>

<p>Error in the given block will be propagated to the receiver of an outgoing message.</p>

<pre><code>r = Ractor.new do
  raise &#39;ok&#39; # exception will be transferred to the receiver
end

begin
  r.take
rescue Ractor::RemoteError =&gt; e
  e.cause.class   #=&gt; RuntimeError
  e.cause.message #=&gt; &#39;ok&#39;
  e.ractor        #=&gt; r
end
</code></pre>

<h2 id="label-Communication+between+Ractors">Communication between Ractors</h2>

<p>Communication between Ractors is achieved by sending and receiving messages. There are two ways to communicate with each other.</p>
<ul><li>
<p>(1) Message sending/receiving</p>
</li><li>
<p>(1-1) push type send/receive (sender knows receiver). similar to the Actor model.</p>
</li><li>
<p>(1-2) pull type yield/take (receiver knows sender).</p>
</li><li>
<p>(2) Using shareable container objects</p>
</li><li>
<p>Ractor::TVar gem (<a href="https://github.com/ko1/ractor-tvar">ko1/ractor-tvar</a>)</p>
</li><li>
<p>more?</p>
</li></ul>

<p>Users can control program execution timing with (1), but should not control with (2) (only manage as critical section).</p>

<p>For message sending and receiving, there are two types of APIs: push type and pull type.</p>
<ul><li>
<p>(1-1) send/receive (push type)</p>
</li><li>
<p><code>Ractor#send(obj)</code> (<code>Ractor#&lt;&lt;(obj)</code> is an alias) send a message to the Ractor’s incoming port. Incoming port is connected to the infinite size incoming queue so <code>Ractor#send</code> will never block.</p>
</li><li>
<p><code>Ractor.receive</code> dequeue a message from its own incoming queue. If the incoming queue is empty, <code>Ractor.receive</code> calling will block.</p>
</li><li>
<p><code>Ractor.receive_if{|msg| filter_expr }</code> is variant of <code>Ractor.receive</code>. <code>receive_if</code> only receives a message which <code>filter_expr</code> is true (So <code>Ractor.receive</code> is the same as <code>Ractor.receive_if{ true }</code>.</p>
</li><li>
<p>(1-2) yield/take (pull type)</p>
</li><li>
<p><code>Ractor.yield(obj)</code> send an message to a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> which are calling <code>Ractor#take</code> via outgoing port . If no Ractors are waiting for it, the <code>Ractor.yield(obj)</code> will block. If multiple Ractors are waiting for <code>Ractor.yield(obj)</code>, only one <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can receive the message.</p>
</li><li>
<p><code>Ractor#take</code> receives a message which is waiting by <code>Ractor.yield(obj)</code> method from the specified <a href="../../../classes/Ractor.html"><code>Ractor</code></a>. If the <a href="../../../classes/Ractor.html"><code>Ractor</code></a> does not call <code>Ractor.yield</code> yet, the <code>Ractor#take</code> call will block.</p>
</li><li>
<p><code>Ractor.select()</code> can wait for the success of <code>take</code>, <code>yield</code> and <code>receive</code>.</p>
</li><li>
<p>You can close the incoming port or outgoing port.</p>
</li><li>
<p>You can close then with <code>Ractor#close_incoming</code> and <code>Ractor#close_outgoing</code>.</p>
</li><li>
<p>If the incoming port is closed for a <a href="../../../classes/Ractor.html"><code>Ractor</code></a>, you can’t <code>send</code> to the <a href="../../../classes/Ractor.html"><code>Ractor</code></a>. If <code>Ractor.receive</code> is blocked for the closed incoming port, then it will raise an exception.</p>
</li><li>
<p>If the outgoing port is closed for a <a href="../../../classes/Ractor.html"><code>Ractor</code></a>, you can’t call <code>Ractor#take</code> and <code>Ractor.yield</code> on the <a href="../../../classes/Ractor.html"><code>Ractor</code></a>. If ractors are blocking by <code>Ractor#take</code> or <code>Ractor.yield</code>, closing outgoing port will raise an exception on these blocking ractors.</p>
</li><li>
<p>When a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> is terminated, the Ractor’s ports are closed.</p>
</li><li>
<p>There are 3 ways to send an object as a message</p>
</li><li>
<p>(1) Send a reference: Sending a shareable object, send only a reference to the object (fast)</p>
</li><li>
<p>(2) Copy an object: Sending an unshareable object by copying an object deeply (slow). Note that you can not send an object which does not support deep copy. Some <code>T_DATA</code> objects are not supported.</p>
</li><li>
<p>(3) Move an object: Sending an unshareable object reference with a membership. Sender <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can not access moved objects anymore (raise an exception) after moving it. Current implementation makes new object as a moved object for receiver <a href="../../../classes/Ractor.html"><code>Ractor</code></a> and copies references of sending object to moved object.</p>
</li><li>
<p>You can choose “Copy” and “Move” by the <code>move:</code> keyword, <code>Ractor#send(obj, move: true/false)</code> and <code>Ractor.yield(obj, move: true/false)</code> (default is <code>false</code> (COPY)).</p>
</li></ul>

<h3 id="label-Sending-2FReceiving+ports">Sending/Receiving ports</h3>

<p>Each <a href="../../../classes/Ractor.html"><code>Ractor</code></a> has <em>incoming-port</em> and <em>outgoing-port</em>. Incoming-port is connected to the infinite sized incoming queue.</p>

<pre><code>Ractor r
                 +-------------------------------------------+
                 | incoming                         outgoing |
                 | port                                 port |
   r.send(obj) -&gt;*-&gt;[incoming queue]     Ractor.yield(obj) -&gt;*-&gt; r.take
                 |                |                          |
                 |                v                          |
                 |           Ractor.receive                  |
                 +-------------------------------------------+


Connection example: r2.send obj on r1、Ractor.receive on r2
  +----+     +----+
  * r1 |----&gt;* r2 *
  +----+     +----+


Connection example: Ractor.yield(obj) on r1, r1.take on r2
  +----+     +----+
  * r1 *----&gt;- r2 *
  +----+     +----+

Connection example: Ractor.yield(obj) on r1 and r2,
                    and waiting for both simultaneously by Ractor.select(r1, r2)

  +----+
  * r1 *------+
  +----+      |
              +----&gt; Ractor.select(r1, r2)
  +----+      |
  * r2 *------|
  +----+
</code></pre>

<pre><code>r = Ractor.new do
  msg = Ractor.receive # Receive from r&#39;s incoming queue
  msg # send back msg as block return value
end
r.send &#39;ok&#39; # Send &#39;ok&#39; to r&#39;s incoming port -&gt; incoming queue
r.take      # Receive from r&#39;s outgoing port
</code></pre>

<p>The last example shows the following ractor network.</p>

<pre><code>
  +------+        +---+
  * main |------&gt; * r *---+
  +------+        +---+   |
      ^                   |
      +-------------------+
</code></pre>

<p>And this code can be simplified by using an argument for <code>Ractor.new</code>.</p>

<pre><code># Actual argument &#39;ok&#39; for `Ractor.new()` will be sent to created Ractor.
r = Ractor.new &#39;ok&#39; do |msg|
  # Values for formal parameters will be received from incoming queue.
  # Similar to: msg = Ractor.receive

  msg # Return value of the given block will be sent via outgoing port
end

# receive from the r&#39;s outgoing port.
r.take #=&gt; `ok`
</code></pre>

<h3 id="label-Return+value+of+a+block+for+Ractor.new">Return value of a block for <code>Ractor.new</code></h3>

<p>As already explained, the return value of <code>Ractor.new</code> (an evaluated value of <code>expr</code> in <code>Ractor.new{ expr }</code>) can be taken by <code>Ractor#take</code>.</p>

<pre><code>Ractor.new{ 42 }.take #=&gt; 42
</code></pre>

<p>When the block return value is available, the <a href="../../../classes/Ractor.html"><code>Ractor</code></a> is dead so that no ractors except taken <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can touch the return value, so any values can be sent with this communication path without any modification.</p>

<pre><code>r = Ractor.new do
  a = &quot;hello&quot;
  binding
end

r.take.eval(&quot;p a&quot;) #=&gt; &quot;hello&quot; (other communication path can not send a Binding object directly)
</code></pre>

<h3 id="label-Wait+for+multiple+Ractors+with+Ractor.select">Wait for multiple Ractors with <code>Ractor.select</code></h3>

<p>You can wait multiple Ractor’s <code>yield</code> with <code>Ractor.select(*ractors)</code>. The return value of <code>Ractor.select()</code> is <code>[r, msg]</code> where <code>r</code> is yielding <a href="../../../classes/Ractor.html"><code>Ractor</code></a> and <code>msg</code> is yielded message.</p>

<p>Wait for a single ractor (same as <code>Ractor.take</code>):</p>

<pre><code>r1 = Ractor.new{&#39;r1&#39;}

r, obj = Ractor.select(r1)
r == r1 and obj == &#39;r1&#39; #=&gt; true
</code></pre>

<p>Wait for two ractors:</p>

<pre><code>r1 = Ractor.new{&#39;r1&#39;}
r2 = Ractor.new{&#39;r2&#39;}
rs = [r1, r2]
as = []

# Wait for r1 or r2&#39;s Ractor.yield
r, obj = Ractor.select(*rs)
rs.delete(r)
as &lt;&lt; obj

# Second try (rs only contain not-closed ractors)
r, obj = Ractor.select(*rs)
rs.delete(r)
as &lt;&lt; obj
as.sort == [&#39;r1&#39;, &#39;r2&#39;] #=&gt; true
</code></pre>

<p><a href="../../../classes/Complex.html"><code>Complex</code></a> example:</p>

<pre><code>pipe = Ractor.new do
  loop do
    Ractor.yield Ractor.receive
  end
end

RN = 10
rs = RN.times.map{|i|
  Ractor.new pipe, i do |pipe, i|
    msg = pipe.take
    msg # ping-pong
  end
}
RN.times{|i|
  pipe &lt;&lt; i
}
RN.times.map{
  r, n = Ractor.select(*rs)
  rs.delete r
  n
}.sort #=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>Multiple Ractors can send to one <a href="../../../classes/Ractor.html"><code>Ractor</code></a>.</p>

<pre><code># Create 10 ractors and they send objects to pipe ractor.
# pipe ractor yield received objects

pipe = Ractor.new do
  loop do
    Ractor.yield Ractor.receive
  end
end

RN = 10
rs = RN.times.map{|i|
  Ractor.new pipe, i do |pipe, i|
    pipe &lt;&lt; i
  end
}

RN.times.map{
  pipe.take
}.sort #=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>TODO: Current <code>Ractor.select()</code> has the same issue of <code>select(2)</code>, so this interface should be refined.</p>

<p>TODO: <code>select</code> syntax of go-language uses round-robin technique to make fair scheduling. Now <code>Ractor.select()</code> doesn’t use it.</p>

<h3 id="label-Closing+Ractor-27s+ports">Closing Ractor’s ports</h3>
<ul><li>
<p><code>Ractor#close_incoming/outgoing</code> close incoming/outgoing ports (similar to <code>Queue#close</code>).</p>
</li><li>
<p><code>Ractor#close_incoming</code></p>
</li><li>
<p><code>r.send(obj)</code> where <code>r</code>‘s incoming port is closed, will raise an exception.</p>
</li><li>
<p>When the incoming queue is empty and incoming port is closed, <code>Ractor.receive</code> raises an exception. If the incoming queue is not empty, it dequeues an object without exceptions.</p>
</li><li>
<p><code>Ractor#close_outgoing</code></p>
</li><li>
<p><code>Ractor.yield</code> on a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> which closed the outgoing port, it will raise an exception.</p>
</li><li>
<p><code>Ractor#take</code> for a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> which closed the outgoing port, it will raise an exception. If <code>Ractor#take</code> is blocking, it will raise an exception.</p>
</li><li>
<p>When a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> terminates, the ports are closed automatically.</p>
</li><li>
<p>Return value of the Ractor’s block will be yielded as <code>Ractor.yield(ret_val)</code>, even if the implementation terminates the based native thread.</p>
</li></ul>

<p>Example (try to take from closed <a href="../../../classes/Ractor.html"><code>Ractor</code></a>):</p>

<pre><code>r = Ractor.new do
  &#39;finish&#39;
end
r.take # success (will return &#39;finish&#39;)
begin
  o = r.take # try to take from closed Ractor
rescue Ractor::ClosedError
  &#39;ok&#39;
else
  &quot;ng: #{o}&quot;
end
</code></pre>

<p>Example (try to send to closed (terminated) <a href="../../../classes/Ractor.html"><code>Ractor</code></a>):</p>

<pre><code>r = Ractor.new do
end

r.take # wait terminate

begin
  r.send(1)
rescue Ractor::ClosedError
  &#39;ok&#39;
else
  &#39;ng&#39;
end
</code></pre>

<p>When multiple Ractors are waiting for <code>Ractor.yield()</code>, <code>Ractor#close_outgoing</code> will cancel all blocking by raising an exception (<code>ClosedError</code>).</p>

<h3 id="label-Send+a+message+by+copying">Send a message by copying</h3>

<p><code>Ractor#send(obj)</code> or <code>Ractor.yield(obj)</code> copy <code>obj</code> deeply if <code>obj</code> is an unshareable object.</p>

<pre><code>obj = &#39;str&#39;.dup
r = Ractor.new obj do |msg|
  # return received msg&#39;s object_id
  msg.object_id
end

obj.object_id == r.take #=&gt; false
</code></pre>

<p>Some objects are not supported to copy the value, and raise an exception.</p>

<pre><code>obj = Thread.new{}
begin
  Ractor.new obj do |msg|
    msg
  end
rescue TypeError =&gt; e
  e.message #=&gt; #&lt;TypeError: allocator undefined for Thread&gt;
else
  &#39;ng&#39; # unreachable here
end
</code></pre>

<h3 id="label-Send+a+message+by+moving">Send a message by moving</h3>

<p><code>Ractor#send(obj, move: true)</code> or <code>Ractor.yield(obj, move: true)</code> move <code>obj</code> to the destination <a href="../../../classes/Ractor.html"><code>Ractor</code></a>. If the source <a href="../../../classes/Ractor.html"><code>Ractor</code></a> touches the moved object (for example, call the method like <code>obj.foo()</code>), it will be an error.</p>

<pre><code># move with Ractor#send
r = Ractor.new do
  obj = Ractor.receive
  obj &lt;&lt; &#39; world&#39;
end

str = &#39;hello&#39;
r.send str, move: true
modified = r.take #=&gt; &#39;hello world&#39;

# str is moved, and accessing str from this Ractor is prohibited

begin
  # Error because it touches moved str.
  str &lt;&lt; &#39; exception&#39; # raise Ractor::MovedError
rescue Ractor::MovedError
  modified #=&gt; &#39;hello world&#39;
else
  raise &#39;unreachable&#39;
end
</code></pre>

<pre><code># move with Ractor.yield
r = Ractor.new do
  obj = &#39;hello&#39;
  Ractor.yield obj, move: true
  obj &lt;&lt; &#39;world&#39;  # raise Ractor::MovedError
end

str = r.take
begin
  r.take
rescue Ractor::RemoteError
  p str #=&gt; &quot;hello&quot;
end
</code></pre>

<p>Some objects are not supported to move, and an exception will be raised.</p>

<pre><code>r = Ractor.new do
  Ractor.receive
end

r.send(Thread.new{}, move: true) #=&gt; allocator undefined for Thread (TypeError)
</code></pre>

<p>To achieve the access prohibition for moved objects, <em>class replacement</em> technique is used to implement it.</p>

<h3 id="label-Shareable+objects">Shareable objects</h3>

<p>The following objects are shareable.</p>
<ul><li>
<p>Immutable objects</p>
</li><li>
<p>Small integers, some symbols, <code>true</code>, <code>false</code>, <code>nil</code> (a.k.a. <code>SPECIAL_CONST_P()</code> objects in internal)</p>
</li><li>
<p>Frozen native objects</p>
<ul><li>
<p><a href="../../../classes/Numeric.html"><code>Numeric</code></a> objects: <code>Float</code>, <code>Complex</code>, <code>Rational</code>, big integers (<code>T_BIGNUM</code> in internal)</p>
</li><li>
<p>All Symbols.</p>
</li></ul>
</li><li>
<p>Frozen <code>String</code> and <code>Regexp</code> objects (their instance variables should refer only shareable objects)</p>
</li><li>
<p><a href="../../../classes/Class.html"><code>Class</code></a>, <a href="../../../classes/Module.html"><code>Module</code></a> objects (<code>T_CLASS</code>, <code>T_MODULE</code> and <code>T_ICLASS</code> in internal)</p>
</li><li>
<p><code>Ractor</code> and other special objects which care about synchronization.</p>
</li></ul>

<p>Implementation: Now shareable objects (<code>RVALUE</code>) have <code>FL_SHAREABLE</code> flag. This flag can be added lazily.</p>

<p>To make shareable objects, <code>Ractor.make_shareable(obj)</code> method is provided. In this case, try to make sharaeble by freezing <code>obj</code> and recursively travasible objects. This method accepts <code>copy:</code> keyword (default value is false).<code>Ractor.make_shareable(obj, copy: true)</code> tries to make a deep copy of <code>obj</code> and make the copied object shareable.</p>

<h2 id="label-Language+changes+to+isolate+unshareable+objects+between+Ractors">Language changes to isolate unshareable objects between Ractors</h2>

<p>To isolate unshareable objects between Ractors, we introduced additional language semantics on multi-Ractor Ruby programs.</p>

<p>Note that without using Ractors, these additional semantics is not needed (100% compatible with Ruby 2).</p>

<h3 id="label-Global+variables">Global variables</h3>

<p>Only the main <a href="../../../classes/Ractor.html"><code>Ractor</code></a> (a <a href="../../../classes/Ractor.html"><code>Ractor</code></a> created at starting of interpreter) can access global variables.</p>

<pre><code>$gv = 1
r = Ractor.new do
  $gv
end

begin
  r.take
rescue Ractor::RemoteError =&gt; e
  e.cause.message #=&gt; &#39;can not access global variables from non-main Ractors&#39;
end
</code></pre>

<p>Note that some special global variables are ractor-local, like <code>$stdin</code>, <code>$stdout</code>, <code>$stderr</code>. See <a href="https://bugs.ruby-lang.org/issues/17268">[Bug #17268]</a> for more details.</p>

<h3 id="label-Instance+variables+of+shareable+objects">Instance variables of shareable objects</h3>

<p>Instance variables of classes/modules can be get from non-main Ractors if the referring values are shareable objects.</p>

<pre><code>class C
  @iv = 1
end

p Ractor.new do
  class C
     @iv
  end
end.take #=&gt; 1
</code></pre>

<p>Otherwise, only the main <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can access instance variables of shareable objects.</p>

<pre><code>class C
  @iv = [] # unshareable object
end

Ractor.new do
  class C
    begin
      p @iv
    rescue Ractor::IsolationError
      p $!.message
      #=&gt; &quot;can not get unshareable values from instance variables of classes/modules from non-main Ractors&quot;
    end

    begin
      @iv = 42
    rescue Ractor::IsolationError
      p $!.message
      #=&gt; &quot;can not set instance variables of classes/modules by non-main Ractors&quot;
    end
  end
end.take
</code></pre>

<pre><code>shared = Ractor.new{}
shared.instance_variable_set(:@iv, &#39;str&#39;)

r = Ractor.new shared do |shared|
  p shared.instance_variable_get(:@iv)
end

begin
  r.take
rescue Ractor::RemoteError =&gt; e
  e.cause.message #=&gt; can not access instance variables of shareable objects from non-main Ractors (Ractor::IsolationError)
end
</code></pre>

<p>Note that instance variables for class/module objects are also prohibited on Ractors.</p>

<h3 id="label-Class+variables"><a href="../../../classes/Class.html"><code>Class</code></a> variables</h3>

<p>Only the main <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can access class variables.</p>

<pre><code>class C
  @@cv = &#39;str&#39;
end

r = Ractor.new do
  class C
    p @@cv
  end
end


begin
  r.take
rescue =&gt; e
  e.class #=&gt; Ractor::IsolationError
end
</code></pre>

<h3 id="label-Constants">Constants</h3>

<p>Only the main <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can read constants which refer to the unshareable object.</p>

<pre><code>class C
  CONST = &#39;str&#39;
end
r = Ractor.new do
  C::CONST
end
begin
  r.take
rescue =&gt; e
  e.class #=&gt; Ractor::IsolationError
end
</code></pre>

<p>Only the main <a href="../../../classes/Ractor.html"><code>Ractor</code></a> can define constants which refer to the unshareable object.</p>

<pre><code>class C
end
r = Ractor.new do
  C::CONST = &#39;str&#39;
end
begin
  r.take
rescue =&gt; e
  e.class #=&gt; Ractor::IsolationError
end
</code></pre>

<p>To make multi-ractor supported library, the constants should only refer shareable objects.</p>

<pre><code>TABLE = {a: &#39;ko1&#39;, b: &#39;ko2&#39;, c: &#39;ko3&#39;}
</code></pre>

<p>In this case, <code>TABLE</code> references an unshareable <a href="../../../classes/Hash.html"><code>Hash</code></a> object. So that other ractors can not refer <code>TABLE</code> constant. To make it shareable, we can use <code>Ractor.make_shareable()</code> like that.</p>

<pre><code>TABLE = Ractor.make_shareable( {a: &#39;ko1&#39;, b: &#39;ko2&#39;, c: &#39;ko3&#39;} )
</code></pre>

<p>To make it easy, Ruby 3.0 introduced new <code>shareable_constant_value</code> Directive.</p>

<pre><code># shareable_constant_value: literal

TABLE = {a: &#39;ko1&#39;, b: &#39;ko2&#39;, c: &#39;ko3&#39;}
#=&gt; Same as: TABLE = Ractor.make_shareable( {a: &#39;ko1&#39;, b: &#39;ko2&#39;, c: &#39;ko3&#39;} )
</code></pre>

<p><code>shareable_constant_value</code> directive accepts the following modes (descriptions use the example: <code>CONST = expr</code>):</p>
<ul><li>
<p>none: Do nothing. Same as: <code>CONST = expr</code></p>
</li><li>
<p>literal:</p>
</li><li>
<p>if <code>expr</code> is consites of literals, replaced to <code>CONST = Ractor.make_shareable(expr)</code>.</p>
</li><li>
<p>otherwise: replaced to <code>CONST = expr.tap{|o| raise unless Ractor.shareable?}</code>.</p>
</li><li>
<p>experimental_everything: replaced to <code>CONST = Ractor.make_shareable(expr)</code>.</p>
</li><li>
<p>experimental_copy: replaced to <code>CONST = Ractor.make_shareable(expr, copy: true)</code>.</p>
</li></ul>

<p>Except the <code>none</code> mode (default), it is guaranteed that the assigned constants refer to only shareable objects.</p>

<p>See <a href="syntax/comments_rdoc.html">doc/syntax/comments.rdoc</a> for more details.</p>

<h2 id="label-Implementation+note">Implementation note</h2>
<ul><li>
<p>Each <a href="../../../classes/Ractor.html"><code>Ractor</code></a> has its own thread, it means each <a href="../../../classes/Ractor.html"><code>Ractor</code></a> has at least 1 native thread.</p>
</li><li>
<p>Each <a href="../../../classes/Ractor.html"><code>Ractor</code></a> has its own ID (<code>rb_ractor_t::pub::id</code>).</p>
</li><li>
<p>On debug mode, all unshareable objects are labeled with current Ractor’s id, and it is checked to detect unshareable object leak (access an object from different <a href="../../../classes/Ractor.html"><code>Ractor</code></a>) in VM.</p>
</li></ul>

<h2 id="label-Examples">Examples</h2>

<h3 id="label-Traditional+Ring+example+in+Actor-model">Traditional Ring example in Actor-model</h3>

<pre><code>RN = 1_000
CR = Ractor.current

r = Ractor.new do
  p Ractor.receive
  CR &lt;&lt; :fin
end

RN.times{
  r = Ractor.new r do |next_r|
    next_r &lt;&lt; Ractor.receive
  end
}

p :setup_ok
r &lt;&lt; 1
p Ractor.receive
</code></pre>

<h3 id="label-Fork-join">Fork-join</h3>

<pre><code>def fib n
  if n &lt; 2
    1
  else
    fib(n-2) + fib(n-1)
  end
end

RN = 10
rs = (1..RN).map do |i|
  Ractor.new i do |i|
    [i, fib(i)]
  end
end

until rs.empty?
  r, v = Ractor.select(*rs)
  rs.delete r
  p answer: v
end
</code></pre>

<h3 id="label-Worker+pool">Worker pool</h3>

<pre><code>require &#39;prime&#39;

pipe = Ractor.new do
  loop do
    Ractor.yield Ractor.receive
  end
end

N = 1000
RN = 10
workers = (1..RN).map do
  Ractor.new pipe do |pipe|
    while n = pipe.take
      Ractor.yield [n, n.prime?]
    end
  end
end

(1..N).each{|i|
  pipe &lt;&lt; i
}

pp (1..N).map{
  _r, (n, b) = Ractor.select(*workers)
  [n, b]
}.sort_by{|(n, b)| n}
</code></pre>

<h3 id="label-Pipeline">Pipeline</h3>

<pre><code># pipeline with yield/take
r1 = Ractor.new do
  &#39;r1&#39;
end

r2 = Ractor.new r1 do |r1|
  r1.take + &#39;r2&#39;
end

r3 = Ractor.new r2 do |r2|
  r2.take + &#39;r3&#39;
end

p r3.take #=&gt; &#39;r1r2r3&#39;
</code></pre>

<pre><code># pipeline with send/receive

r3 = Ractor.new Ractor.current do |cr|
  cr.send Ractor.receive + &#39;r3&#39;
end

r2 = Ractor.new r3 do |r3|
  r3.send Ractor.receive + &#39;r2&#39;
end

r1 = Ractor.new r2 do |r2|
  r2.send Ractor.receive + &#39;r1&#39;
end

r1 &lt;&lt; &#39;r0&#39;
p Ractor.receive #=&gt; &quot;r0r1r2r3&quot;
</code></pre>

<h3 id="label-Supervise">Supervise</h3>

<pre><code># ring example again

r = Ractor.current
(1..10).map{|i|
  r = Ractor.new r, i do |r, i|
    r.send Ractor.receive + &quot;r#{i}&quot;
  end
}

r.send &quot;r0&quot;
p Ractor.receive #=&gt; &quot;r0r10r9r8r7r6r5r4r3r2r1&quot;
</code></pre>

<pre><code># ring example with an error

r = Ractor.current
rs = (1..10).map{|i|
  r = Ractor.new r, i do |r, i|
    loop do
      msg = Ractor.receive
      raise if /e/ =~ msg
      r.send msg + &quot;r#{i}&quot;
    end
  end
}

r.send &quot;r0&quot;
p Ractor.receive #=&gt; &quot;r0r10r9r8r7r6r5r4r3r2r1&quot;
r.send &quot;r0&quot;
p Ractor.select(*rs, Ractor.current) #=&gt; [:receive, &quot;r0r10r9r8r7r6r5r4r3r2r1&quot;]
r.send &quot;e0&quot;
p Ractor.select(*rs, Ractor.current)
#=&gt;
#&lt;Thread:0x000056262de28bd8 run&gt; terminated with exception (report_on_exception is true):
Traceback (most recent call last):
        2: from /home/ko1/src/ruby/trunk/test.rb:7:in `block (2 levels) in &lt;main&gt;&#39;
        1: from /home/ko1/src/ruby/trunk/test.rb:7:in `loop&#39;
/home/ko1/src/ruby/trunk/test.rb:9:in `block (3 levels) in &lt;main&gt;&#39;: unhandled exception
Traceback (most recent call last):
        2: from /home/ko1/src/ruby/trunk/test.rb:7:in `block (2 levels) in &lt;main&gt;&#39;
        1: from /home/ko1/src/ruby/trunk/test.rb:7:in `loop&#39;
/home/ko1/src/ruby/trunk/test.rb:9:in `block (3 levels) in &lt;main&gt;&#39;: unhandled exception
        1: from /home/ko1/src/ruby/trunk/test.rb:21:in `&lt;main&gt;&#39;
&lt;internal:ractor&gt;:69:in `select&#39;: thrown by remote Ractor. (Ractor::RemoteError)
</code></pre>

<pre><code># resend non-error message

r = Ractor.current
rs = (1..10).map{|i|
  r = Ractor.new r, i do |r, i|
    loop do
      msg = Ractor.receive
      raise if /e/ =~ msg
      r.send msg + &quot;r#{i}&quot;
    end
  end
}

r.send &quot;r0&quot;
p Ractor.receive #=&gt; &quot;r0r10r9r8r7r6r5r4r3r2r1&quot;
r.send &quot;r0&quot;
p Ractor.select(*rs, Ractor.current)
[:receive, &quot;r0r10r9r8r7r6r5r4r3r2r1&quot;]
msg = &#39;e0&#39;
begin
  r.send msg
  p Ractor.select(*rs, Ractor.current)
rescue Ractor::RemoteError
  msg = &#39;r0&#39;
  retry
end

#=&gt; &lt;internal:ractor&gt;:100:in `send&#39;: The incoming-port is already closed (Ractor::ClosedError)
# because r == r[-1] is terminated.
</code></pre>

<pre><code># ring example with supervisor and re-start

def make_ractor r, i
  Ractor.new r, i do |r, i|
    loop do
      msg = Ractor.receive
      raise if /e/ =~ msg
      r.send msg + &quot;r#{i}&quot;
    end
  end
end

r = Ractor.current
rs = (1..10).map{|i|
  r = make_ractor(r, i)
}

msg = &#39;e0&#39; # error causing message
begin
  r.send msg
  p Ractor.select(*rs, Ractor.current)
rescue Ractor::RemoteError
  r = rs[-1] = make_ractor(rs[-2], rs.size-1)
  msg = &#39;x0&#39;
  retry
end

#=&gt; [:receive, &quot;x0r9r9r8r7r6r5r4r3r2r1&quot;]
</code></pre>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </main>
  </body>
</html>
