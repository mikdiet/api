<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>layouts_and_rendering.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            layouts_and_rendering.md
        </h1>
        <ul class="files">
            <li>rails/guides/source/layouts_and_rendering.md</li>
            <li>Last modified: 2013-04-26 19:51:18 +0300</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Layouts+and+Rendering+in+Rails">Layouts and Rendering in <a href="../../../../classes/Rails.html">Rails</a></h1>

<p>This guide covers the basic layout features of Action Controller and Action
View. By referring to this guide, you will be able to:</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>How to use the various rendering methods built into <a
href="../../../../classes/Rails.html">Rails</a>.</p>
</li><li>
<p>How to create layouts with multiple content sections.</p>
</li><li>
<p>How to use partials to DRY up your views.</p>
</li><li>
<p>How to use nested layouts (sub-templates).</p>
</li></ul>
<hr style="height: 1px">

<h2 id="label-Overview%3A+How+the+Pieces+Fit+Together">Overview: How the Pieces Fit Together</h2>

<p>This guide focuses on the interaction between Controller and View in the
Model-View-Controller triangle. As you know, the Controller is responsible
for orchestrating the whole process of handling a request in <a
href="../../../../classes/Rails.html">Rails</a>, though it normally hands
off any heavy code to the Model. But then, when it&#39;s time to send a
response back to the user, the Controller hands things off to the View.
It&#39;s that handoff that is the subject of this guide.</p>

<p>In broad strokes, this involves deciding what should be sent as the
response and calling an appropriate method to create that response. If the
response is a full-blown view, <a
href="../../../../classes/Rails.html">Rails</a> also does some extra work
to wrap the view in a layout and possibly to pull in partial views.
You&#39;ll see all of those paths later in this guide.</p>

<h2 id="label-Creating+Responses">Creating Responses</h2>

<p>From the controller&#39;s point of view, there are three ways to create an
HTTP response:</p>
<ul><li>
<p>Call <code>render</code> to create a full response to send back to the
browser</p>
</li><li>
<p>Call <code>redirect_to</code> to send an HTTP redirect status code to the
browser</p>
</li><li>
<p>Call <code>head</code> to create a response consisting solely of HTTP
headers to send back to the browser</p>
</li></ul>

<h3 id="label-Rendering+by+Default%3A+Convention+Over+Configuration+in+Action">Rendering by Default: Convention Over Configuration in Action</h3>

<p>You&#39;ve heard that <a href="../../../../classes/Rails.html">Rails</a>
promotes “convention over configuration”. <a
href="../../../../classes/Default.html">Default</a> rendering is an
excellent example of this. By default, controllers in <a
href="../../../../classes/Rails.html">Rails</a> automatically render views
with names that correspond to valid routes. For example, if you have this
code in your <code>BooksController</code> class:</p>

<pre><code>class BooksController &lt; ApplicationController
end
</code></pre>

<p>And the following in your routes file:</p>

<pre><code>resources :books
</code></pre>

<p>And you have a view file <code>app/views/books/index.html.erb</code>:</p>

<pre><code>&lt;h1&gt;Books are coming soon!&lt;/h1&gt;</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> will automatically
render <code>app/views/books/index.html.erb</code> when you navigate to
<code>/books</code> and you will see “Books are coming soon!” on your
screen.</p>

<p>However a coming soon screen is only minimally useful, so you will soon
create your <code>Book</code> model and add the index action to
<code>BooksController</code>:</p>

<pre><code>class BooksController &lt; ApplicationController
  def index
    @books = Book.all
  end
end
</code></pre>

<p>Note that we don&#39;t have explicit render at the end of the index action
in accordance with “convention over configuration” principle. The rule is
that if you do not explicitly render something at the end of a controller
action, <a href="../../../../classes/Rails.html">Rails</a> will
automatically look for the <code>action_name.html.erb</code> template in
the controller&#39;s view path and render it. So in this case, <a
href="../../../../classes/Rails.html">Rails</a> will render the
<code>app/views/books/index.html.erb</code> file.</p>

<p>If we want to display the properties of all the books in our view, we can
do so with an <a href="../../../../classes/ERB.html">ERB</a> template like
this:</p>

<pre><code>&lt;h1&gt;Listing Books&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Summary&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @books.each do |book| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= book.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= book.content %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &quot;Show&quot;, book %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &quot;Edit&quot;, edit_book_path(book) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to &quot;Remove&quot;, book, method: :delete, data: { confirm: &quot;Are you sure?&quot; } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to &quot;New book&quot;, new_book_path %&gt;</code></pre>

<p>NOTE: The actual rendering is done by subclasses of
<code>ActionView::TemplateHandlers</code>. This guide does not dig into
that process, but it&#39;s important to know that the file extension on
your view controls the choice of template handler. Beginning with <a
href="../../../../classes/Rails.html">Rails</a> 2, the standard extensions
are <code>.erb</code> for <a href="../../../../classes/ERB.html">ERB</a>
(HTML with embedded Ruby), and <code>.builder</code> for Builder (XML
generator).</p>

<h3 id="label-Using+render">Using <code>render</code></h3>

<p>In most cases, the <code>ActionController::Base#render</code> method does
the heavy lifting of rendering your application&#39;s content for use by a
browser. There are a variety of ways to customize the behavior of
<code>render</code>. You can render the default view for a <a
href="../../../../classes/Rails.html">Rails</a> template, or a specific
template, or a file, or inline code, or nothing at all. You can render
text, JSON, or XML. You can specify the content type or HTTP status of the
rendered response as well.</p>

<p>TIP: If you want to see the exact results of a call to <code>render</code>
without needing to inspect it in a browser, you can call
<code>render_to_string</code>. This method takes exactly the same options
as <code>render</code>, but it returns a string instead of sending a
response back to the browser.</p>

<h4 id="label-Rendering+Nothing">Rendering Nothing</h4>

<p>Perhaps the simplest thing you can do with <code>render</code> is to render
nothing at all:</p>

<pre><code>render nothing: true
</code></pre>

<p>If you look at the response for this using cURL, you will see the
following:</p>

<pre><code>$ curl -i 127.0.0.1:3000/books
HTTP/1.1 200 OK
Connection: close
Date: Sun, 24 Jan 2010 09:25:18 GMT
Transfer-Encoding: chunked
Content-Type: */*; charset=utf-8
X-Runtime: 0.014297
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache


 $</code></pre>

<p>We see there is an empty response (no data after the
<code>Cache-Control</code> line), but the request was successful because <a
href="../../../../classes/Rails.html">Rails</a> has set the response to 200
OK. You can set the <code>:status</code> option on render to change this
response. Rendering nothing can be useful for Ajax requests where all you
want to send back to the browser is an acknowledgment that the request was
completed.</p>

<p>TIP: You should probably be using the <code>head</code> method, discussed
later in this guide, instead of <code>render :nothing</code>. This provides
additional flexibility and makes it explicit that you&#39;re only
generating HTTP headers.</p>

<h4 id="label-Rendering+an+Action%27s+View">Rendering an Action&#39;s View</h4>

<p>If you want to render the view that corresponds to a different template
within the same controller, you can use <code>render</code> with the name
of the view:</p>

<pre><code>def update
  @book = Book.find(params[:id])
  if @book.update(params[:book])
    redirect_to(@book)
  else
    render &quot;edit&quot;
  end
end
</code></pre>

<p>If the call to <code>update</code> fails, calling the <code>update</code>
action in this controller will render the <code>edit.html.erb</code>
template belonging to the same controller.</p>

<p>If you prefer, you can use a symbol instead of a string to specify the
action to render:</p>

<pre><code>def update
  @book = Book.find(params[:id])
  if @book.update(params[:book])
    redirect_to(@book)
  else
    render :edit
  end
end
</code></pre>

<h4 id="label-Rendering+an+Action%27s+Template+from+Another+Controller">Rendering an Action&#39;s Template from <a href="../../../../classes/Another.html">Another</a> Controller</h4>

<p>What if you want to render a template from an entirely different controller
from the one that contains the action code? You can also do that with
<code>render</code>, which accepts the full path (relative to
<code>app/views</code>) of the template to render. For example, if
you&#39;re running code in an <code>AdminProductsController</code> that
lives in <code>app/controllers/admin</code>, you can render the results of
an action to a template in <code>app/views/products</code> this way:</p>

<pre><code>render &quot;products/show&quot;
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> knows that this view
belongs to a different controller because of the embedded slash character
in the string. If you want to be explicit, you can use the
<code>:template</code> option (which was required on <a
href="../../../../classes/Rails.html">Rails</a> 2.2 and earlier):</p>

<pre><code>render template: &quot;products/show&quot;
</code></pre>

<h4 id="label-Rendering+an+Arbitrary+File">Rendering an Arbitrary <a href="../../../../classes/File.html">File</a></h4>

<p>The <code>render</code> method can also use a view that&#39;s entirely
outside of your application (perhaps you&#39;re sharing views between two
<a href="../../../../classes/Rails.html">Rails</a> applications):</p>

<pre><code>render &quot;/u/apps/warehouse_app/current/app/views/products/show&quot;
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> determines that this is
a file render because of the leading slash character. To be explicit, you
can use the <code>:file</code> option (which was required on <a
href="../../../../classes/Rails.html">Rails</a> 2.2 and earlier):</p>

<pre><code>render file: &quot;/u/apps/warehouse_app/current/app/views/products/show&quot;
</code></pre>

<p>The <code>:file</code> option takes an absolute file-system path. Of
course, you need to have rights to the view that you&#39;re using to render
the content.</p>

<p>NOTE: By default, the file is rendered without using the current layout. If
you want <a href="../../../../classes/Rails.html">Rails</a> to put the file
into the current layout, you need to add the <code>layout: true</code>
option.</p>

<p>TIP: If you&#39;re running <a
href="../../../../classes/Rails.html">Rails</a> on Microsoft Windows, you
should use the <code>:file</code> option to render a file, because Windows
filenames do not have the same format as Unix filenames.</p>

<h4 id="label-Wrapping+it+up">Wrapping it up</h4>

<p>The above three ways of rendering (rendering another template within the
controller, rendering a template within another controller and rendering an
arbitrary file on the file system) are actually variants of the same
action.</p>

<p>In fact, in the <a
href="../../../../classes/BooksController.html">BooksController</a> class,
inside of the update action where we want to render the edit template if
the book does not update successfully, all of the following render calls
would all render the <code>edit.html.erb</code> template in the
<code>views/books</code> directory:</p>

<pre><code>render :edit
render action: :edit
render &quot;edit&quot;
render &quot;edit.html.erb&quot;
render action: &quot;edit&quot;
render action: &quot;edit.html.erb&quot;
render &quot;books/edit&quot;
render &quot;books/edit.html.erb&quot;
render template: &quot;books/edit&quot;
render template: &quot;books/edit.html.erb&quot;
render &quot;/path/to/rails/app/views/books/edit&quot;
render &quot;/path/to/rails/app/views/books/edit.html.erb&quot;
render file: &quot;/path/to/rails/app/views/books/edit&quot;
render file: &quot;/path/to/rails/app/views/books/edit.html.erb&quot;
</code></pre>

<p>Which one you use is really a matter of style and convention, but the rule
of thumb is to use the simplest one that makes sense for the code you are
writing.</p>

<h4 id="label-Using+render+with+%3Ainline">Using <code>render</code> with <code>:inline</code></h4>

<p>The <code>render</code> method can do without a view completely, if
you&#39;re willing to use the <code>:inline</code> option to supply <a
href="../../../../classes/ERB.html">ERB</a> as part of the method call.
This is perfectly valid:</p>

<pre><code>render inline: &quot;&lt;% products.each do |p| %&gt;&lt;p&gt;&lt;%= p.name %&gt;&lt;/p&gt;&lt;% end %&gt;&quot;
</code></pre>

<p>WARNING: There is seldom any good reason to use this option. Mixing <a
href="../../../../classes/ERB.html">ERB</a> into your controllers defeats
the MVC orientation of <a href="../../../../classes/Rails.html">Rails</a>
and will make it harder for other developers to follow the logic of your
project. Use a separate erb view instead.</p>

<p>By default, inline rendering uses <a
href="../../../../classes/ERB.html">ERB</a>. You can force it to use
Builder instead with the <code>:type</code> option:</p>

<pre><code>render inline: &quot;xml.p {&#39;Horrid coding practice!&#39;}&quot;, type: :builder
</code></pre>

<h4 id="label-Rendering+Text">Rendering Text</h4>

<p>You can send plain text - with no markup at all - back to the browser by
using the <code>:text</code> option to <code>render</code>:</p>

<pre><code>render text: &quot;OK&quot;
</code></pre>

<p>TIP: Rendering pure text is most useful when you&#39;re responding to Ajax
or web service requests that are expecting something other than proper <a
href="../../../../classes/HTML.html">HTML</a>.</p>

<p>NOTE: By default, if you use the <code>:text</code> option, the text is
rendered without using the current layout. If you want <a
href="../../../../classes/Rails.html">Rails</a> to put the text into the
current layout, you need to add the <code>layout: true</code> option.</p>

<h4 id="label-Rendering+JSON">Rendering JSON</h4>

<p>JSON is a JavaScript data format used by many Ajax libraries. <a
href="../../../../classes/Rails.html">Rails</a> has built-in support for
converting objects to JSON and rendering that JSON back to the browser:</p>

<pre><code>render json: @product
</code></pre>

<p>TIP: You don&#39;t need to call <code>to_json</code> on the object that you
want to render. If you use the <code>:json</code> option,
<code>render</code> will automatically call <code>to_json</code> for you.</p>

<h4 id="label-Rendering+XML">Rendering XML</h4>

<p><a href="../../../../classes/Rails.html">Rails</a> also has built-in
support for converting objects to XML and rendering that XML back to the
caller:</p>

<pre><code>render xml: @product
</code></pre>

<p>TIP: You don&#39;t need to call <code>to_xml</code> on the object that you
want to render. If you use the <code>:xml</code> option,
<code>render</code> will automatically call <code>to_xml</code> for you.</p>

<h4 id="label-Rendering+Vanilla+JavaScript">Rendering Vanilla JavaScript</h4>

<p><a href="../../../../classes/Rails.html">Rails</a> can render vanilla
JavaScript:</p>

<pre><code>render js: &quot;alert(&#39;Hello Rails&#39;);&quot;
</code></pre>

<p>This will send the supplied string to the browser with a MIME type of
<code>text/javascript</code>.</p>

<h4 id="label-Options+for+render">Options for <code>render</code></h4>

<p>Calls to the <code>render</code> method generally accept four options:</p>
<ul><li>
<p><code>:content_type</code></p>
</li><li>
<p><code>:layout</code></p>
</li><li>
<p><code>:status</code></p>
</li><li>
<p><code>:location</code></p>
</li></ul>

<h5 id="label-The+%3Acontent_type+Option">The <code>:content_type</code> Option</h5>

<p>By default, <a href="../../../../classes/Rails.html">Rails</a> will serve
the results of a rendering operation with the MIME content-type of
<code>text/html</code> (or <code>application/json</code> if you use the
<code>:json</code> option, or <code>application/xml</code> for the
<code>:xml</code> option.). There are times when you might like to change
this, and you can do so by setting the <code>:content_type</code> option:</p>

<pre><code>render file: filename, content_type: &quot;application/rss&quot;
</code></pre>

<h5 id="label-The+%3Alayout+Option">The <code>:layout</code> Option</h5>

<p>With most of the options to <code>render</code>, the rendered content is
displayed as part of the current layout. You&#39;ll learn more about
layouts and how to use them later in this guide.</p>

<p>You can use the <code>:layout</code> option to tell <a
href="../../../../classes/Rails.html">Rails</a> to use a specific file as
the layout for the current action:</p>

<pre><code>render layout: &quot;special_layout&quot;
</code></pre>

<p>You can also tell <a href="../../../../classes/Rails.html">Rails</a> to
render with no layout at all:</p>

<pre><code>render layout: false
</code></pre>

<h5 id="label-The+%3Astatus+Option">The <code>:status</code> Option</h5>

<p><a href="../../../../classes/Rails.html">Rails</a> will automatically
generate a response with the correct HTTP status code (in most cases, this
is <code>200 OK</code>). You can use the <code>:status</code> option to
change this:</p>

<pre><code>render status: 500
render status: :forbidden
</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> understands both numeric
and symbolic status codes.</p>

<h5 id="label-The+%3Alocation+Option">The <code>:location</code> Option</h5>

<p>You can use the <code>:location</code> option to set the HTTP
<code>Location</code> header:</p>

<pre><code>render xml: photo, location: photo_url(photo)
</code></pre>

<h4 id="label-Finding+Layouts">Finding Layouts</h4>

<p>To find the current layout, <a
href="../../../../classes/Rails.html">Rails</a> first looks for a file in
<code>app/views/layouts</code> with the same base name as the controller.
For example, rendering actions from the <code>PhotosController</code> class
will use <code>app/views/layouts/photos.html.erb</code> (or
<code>app/views/layouts/photos.builder</code>). If there is no such
controller-specific layout, <a
href="../../../../classes/Rails.html">Rails</a> will use
<code>app/views/layouts/application.html.erb</code> or
<code>app/views/layouts/application.builder</code>. If there is no
<code>.erb</code> layout, <a
href="../../../../classes/Rails.html">Rails</a> will use a
<code>.builder</code> layout if one exists. <a
href="../../../../classes/Rails.html">Rails</a> also provides several ways
to more precisely assign specific layouts to individual controllers and
actions.</p>

<h5 id="label-Specifying+Layouts+for+Controllers">Specifying Layouts for Controllers</h5>

<p>You can override the default layout conventions in your controllers by
using the <code>layout</code> declaration. For example:</p>

<pre><code>class ProductsController &lt; ApplicationController
  layout &quot;inventory&quot;
  #...
end
</code></pre>

<p>With this declaration, all of the views rendered by the products controller
will use <code>app/views/layouts/inventory.html.erb</code> as their layout.</p>

<p>To assign a specific layout for the entire application, use a
<code>layout</code> declaration in your <code>ApplicationController</code>
class:</p>

<pre><code>class ApplicationController &lt; ActionController::Base
  layout &quot;main&quot;
  #...
end
</code></pre>

<p>With this declaration, all of the views in the entire application will use
<code>app/views/layouts/main.html.erb</code> for their layout.</p>

<h5 id="label-Choosing+Layouts+at+Runtime">Choosing Layouts at Runtime</h5>

<p>You can use a symbol to defer the choice of layout until a request is
processed:</p>

<pre><code>class ProductsController &lt; ApplicationController
  layout &quot;products_layout&quot;

  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? &quot;special&quot; : &quot;products&quot;
    end

end
</code></pre>

<p>Now, if the current user is a special user, they&#39;ll get a special
layout when viewing a product.</p>

<p>You can even use an inline method, such as a Proc, to determine the layout.
For example, if you pass a Proc object, the block you give the Proc will be
given the <code>controller</code> instance, so the layout can be determined
based on the current request:</p>

<pre><code>class ProductsController &lt; ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? &quot;popup&quot; : &quot;application&quot; }
end
</code></pre>

<h5 id="label-Conditional+Layouts">Conditional Layouts</h5>

<p>Layouts specified at the controller level support the <code>:only</code>
and <code>:except</code> options. These options take either a method name,
or an array of method names, corresponding to method names within the
controller:</p>

<pre><code>class ProductsController &lt; ApplicationController
  layout &quot;product&quot;, except: [:index, :rss]
end
</code></pre>

<p>With this declaration, the <code>product</code> layout would be used for
everything but the <code>rss</code> and <code>index</code> methods.</p>

<h5 id="label-Layout+Inheritance">Layout Inheritance</h5>

<p>Layout declarations cascade downward in the hierarchy, and more specific
layout declarations always override more general ones. For example:</p>
<ul><li>
<p><code>application_controller.rb</code></p>

<pre><code>class ApplicationController &lt; ActionController::Base
  layout &quot;main&quot;
end
</code></pre>
</li><li>
<p><code>posts_controller.rb</code></p>

<pre><code>class PostsController &lt; ApplicationController
end
</code></pre>
</li><li>
<p><code>special_posts_controller.rb</code></p>

<pre><code>class SpecialPostsController &lt; PostsController
  layout &quot;special&quot;
end
</code></pre>
</li><li>
<p><code>old_posts_controller.rb</code></p>

<pre><code>class OldPostsController &lt; SpecialPostsController
  layout false

  def show
    @post = Post.find(params[:id])
  end

  def index
    @old_posts = Post.older
    render layout: &quot;old&quot;
  end
  # ...
end
</code></pre>
</li></ul>

<p>In this application:</p>
<ul><li>
<p>In general, views will be rendered in the <code>main</code> layout</p>
</li><li>
<p><code>PostsController#index</code> will use the <code>main</code> layout</p>
</li><li>
<p><code>SpecialPostsController#index</code> will use the <code>special</code>
layout</p>
</li><li>
<p><code>OldPostsController#show</code> will use no layout at all</p>
</li><li>
<p><code>OldPostsController#index</code> will use the <code>old</code> layout</p>
</li></ul>

<h4 id="label-Avoiding+Double+Render+Errors">Avoiding Double <a href="../../../../classes/Render.html">Render</a> Errors</h4>

<p>Sooner or later, most <a href="../../../../classes/Rails.html">Rails</a>
developers will see the error message “Can only render or redirect once per
action”. While this is annoying, it&#39;s relatively easy to fix. Usually
it happens because of a fundamental misunderstanding of the way that
<code>render</code> works.</p>

<p>For example, here&#39;s some code that will trigger this error:</p>

<pre><code>def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: &quot;special_show&quot;
  end
  render action: &quot;regular_show&quot;
end
</code></pre>

<p>If <code>@book.special?</code> evaluates to <code>true</code>, <a
href="../../../../classes/Rails.html">Rails</a> will start the rendering
process to dump the <code>@book</code> variable into the
<code>special_show</code> view. But this will <em>not</em> stop the rest of
the code in the <code>show</code> action from running, and when <a
href="../../../../classes/Rails.html">Rails</a> hits the end of the action,
it will start to render the <code>regular_show</code> view - and throw an
error. The solution is simple: make sure that you have only one call to
<code>render</code> or <code>redirect</code> in a single code path. <a
href="../../../../classes/One.html">One</a> thing that can help is
<code>and return</code>. Here&#39;s a patched version of the method:</p>

<pre><code>def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: &quot;special_show&quot; and return
  end
  render action: &quot;regular_show&quot;
end
</code></pre>

<p>Make sure to use <code>and return</code> instead of <code>&amp;&amp;
return</code> because <code>&amp;&amp; return</code> will not work due to
the operator precedence in the Ruby Language.</p>

<p>Note that the implicit render done by <a
href="../../../../classes/ActionController.html">ActionController</a>
detects if <code>render</code> has been called, so the following will work
without errors:</p>

<pre><code>def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: &quot;special_show&quot;
  end
end
</code></pre>

<p>This will render a book with <code>special?</code> set with the
<code>special_show</code> template, while other books will render with the
default <code>show</code> template.</p>

<h3 id="label-Using+redirect_to">Using <code>redirect_to</code></h3>

<p><a href="../../../../classes/Another.html">Another</a> way to handle
returning responses to an HTTP request is with <code>redirect_to</code>. As
you&#39;ve seen, <code>render</code> tells <a
href="../../../../classes/Rails.html">Rails</a> which view (or other asset)
to use in constructing a response. The <code>redirect_to</code> method does
something completely different: it tells the browser to send a new request
for a different URL. For example, you could redirect from wherever you are
in your code to the index of photos in your application with this call:</p>

<pre><code>redirect_to photos_url
</code></pre>

<p>You can use <code>redirect_to</code> with any arguments that you could use
with <code>link_to</code> or <code>url_for</code>. There&#39;s also a
special redirect that sends the user back to the page they just came from:</p>

<pre><code>redirect_to :back
</code></pre>

<h4 id="label-Getting+a+Different+Redirect+Status+Code">Getting a Different Redirect Status Code</h4>

<p><a href="../../../../classes/Rails.html">Rails</a> uses HTTP status code
302, a temporary redirect, when you call <code>redirect_to</code>. If
you&#39;d like to use a different status code, perhaps 301, a permanent
redirect, you can use the <code>:status</code> option:</p>

<pre><code>redirect_to photos_path, status: 301
</code></pre>

<p>Just like the <code>:status</code> option for <code>render</code>,
<code>:status</code> for <code>redirect_to</code> accepts both numeric and
symbolic header designations.</p>

<h4 id="label-The+Difference+Between+render+and+redirect_to">The Difference Between <code>render</code> and <code>redirect_to</code></h4>

<p>Sometimes inexperienced developers think of <code>redirect_to</code> as a
sort of <code>goto</code> command, moving execution from one place to
another in your <a href="../../../../classes/Rails.html">Rails</a> code.
This is <em>not</em> correct. Your code stops running and waits for a new
request for the browser. It just happens that you&#39;ve told the browser
what request it should make next, by sending back an HTTP 302 status code.</p>

<p>Consider these actions to see the difference:</p>

<pre><code>def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    render action: &quot;index&quot;
  end
end
</code></pre>

<p>With the code in this form, there will likely be a problem if the
<code>@book</code> variable is <code>nil</code>. Remember, a <code>render
:action</code> doesn&#39;t run any code in the target action, so nothing
will set up the <code>@books</code> variable that the <code>index</code>
view will probably require. <a href="../../../../classes/One.html">One</a>
way to fix this is to redirect instead of rendering:</p>

<pre><code>def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    redirect_to action: :index
  end
end
</code></pre>

<p>With this code, the browser will make a fresh request for the index page,
the code in the <code>index</code> method will run, and all will be well.</p>

<p>The only downside to this code is that it requires a round trip to the
browser: the browser requested the show action with <code>/books/1</code>
and the controller finds that there are no books, so the controller sends
out a 302 redirect response to the browser telling it to go to
<code>/books/</code>, the browser complies and sends a new request back to
the controller asking now for the <code>index</code> action, the controller
then gets all the books in the database and renders the index template,
sending it back down to the browser which then shows it on your screen.</p>

<p>While in a small application, this added latency might not be a problem, it
is something to think about if response time is a concern. We can
demonstrate one way to handle this with a contrived example:</p>

<pre><code>def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    @books = Book.all
    render &quot;index&quot;, alert: &quot;Your book was not found!&quot;
  end
end
</code></pre>

<p>This would detect that there are no books with the specified ID, populate
the <code>@books</code> instance variable with all the books in the model,
and then directly render the <code>index.html.erb</code> template,
returning it to the browser with a flash alert message to tell the user
what happened.</p>

<h3 id="label-Using+head+To+Build+Header-Only+Responses">Using <code>head</code> To <a href="../../../../classes/Build.html">Build</a> Header-Only Responses</h3>

<p>The <code>head</code> method can be used to send responses with only
headers to the browser. It provides a more obvious alternative to calling
<code>render :nothing</code>. The <code>head</code> method takes one
parameter, which is interpreted as a hash of header names and values. For
example, you can return only an error header:</p>

<pre><code>head :bad_request
</code></pre>

<p>This would produce the following header:</p>

<pre><code>HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache</code></pre>

<p>Or you can use other HTTP headers to convey other information:</p>

<pre><code>head :created, location: photo_path(@photo)
</code></pre>

<p>Which would produce:</p>

<pre><code>HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache</code></pre>

<h2 id="label-Structuring+Layouts">Structuring Layouts</h2>

<p>When <a href="../../../../classes/Rails.html">Rails</a> renders a view as a
response, it does so by combining the view with the current layout, using
the rules for finding the current layout that were covered earlier in this
guide. Within a layout, you have access to three tools for combining
different bits of output to form the overall response:</p>
<ul><li>
<p>Asset tags</p>
</li><li>
<p><code>yield</code> and <code>content_for</code></p>
</li><li>
<p>Partials</p>
</li></ul>

<h3 id="label-Asset+Tag+Helpers">Asset <a href="../../../../classes/Tag.html">Tag</a> Helpers</h3>

<p>Asset tag helpers provide methods for generating <a
href="../../../../classes/HTML.html">HTML</a> that link views to feeds,
JavaScript, stylesheets, images, videos and audios. There are six asset tag
helpers available in Rails:</p>
<ul><li>
<p><code>auto_discovery_link_tag</code></p>
</li><li>
<p><code>javascript_include_tag</code></p>
</li><li>
<p><code>stylesheet_link_tag</code></p>
</li><li>
<p><code>image_tag</code></p>
</li><li>
<p><code>video_tag</code></p>
</li><li>
<p><code>audio_tag</code></p>
</li></ul>

<p>You can use these tags in layouts or other views, although the
<code>auto_discovery_link_tag</code>, <code>javascript_include_tag</code>,
and <code>stylesheet_link_tag</code>, are most commonly used in the
<code>&lt;head&gt;</code> section of a layout.</p>

<p>WARNING: The asset tag helpers do <em>not</em> verify the existence of the
assets at the specified locations; they simply assume that you know what
you&#39;re doing and generate the link.</p>

<h4 id="label-Linking+to+Feeds+with+the+auto_discovery_link_tag">Linking to Feeds with the <code>auto_discovery_link_tag</code></h4>

<p>The <code>auto_discovery_link_tag</code> helper builds <a
href="../../../../classes/HTML.html">HTML</a> that most browsers and
newsreaders can use to detect the presence of RSS or Atom feeds. It takes
the type of the link (<code>:rss</code> or <code>:atom</code>), a hash of
options that are passed through to url_for, and a hash of options for the
tag:</p>

<pre><code>&lt;%= auto_discovery_link_tag(:rss, {action: &quot;feed&quot;},
  {title: &quot;RSS Feed&quot;}) %&gt;</code></pre>

<p>There are three tag options available for the
<code>auto_discovery_link_tag</code>:</p>
<ul><li>
<p><code>:rel</code> specifies the <code>rel</code> value in the link. The
default value is “alternate”.</p>
</li><li>
<p><code>:type</code> specifies an explicit MIME type. <a
href="../../../../classes/Rails.html">Rails</a> will generate an
appropriate MIME type automatically.</p>
</li><li>
<p><code>:title</code> specifies the title of the link. The default value is
the uppercased <code>:type</code> value, for example, “ATOM” or “RSS”.</p>
</li></ul>

<h4 id="label-Linking+to+JavaScript+Files+with+the+javascript_include_tag">Linking to JavaScript Files with the <code>javascript_include_tag</code></h4>

<p>The <code>javascript_include_tag</code> helper returns an <a
href="../../../../classes/HTML.html">HTML</a> <code>script</code> tag for
each source provided.</p>

<p>If you are using <a href="../../../../classes/Rails.html">Rails</a> with
the <a href="http://asset_pipeline.html">Asset Pipeline</a> enabled, this
helper will generate a link to <code>/assets/javascripts/</code> rather
than <code>public/javascripts</code> which was used in earlier versions of
<a href="../../../../classes/Rails.html">Rails</a>. This link is then
served by the asset pipeline.</p>

<p><a href="../../../../classes/A.html">A</a> JavaScript file within a <a
href="../../../../classes/Rails.html">Rails</a> application or <a
href="../../../../classes/Rails.html">Rails</a> engine goes in one of three
locations: <code>app/assets</code>, <code>lib/assets</code> or
<code>vendor/assets</code>. These locations are explained in detail in the
<a href="http://asset_pipeline.html#asset-organization">Asset Organization
section in the Asset Pipeline Guide</a></p>

<p>You can specify a full path relative to the document root, or a URL, if you
prefer. For example, to link to a JavaScript file that is inside a
directory called <code>javascripts</code> inside of one of
<code>app/assets</code>, <code>lib/assets</code> or
<code>vendor/assets</code>, you would do this:</p>

<pre><code>&lt;%= javascript_include_tag &quot;main&quot; %&gt;</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> will then output a
<code>script</code> tag such as this:</p>

<pre><code>&lt;script src=&#39;/assets/main.js&#39;&gt;&lt;/script&gt;</code></pre>

<p>The request to this asset is then served by the Sprockets gem.</p>

<p>To include multiple files such as
<code>app/assets/javascripts/main.js</code> and
<code>app/assets/javascripts/columns.js</code> at the same time:</p>

<pre><code>&lt;%= javascript_include_tag &quot;main&quot;, &quot;columns&quot; %&gt;</code></pre>

<p>To include <code>app/assets/javascripts/main.js</code> and
<code>app/assets/javascripts/photos/columns.js</code>:</p>

<pre><code>&lt;%= javascript_include_tag &quot;main&quot;, &quot;/photos/columns&quot; %&gt;</code></pre>

<p>To include <code>http://example.com/main.js</code>:</p>

<pre><code>&lt;%= javascript_include_tag &quot;http://example.com/main.js&quot; %&gt;</code></pre>

<h4 id="label-Linking+to+CSS+Files+with+the+stylesheet_link_tag">Linking to CSS Files with the <code>stylesheet_link_tag</code></h4>

<p>The <code>stylesheet_link_tag</code> helper returns an <a
href="../../../../classes/HTML.html">HTML</a> <code>&lt;link&gt;</code> tag
for each source provided.</p>

<p>If you are using <a href="../../../../classes/Rails.html">Rails</a> with
the “Asset Pipeline” enabled, this helper will generate a link to
<code>/assets/stylesheets/</code>. This link is then processed by the
Sprockets gem. <a href="../../../../classes/A.html">A</a> stylesheet file
can be stored in one of three locations: <code>app/assets</code>,
<code>lib/assets</code> or <code>vendor/assets</code>.</p>

<p>You can specify a full path relative to the document root, or a URL. For
example, to link to a stylesheet file that is inside a directory called
<code>stylesheets</code> inside of one of <code>app/assets</code>,
<code>lib/assets</code> or <code>vendor/assets</code>, you would do this:</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;main&quot; %&gt;</code></pre>

<p>To include <code>app/assets/stylesheets/main.css</code> and
<code>app/assets/stylesheets/columns.css</code>:</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;main&quot;, &quot;columns&quot; %&gt;</code></pre>

<p>To include <code>app/assets/stylesheets/main.css</code> and
<code>app/assets/stylesheets/photos/columns.css</code>:</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;main&quot;, &quot;photos/columns&quot; %&gt;</code></pre>

<p>To include <code>http://example.com/main.css</code>:</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;http://example.com/main.css&quot; %&gt;</code></pre>

<p>By default, the <code>stylesheet_link_tag</code> creates links with
<code>media=&quot;screen&quot; rel=&quot;stylesheet&quot;</code>. You can
override any of these defaults by specifying an appropriate option
(<code>:media</code>, <code>:rel</code>):</p>

<pre><code>&lt;%= stylesheet_link_tag &quot;main_print&quot;, media: &quot;print&quot; %&gt;</code></pre>

<h4 id="label-Linking+to+Images+with+the+image_tag">Linking to Images with the <code>image_tag</code></h4>

<p>The <code>image_tag</code> helper builds an <a
href="../../../../classes/HTML.html">HTML</a> <code>&lt;img /&gt;</code>
tag to the specified file. By default, files are loaded from
<code>public/images</code>.</p>

<p>WARNING: Note that you must specify the extension of the image.</p>

<pre><code>&lt;%= image_tag &quot;header.png&quot; %&gt;</code></pre>

<p>You can supply a path to the image if you like:</p>

<pre><code>&lt;%= image_tag &quot;icons/delete.gif&quot; %&gt;</code></pre>

<p>You can supply a hash of additional <a
href="../../../../classes/HTML.html">HTML</a> options:</p>

<pre><code>&lt;%= image_tag &quot;icons/delete.gif&quot;, {height: 45} %&gt;</code></pre>

<p>You can supply alternate text for the image which will be used if the user
has images turned off in their browser. If you do not specify an alt text
explicitly, it defaults to the file name of the file, capitalized and with
no extension. For example, these two image tags would return the same code:</p>

<pre><code>&lt;%= image_tag &quot;home.gif&quot; %&gt;
&lt;%= image_tag &quot;home.gif&quot;, alt: &quot;Home&quot; %&gt;</code></pre>

<p>You can also specify a special size tag, in the format “{width}x{height}”:</p>

<pre><code>&lt;%= image_tag &quot;home.gif&quot;, size: &quot;50x20&quot; %&gt;</code></pre>

<p>In addition to the above special tags, you can supply a final hash of
standard <a href="../../../../classes/HTML.html">HTML</a> options, such as
<code>:class</code>, <code>:id</code> or <code>:name</code>:</p>

<pre><code>&lt;%= image_tag &quot;home.gif&quot;, alt: &quot;Go Home&quot;,
                          id: &quot;HomeImage&quot;,
                          class: &quot;nav_bar&quot; %&gt;</code></pre>

<h4 id="label-Linking+to+Videos+with+the+video_tag">Linking to Videos with the <code>video_tag</code></h4>

<p>The <code>video_tag</code> helper builds an <a
href="../../../../classes/HTML.html">HTML</a> 5 <code>&lt;video&gt;</code>
tag to the specified file. By default, files are loaded from
<code>public/videos</code>.</p>

<pre><code>&lt;%= video_tag &quot;movie.ogg&quot; %&gt;</code></pre>

<p>Produces</p>

<pre><code>&lt;video src=&quot;/videos/movie.ogg&quot; /&gt;</code></pre>

<p>Like an <code>image_tag</code> you can supply a path, either absolute, or
relative to the <code>public/videos</code> directory. Additionally you can
specify the <code>size: &quot;#{width}x#{height}&quot;</code> option just
like an <code>image_tag</code>. Video tags can also have any of the <a
href="../../../../classes/HTML.html">HTML</a> options specified at the end
(<code>id</code>, <code>class</code> et al).</p>

<p>The video tag also supports all of the <code>&lt;video&gt;</code> <a
href="../../../../classes/HTML.html">HTML</a> options through the <a
href="../../../../classes/HTML.html">HTML</a> options hash, including:</p>
<ul><li>
<p><code>poster: &quot;image_name.png&quot;</code>, provides an image to put
in place of the video before it starts playing.</p>
</li><li>
<p><code>autoplay: true</code>, starts playing the video on page load.</p>
</li><li>
<p><code>loop: true</code>, loops the video once it gets to the end.</p>
</li><li>
<p><code>controls: true</code>, provides browser supplied controls for the
user to interact with the video.</p>
</li><li>
<p><code>autobuffer: true</code>, the video will pre load the file for the
user on page load.</p>
</li></ul>

<p>You can also specify multiple videos to play by passing an array of videos
to the <code>video_tag</code>:</p>

<pre><code>&lt;%= video_tag [&quot;trailer.ogg&quot;, &quot;movie.ogg&quot;] %&gt;</code></pre>

<p>This will produce:</p>

<pre><code>&lt;video&gt;&lt;source src=&quot;trailer.ogg&quot; /&gt;&lt;source src=&quot;movie.ogg&quot; /&gt;&lt;/video&gt;</code></pre>

<h4 id="label-Linking+to+Audio+Files+with+the+audio_tag">Linking to Audio Files with the <code>audio_tag</code></h4>

<p>The <code>audio_tag</code> helper builds an <a
href="../../../../classes/HTML.html">HTML</a> 5 <code>&lt;audio&gt;</code>
tag to the specified file. By default, files are loaded from
<code>public/audios</code>.</p>

<pre><code>&lt;%= audio_tag &quot;music.mp3&quot; %&gt;</code></pre>

<p>You can supply a path to the audio file if you like:</p>

<pre><code>&lt;%= audio_tag &quot;music/first_song.mp3&quot; %&gt;</code></pre>

<p>You can also supply a hash of additional options, such as <code>:id</code>,
<code>:class</code> etc.</p>

<p>Like the <code>video_tag</code>, the <code>audio_tag</code> has special
options:</p>
<ul><li>
<p><code>autoplay: true</code>, starts playing the audio on page load</p>
</li><li>
<p><code>controls: true</code>, provides browser supplied controls for the
user to interact with the audio.</p>
</li><li>
<p><code>autobuffer: true</code>, the audio will pre load the file for the
user on page load.</p>
</li></ul>

<h3 id="label-Understanding+yield">Understanding <code>yield</code></h3>

<p>Within the context of a layout, <code>yield</code> identifies a section
where content from the view should be inserted. The simplest way to use
this is to have a single <code>yield</code>, into which the entire contents
of the view currently being rendered is inserted:</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;%= yield %&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>You can also create a layout with multiple yielding regions:</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;%= yield :head %&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;%= yield %&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The main body of the view will always render into the unnamed
<code>yield</code>. To render content into a named <code>yield</code>, you
use the <code>content_for</code> method.</p>

<h3 id="label-Using+the+content_for+Method">Using the <code>content_for</code> Method</h3>

<p>The <code>content_for</code> method allows you to insert content into a
named <code>yield</code> block in your layout. For example, this view would
work with the layout that you just saw:</p>

<pre><code>&lt;% content_for :head do %&gt;
  &lt;title&gt;A simple page&lt;/title&gt;
&lt;% end %&gt;

&lt;p&gt;Hello, Rails!&lt;/p&gt;</code></pre>

<p>The result of rendering this page into the supplied layout would be this
HTML:</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;A simple page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;p&gt;Hello, Rails!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The <code>content_for</code> method is very helpful when your layout
contains distinct regions such as sidebars and footers that should get
their own blocks of content inserted. It&#39;s also useful for inserting
tags that load page-specific JavaScript or css files into the header of an
otherwise generic layout.</p>

<h3 id="label-Using+Partials">Using Partials</h3>

<p>Partial templates - usually just called “partials” - are another device for
breaking the rendering process into more manageable chunks. With a partial,
you can move the code for rendering a particular piece of a response to its
own file.</p>

<h4 id="label-Naming+Partials">Naming Partials</h4>

<p>To render a partial as part of a view, you use the <code>render</code>
method within the view:</p>

<pre><code>&lt;%= render &quot;menu&quot; %&gt;
</code></pre>

<p>This will render a file named <code>_menu.html.erb</code> at that point
within the view being rendered. Note the leading underscore character:
partials are named with a leading underscore to distinguish them from
regular views, even though they are referred to without the underscore.
This holds true even when you&#39;re pulling in a partial from another
folder:</p>

<pre><code>&lt;%= render &quot;shared/menu&quot; %&gt;
</code></pre>

<p>That code will pull in the partial from
<code>app/views/shared/_menu.html.erb</code>.</p>

<h4 id="label-Using+Partials+to+Simplify+Views">Using Partials to Simplify Views</h4>

<p><a href="../../../../classes/One.html">One</a> way to use partials is to
treat them as the equivalent of subroutines: as a way to move details out
of a view so that you can grasp what&#39;s going on more easily. For
example, you might have a view that looked like this:</p>

<pre><code>&lt;%= render &quot;shared/ad_banner&quot; %&gt;

&lt;h1&gt;Products&lt;/h1&gt;

&lt;p&gt;Here are a few of our fine products:&lt;/p&gt;
...

&lt;%= render &quot;shared/footer&quot; %&gt;</code></pre>

<p>Here, the <code>_ad_banner.html.erb</code> and
<code>_footer.html.erb</code> partials could contain content that is shared
among many pages in your application. You don&#39;t need to see the details
of these sections when you&#39;re concentrating on a particular page.</p>

<p>TIP: For content that is shared among all pages in your application, you
can use partials directly from layouts.</p>

<h4 id="label-Partial+Layouts">Partial Layouts</h4>

<p><a href="../../../../classes/A.html">A</a> partial can use its own layout
file, just as a view can use a layout. For example, you might call a
partial like this:</p>

<pre><code>&lt;%= render partial: &quot;link_area&quot;, layout: &quot;graybar&quot; %&gt;</code></pre>

<p>This would look for a partial named <code>_link_area.html.erb</code> and
render it using the layout <code>_graybar.html.erb</code>. Note that
layouts for partials follow the same leading-underscore naming as regular
partials, and are placed in the same folder with the partial that they
belong to (not in the master <code>layouts</code> folder).</p>

<p>Also note that explicitly specifying <code>:partial</code> is required when
passing additional options such as <code>:layout</code>.</p>

<h4 id="label-Passing+Local+Variables">Passing Local Variables</h4>

<p>You can also pass local variables into partials, making them even more
powerful and flexible. For example, you can use this technique to reduce
duplication between new and edit pages, while still keeping a bit of
distinct content:</p>
<ul><li>
<p><code>new.html.erb</code></p>

<pre><code>&lt;h1&gt;New zone&lt;/h1&gt;
&lt;%= error_messages_for :zone %&gt;
&lt;%= render partial: &quot;form&quot;, locals: {zone: @zone} %&gt;</code></pre>
</li><li>
<p><code>edit.html.erb</code></p>

<pre><code>&lt;h1&gt;Editing zone&lt;/h1&gt;
&lt;%= error_messages_for :zone %&gt;
&lt;%= render partial: &quot;form&quot;, locals: {zone: @zone} %&gt;</code></pre>
</li><li>
<p><code>_form.html.erb</code></p>

<pre><code>&lt;%= form_for(zone) do |f| %&gt;
  &lt;p&gt;
    &lt;b&gt;Zone name&lt;/b&gt;&lt;br /&gt;
    &lt;%= f.text_field :name %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;</code></pre>
</li></ul>

<p>Although the same partial will be rendered into both views, Action
View&#39;s submit helper will return “Create Zone” for the new action and
“Update Zone” for the edit action.</p>

<p>Every partial also has a local variable with the same name as the partial
(minus the underscore). You can pass an object in to this local variable
via the <code>:object</code> option:</p>

<pre><code>&lt;%= render partial: &quot;customer&quot;, object: @new_customer %&gt;</code></pre>

<p>Within the <code>customer</code> partial, the <code>customer</code>
variable will refer to <code>@new_customer</code> from the parent view.</p>

<p>If you have an instance of a model to render into a partial, you can use a
shorthand syntax:</p>

<pre><code>&lt;%= render @customer %&gt;</code></pre>

<p>Assuming that the <code>@customer</code> instance variable contains an
instance of the <code>Customer</code> model, this will use
<code>_customer.html.erb</code> to render it and will pass the local
variable <code>customer</code> into the partial which will refer to the
<code>@customer</code> instance variable in the parent view.</p>

<h4 id="label-Rendering+Collections">Rendering Collections</h4>

<p>Partials are very useful in rendering collections. When you pass a
collection to a partial via the <code>:collection</code> option, the
partial will be inserted once for each member in the collection:</p>
<ul><li>
<p><code>index.html.erb</code></p>

<pre><code>&lt;h1&gt;Products&lt;/h1&gt;
&lt;%= render partial: &quot;product&quot;, collection: @products %&gt;</code></pre>
</li><li>
<p><code>_product.html.erb</code></p>

<pre><code>&lt;p&gt;Product Name: &lt;%= product.name %&gt;&lt;/p&gt;</code></pre>
</li></ul>

<p>When a partial is called with a pluralized collection, then the individual
instances of the partial have access to the member of the collection being
rendered via a variable named after the partial. In this case, the partial
is <code>_product</code>, and within the <code>_product</code> partial, you
can refer to <code>product</code> to get the instance that is being
rendered.</p>

<p>There is also a shorthand for this. Assuming <code>@products</code> is a
collection of <code>product</code> instances, you can simply write this in
the <code>index.html.erb</code> to produce the same result:</p>

<pre><code>&lt;h1&gt;Products&lt;/h1&gt;
&lt;%= render @products %&gt;</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> determines the name of
the partial to use by looking at the model name in the collection. In fact,
you can even create a heterogeneous collection and render it this way, and
<a href="../../../../classes/Rails.html">Rails</a> will choose the proper
partial for each member of the collection:</p>
<ul><li>
<p><code>index.html.erb</code></p>

<pre><code>&lt;h1&gt;Contacts&lt;/h1&gt;
&lt;%= render [customer1, employee1, customer2, employee2] %&gt;</code></pre>
</li><li>
<p><code>customers/_customer.html.erb</code></p>

<pre><code>&lt;p&gt;Customer: &lt;%= customer.name %&gt;&lt;/p&gt;</code></pre>
</li><li>
<p><code>employees/_employee.html.erb</code></p>

<pre><code>&lt;p&gt;Employee: &lt;%= employee.name %&gt;&lt;/p&gt;</code></pre>
</li></ul>

<p>In this case, <a href="../../../../classes/Rails.html">Rails</a> will use
the customer or employee partials as appropriate for each member of the
collection.</p>

<p>In the event that the collection is empty, <code>render</code> will return
nil, so it should be fairly simple to provide alternative content.</p>

<pre><code>&lt;h1&gt;Products&lt;/h1&gt;
&lt;%= render(@products) || &quot;There are no products available.&quot; %&gt;</code></pre>

<h4 id="label-Local+Variables">Local Variables</h4>

<p>To use a custom local variable name within the partial, specify the
<code>:as</code> option in the call to the partial:</p>

<pre><code>&lt;%= render partial: &quot;product&quot;, collection: @products, as: :item %&gt;</code></pre>

<p>With this change, you can access an instance of the <code>@products</code>
collection as the <code>item</code> local variable within the partial.</p>

<p>You can also pass in arbitrary local variables to any partial you are
rendering with the <code>locals: {}</code> option:</p>

<pre><code>&lt;%= render partial: &quot;products&quot;, collection: @products,
           as: :item, locals: {title: &quot;Products Page&quot;} %&gt;</code></pre>

<p>Would render a partial <code>_products.html.erb</code> once for each
instance of <code>product</code> in the <code>@products</code> instance
variable passing the instance to the partial as a local variable called
<code>item</code> and to each partial, make the local variable
<code>title</code> available with the value <code>Products Page</code>.</p>

<p>TIP: <a href="../../../../classes/Rails.html">Rails</a> also makes a
counter variable available within a partial called by the collection, named
after the member of the collection followed by <code>_counter</code>. For
example, if you&#39;re rendering <code>@products</code>, within the partial
you can refer to <code>product_counter</code> to tell you how many times
the partial has been rendered. This does not work in conjunction with the
<code>as: :value</code> option.</p>

<p>You can also specify a second partial to be rendered between instances of
the main partial by using the <code>:spacer_template</code> option:</p>

<h4 id="label-Spacer+Templates">Spacer Templates</h4>

<pre><code>&lt;%= render partial: @products, spacer_template: &quot;product_ruler&quot; %&gt;</code></pre>

<p><a href="../../../../classes/Rails.html">Rails</a> will render the
<code>_product_ruler</code> partial (with no data passed in to it) between
each pair of <code>_product</code> partials.</p>

<h4 id="label-Collection+Partial+Layouts">Collection Partial Layouts</h4>

<p>When rendering collections it is also possible to use the
<code>:layout</code> option:</p>

<pre><code>&lt;%= render partial: &quot;product&quot;, collection: @products, layout: &quot;special_layout&quot; %&gt;</code></pre>

<p>The layout will be rendered together with the partial for each item in the
collection. The current object and object_counter variables will be
available in the layout as well, the same way they do within the partial.</p>

<h3 id="label-Using+Nested+Layouts">Using <a href="../../../../classes/Nested.html">Nested</a> Layouts</h3>

<p>You may find that your application requires a layout that differs slightly
from your regular application layout to support one particular controller.
Rather than repeating the main layout and editing it, you can accomplish
this by using nested layouts (sometimes called sub-templates). Here&#39;s
an example:</p>

<p>Suppose you have the following <code>ApplicationController</code> layout:</p>
<ul><li>
<p><code>app/views/layouts/application.html.erb</code></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;&lt;%= @page_title or &quot;Page Title&quot; %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag &quot;layout&quot; %&gt;
  &lt;style&gt;&lt;%= yield :stylesheets %&gt;&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;top_menu&quot;&gt;Top menu items here&lt;/div&gt;
  &lt;div id=&quot;menu&quot;&gt;Menu items here&lt;/div&gt;
  &lt;div id=&quot;content&quot;&gt;&lt;%= content_for?(:content) ? yield(:content) : yield %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li></ul>

<p>On pages generated by <code>NewsController</code>, you want to hide the top
menu and add a right menu:</p>
<ul><li>
<p><code>app/views/layouts/news.html.erb</code></p>

<pre><code>&lt;% content_for :stylesheets do %&gt;
  #top_menu {display: none}
  #right_menu {float: right; background-color: yellow; color: black}
&lt;% end %&gt;
&lt;% content_for :content do %&gt;
  &lt;div id=&quot;right_menu&quot;&gt;Right menu items here&lt;/div&gt;
  &lt;%= content_for?(:news_content) ? yield(:news_content) : yield %&gt;
&lt;% end %&gt;
&lt;%= render template: &quot;layouts/application&quot; %&gt;</code></pre>
</li></ul>

<p>That&#39;s it. The News views will use the new layout, hiding the top menu
and adding a new right menu inside the “content” div.</p>

<p>There are several ways of getting similar results with different
sub-templating schemes using this technique. Note that there is no limit in
nesting levels. <a href="../../../../classes/One.html">One</a> can use the
<code>ActionView::render</code> method via <code>render template:
&#39;layouts/news&#39;</code> to base a new layout on the News layout. If
you are sure you will not subtemplate the <code>News</code> layout, you can
replace the <code>content_for?(:news_content) ? yield(:news_content) :
yield</code> with simply <code>yield</code>.</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>