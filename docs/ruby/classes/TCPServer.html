<!DOCTYPE html>
<html lang="en">
<head>
    <title>TCPServer</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
<link rel="stylesheet" href="/css/reset.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/panel.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/github.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<script src="/js/jquery-3.5.1.min.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/main.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/highlight.pack.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/turbolinks.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/search_index.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searcher.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/panel/tree.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searchdoc.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>

<meta name="data-rel-prefix" content="/">
<meta name="data-tree-keys" content='["TCPServer"]'>


    <meta property="og:title" value="TCPServer">

  
    
    <meta name="description" content="TCPServer represents a TCP/IP server socket.  A simple TCP server may look like:  require &#39;socket&#39;  server = TCPServer.new 2000 # Server bind to port 2000 loop do   client = server.">
    <meta property="og:description" content="TCPServer represents a TCP/IP server socket.  A simple TCP server may look like:  require &#39;socket&#39;  server = TCPServer.new 2000 # Server bind to port 2000 loop do   client = server.">
  

    <meta name="keywords" content="TCPServer class, accept_nonblock, accept, sysaccept, new, listen">
</head>

<body>
    <a class="sr-only sr-only-focusable" href="#content" data-turbolinks="false">Skip to Content</a>
    <a class="sr-only sr-only-focusable" href="#search" data-turbolinks="false">Skip to Search</a>

    <input type="checkbox" id="hamburger" class="panel_checkbox">
<label class="panel_mobile_button" for="hamburger"><span></span> Menu</label>
<nav class="panel panel_tree" id="panel" data-turbolinks-permanent>
  <div class="header">
    <input type="text" placeholder="Search (/) for a class, method, ..." autosave="searchdoc" results="10" id="search" autocomplete="off" tabindex="-1" />
    <label class="panel_mobile_button_close" for="hamburger"><span></span> Close</label>
  </div>
  <div class="tree">
    <ul>
    </ul>
  </div>
  <div class="result">
    <ul>
    </ul>
  </div>
  <a href="links.html" id="links">index</a>
</nav>


    <div class="banner">
        
        <h2>
            <span class="type">Class</span>
            TCPServer
            
                <span class="parent">&lt;
                    
                    <a href="TCPSocket.html">TCPSocket</a>
                    
                </span>
            
        </h2>
        <ul class="files">
            
            <li><a href="../files/ruby/ext/socket/lib/socket_rb.html">ruby/ext/socket/lib/socket.rb</a></li>
            
            <li><a href="../files/ruby/ext/socket/tcpserver_c.html">ruby/ext/socket/tcpserver.c</a></li>
            
        </ul>
    </div>

    <main id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p><a href="TCPServer.html"><code>TCPServer</code></a> represents a TCP/IP server socket.</p>

<p>A simple TCP server may look like:</p>

<pre><code>require &#39;socket&#39;

server = TCPServer.new 2000 # Server bind to port 2000
loop do
  client = server.accept    # Wait for a client to connect
  client.puts &quot;Hello !&quot;
  client.puts &quot;Time is #{Time.now}&quot;
  client.close
end
</code></pre>

<p>A more usable server (serving multiple clients):</p>

<pre><code>require &#39;socket&#39;

server = TCPServer.new 2000
loop do
  Thread.start(server.accept) do |client|
    client.puts &quot;Hello !&quot;
    client.puts &quot;Time is #{Time.now}&quot;
    client.close
  end
end
</code></pre>

    </div>
  


  


  
  


  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>A</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-accept">accept</a>,
              </li>
            
              
              <li>
                <a href="#method-i-accept_nonblock">accept_nonblock</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>L</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-listen">listen</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>N</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-new">new</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>S</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-sysaccept">sysaccept</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    


    


    <!-- Methods -->
    
      <h2 class="sectiontitle">Class Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-c-new">
            
              <b>TCPServer.new([hostname,] port) => tcpserver
</b>
            
            <a href="../classes/TCPServer.html#method-c-new" name="method-c-new" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Creates a new server socket bound to <em>port</em>.</p>

<p>If <em>hostname</em> is given, the socket is bound to it.</p>

<pre><code>serv = TCPServer.new(&quot;127.0.0.1&quot;, 28561)
s = serv.accept
s.puts Time.now
s.close
</code></pre>

<p>Internally, <a href="TCPServer.html#method-c-new"><code>TCPServer.new</code></a> calls getaddrinfo() function to obtain addresses. If getaddrinfo() returns multiple addresses, <a href="TCPServer.html#method-c-new"><code>TCPServer.new</code></a> tries to create a server socket for each address and returns first one that is successful.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-new_source')" id="l_method-c-new_source">show</a>
                
              </p>
              <div id="method-c-new_source" class="dyn-source">
                <pre>static VALUE
tcp_svr_init(int argc, VALUE *argv, VALUE sock)
{
    VALUE hostname, port;

    rb_scan_args(argc, argv, &quot;011&quot;, &amp;hostname, &amp;port);
    return rsock_init_inetsock(sock, hostname, port, Qnil, Qnil, INET_SERVER, Qnil, Qnil);
}</pre>
              </div>
            </div>
            
          </div>
        
      
    
      <h2 class="sectiontitle">Instance Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-i-accept">
            
              <b>tcpserver.accept => tcpsocket
</b>
            
            <a href="../classes/TCPServer.html#method-i-accept" name="method-i-accept" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Accepts an incoming connection. It returns a new <a href="TCPSocket.html"><code>TCPSocket</code></a> object.</p>

<pre><code>TCPServer.open(&quot;127.0.0.1&quot;, 14641) {|serv|
  s = serv.accept
  s.puts Time.now
  s.close
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-accept_source')" id="l_method-i-accept_source">show</a>
                
              </p>
              <div id="method-i-accept_source" class="dyn-source">
                <pre>static VALUE
tcp_accept(VALUE server)
{
    union_sockaddr buffer;
    socklen_t length = sizeof(buffer);

    return rsock_s_accept(rb_cTCPSocket, server, &amp;buffer.addr, &amp;length);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-accept_nonblock">
            
              <b>tcpserver.accept_nonblock([options]) => tcpsocket
</b>
            
            <a href="../classes/TCPServer.html#method-i-accept_nonblock" name="method-i-accept_nonblock" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an accepted <a href="TCPSocket.html"><code>TCPSocket</code></a> for the incoming connection.</p>

<h3 id="method-i-accept_nonblock-label-Example">Example</h3>

<pre><code>require &#39;socket&#39;
serv = TCPServer.new(2202)
begin # emulate blocking accept
  sock = serv.accept_nonblock
rescue IO::WaitReadable, Errno::EINTR
  IO.select([serv])
  retry
end
# sock is an accepted socket.
</code></pre>

<p>Refer to <a href="Socket.html#method-i-accept"><code>Socket#accept</code></a> for the exceptions that may be thrown if the call to <a href="TCPServer.html#method-i-accept_nonblock"><code>TCPServer#accept_nonblock</code></a> fails.</p>

<p><a href="TCPServer.html#method-i-accept_nonblock"><code>TCPServer#accept_nonblock</code></a> may raise any error corresponding to accept(2) failure, including Errno::EWOULDBLOCK.</p>

<p>If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED, Errno::EPROTO, it is extended by <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a>. So <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a> can be used to rescue the exceptions for retrying accept_nonblock.</p>

<p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="TCPServer.html#method-i-accept_nonblock"><code>accept_nonblock</code></a> should not raise an <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p>

<h3 id="method-i-accept_nonblock-label-See">See</h3>
<ul><li>
<p><a href="TCPServer.html#method-i-accept"><code>TCPServer#accept</code></a></p>
</li><li>
<p><a href="Socket.html#method-i-accept"><code>Socket#accept</code></a></p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-accept_nonblock_source')" id="l_method-i-accept_nonblock_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/7b55c452b7d9a295d148ff882e0197cd139a9f8f/ext/socket/lib/socket.rb#L1319" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-i-accept_nonblock_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_nonblock</span>(<span class="ruby-value">exception:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">__accept_nonblock</span>(<span class="ruby-identifier">exception</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-listen">
            
              <b>socket.listen( int ) => 0
</b>
            
            <a href="../classes/TCPServer.html#method-i-listen" name="method-i-listen" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Listens for connections, using the specified <code>int</code> as the backlog. A call to <em>listen</em> only applies if the <code>socket</code> is of type SOCK_STREAM or SOCK_SEQPACKET.</p>

<h3 id="method-i-listen-label-Parameter">Parameter</h3>
<ul><li>
<p><code>backlog</code> - the maximum length of the queue for pending connections.</p>
</li></ul>

<h3 id="method-i-listen-label-Example+1">Example 1</h3>

<pre><code>require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.bind( sockaddr )
socket.listen( 5 )
</code></pre>

<h3 id="method-i-listen-label-Example+2+-28listening+on+an+arbitrary+port-2C+unix-based+systems+only-29-3A">Example 2 (listening on an arbitrary port, unix-based systems only):</h3>

<pre><code>require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
socket.listen( 1 )
</code></pre>

<h3 id="method-i-listen-label-Unix-based+Exceptions">Unix-based Exceptions</h3>

<p>On unix based systems the above will work because a new <code>sockaddr</code> struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the <code>socket</code> is bound by calling <em>bind</em> before it can <em>listen</em>.</p>

<p>If the <em>backlog</em> amount exceeds the implementation-dependent maximum queue length, the implementation’s maximum queue length will be used.</p>

<p>On unix-based based systems the following system exceptions may be raised if the call to <em>listen</em> fails:</p>
<ul><li>
<p>Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor</p>
</li><li>
<p>Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address, and the protocol does not support listening on an unbound socket</p>
</li><li>
<p>Errno::EINVAL - the <em>socket</em> is already connected</p>
</li><li>
<p>Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support listen</p>
</li><li>
<p>Errno::EACCES - the calling process does not have appropriate privileges</p>
</li><li>
<p>Errno::EINVAL - the <em>socket</em> has been shut down</p>
</li><li>
<p>Errno::ENOBUFS - insufficient resources are available in the system to complete the call</p>
</li></ul>

<h3 id="method-i-listen-label-Windows+Exceptions">Windows Exceptions</h3>

<p>On Windows systems the following system exceptions may be raised if the call to <em>listen</em> fails:</p>
<ul><li>
<p>Errno::ENETDOWN - the network is down</p>
</li><li>
<p>Errno::EADDRINUSE - the socket’s local address is already in use. This usually occurs during the execution of <em>bind</em> but could be delayed if the call to <em>bind</em> was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of the call to <em>listen</em></p>
</li><li>
<p>Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the service provider is still processing a callback function</p>
</li><li>
<p>Errno::EINVAL - the <code>socket</code> has not been bound with a call to <em>bind</em>.</p>
</li><li>
<p>Errno::EISCONN - the <code>socket</code> is already connected</p>
</li><li>
<p>Errno::EMFILE - no more socket descriptors are available</p>
</li><li>
<p>Errno::ENOBUFS - no buffer space is available</p>
</li><li>
<p>Errno::ENOTSOC - <code>socket</code> is not a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the referenced <code>socket</code> is not a type that supports the <em>listen</em> method</p>
</li></ul>

<h3 id="method-i-listen-label-See">See</h3>
<ul><li>
<p>listen manual pages on unix-based systems</p>
</li><li>
<p>listen function in Microsoft’s Winsock functions reference</p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-listen_source')" id="l_method-i-listen_source">show</a>
                
              </p>
              <div id="method-i-listen_source" class="dyn-source">
                <pre>VALUE
rsock_sock_listen(VALUE sock, VALUE log)
{
    rb_io_t *fptr;
    int backlog;

    backlog = NUM2INT(log);
    GetOpenFile(sock, fptr);
    if (listen(fptr-&gt;fd, backlog) &lt; 0)
        rb_sys_fail(&quot;listen(2)&quot;);

    return INT2FIX(0);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-sysaccept">
            
              <b>tcpserver.sysaccept => file_descriptor
</b>
            
            <a href="../classes/TCPServer.html#method-i-sysaccept" name="method-i-sysaccept" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a file descriptor of a accepted connection.</p>

<pre><code>TCPServer.open(&quot;127.0.0.1&quot;, 28561) {|serv|
  fd = serv.sysaccept
  s = IO.for_fd(fd)
  s.puts Time.now
  s.close
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-sysaccept_source')" id="l_method-i-sysaccept_source">show</a>
                
              </p>
              <div id="method-i-sysaccept_source" class="dyn-source">
                <pre>static VALUE
tcp_sysaccept(VALUE server)
{
    union_sockaddr buffer;
    socklen_t length = sizeof(buffer);

    return rsock_s_accept(0, server, &amp;buffer.addr, &amp;length);
}</pre>
              </div>
            </div>
            
          </div>
        
      
    
  
</div>

    </main>
  </body>
</html>
