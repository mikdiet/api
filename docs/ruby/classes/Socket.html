<!DOCTYPE html>
<html lang="en">
<head>
    <title>Socket</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
<link rel="stylesheet" href="/css/reset.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/panel.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/github.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<script src="/js/jquery-3.5.1.min.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/main.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/highlight.pack.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/turbolinks.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/search_index.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searcher.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/panel/tree.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searchdoc.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>

<meta name="data-rel-prefix" content="/">
<meta name="data-tree-keys" content='["Socket"]'>


    <meta property="og:title" value="Socket">

  
    
    <meta name="description" content="Class Socket provides access to the underlying operating system socket implementations.">
    <meta property="og:description" content="Class Socket provides access to the underlying operating system socket implementations.">
  

    <meta name="keywords" content="Socket class, getifaddrs, ipv6only!, recvfrom_nonblock, accept_nonblock, tcp, tcp_server_sockets, accept_loop, tcp_server_loop, udp_server_sockets, udp_server_recv, udp_server_loop_on, udp_server_loop, unix, unix_server_socket, unix_server_loop, connect_nonblock, new, connect, bind, listen, accept, sysaccept, recvfrom, socketpair, pair, gethostname, gethostbyname, gethostbyaddr, getservbyname, getservbyport, getaddrinfo, getnameinfo, sockaddr_in, pack_sockaddr_in, unpack_sockaddr_in, sockaddr_un, pack_sockaddr_un, unpack_sockaddr_un, ip_address_list">
</head>

<body>
    <a class="sr-only sr-only-focusable" href="#content" data-turbolinks="false">Skip to Content</a>
    <a class="sr-only sr-only-focusable" href="#search" data-turbolinks="false">Skip to Search</a>

    <input type="checkbox" id="hamburger" class="panel_checkbox">
<label class="panel_mobile_button" for="hamburger"><span></span> Menu</label>
<nav class="panel panel_tree" id="panel" data-turbolinks-permanent>
  <div class="header">
    <input type="text" placeholder="Search (/) for a class, method, ..." autosave="searchdoc" results="10" id="search" autocomplete="off" tabindex="-1" />
    <label class="panel_mobile_button_close" for="hamburger"><span></span> Close</label>
  </div>
  <div class="tree">
    <ul>
    </ul>
  </div>
  <div class="result">
    <ul>
    </ul>
  </div>
  <a href="links.html" id="links">index</a>
</nav>


    <div class="banner">
        
        <h2>
            <span class="type">Class</span>
            Socket
            
                <span class="parent">&lt;
                    
                    <a href="BasicSocket.html">BasicSocket</a>
                    
                </span>
            
        </h2>
        <ul class="files">
            
            <li><a href="../files/ruby/ext/socket/ancdata_c.html">ruby/ext/socket/ancdata.c</a></li>
            
            <li><a href="../files/ruby/ext/socket/ifaddr_c.html">ruby/ext/socket/ifaddr.c</a></li>
            
            <li><a href="../files/ruby/ext/socket/lib/socket_rb.html">ruby/ext/socket/lib/socket.rb</a></li>
            
            <li><a href="../files/ruby/ext/socket/socket_c.html">ruby/ext/socket/socket.c</a></li>
            
            <li><a href="../files/ruby/lib/drb/drb_rb.html">ruby/lib/drb/drb.rb</a></li>
            
            <li><a href="../files/ruby/lib/ipaddr_rb.html">ruby/lib/ipaddr.rb</a></li>
            
            <li><a href="../files/ruby/lib/net/http_rb.html">ruby/lib/net/http.rb</a></li>
            
            <li><a href="../files/ruby/lib/resolv_rb.html">ruby/lib/resolv.rb</a></li>
            
            <li><a href="../files/ruby/lib/rinda/ring_rb.html">ruby/lib/rinda/ring.rb</a></li>
            
        </ul>
    </div>

    <main id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p><a href="Class.html"><code>Class</code></a> <code>Socket</code> provides access to the underlying operating system socket implementations.  It can be used to provide more operating system specific functionality than the protocol-specific socket classes.</p>

<p>The constants defined under Socket::Constants are also defined under <a href="Socket.html"><code>Socket</code></a>.  For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET.  See Socket::Constants for the list of constants.</p>

<h3 id="class-Socket-label-What-27s+a+socket-3F">What’s a socket?</h3>

<p>Sockets are endpoints of a bidirectional communication channel. Sockets can communicate within a process, between processes on the same machine or between different machines.  There are many types of socket: <a href="TCPSocket.html"><code>TCPSocket</code></a>, <a href="UDPSocket.html"><code>UDPSocket</code></a> or <a href="UNIXSocket.html"><code>UNIXSocket</code></a> for example.</p>

<p>Sockets have their own vocabulary:</p>

<p><strong>domain:</strong> The family of protocols:</p>
<ul><li>
<p>Socket::PF_INET</p>
</li><li>
<p>Socket::PF_INET6</p>
</li><li>
<p>Socket::PF_UNIX</p>
</li><li>
<p>etc.</p>
</li></ul>

<p><strong>type:</strong> The type of communications between the two endpoints, typically</p>
<ul><li>
<p>Socket::SOCK_STREAM</p>
</li><li>
<p>Socket::SOCK_DGRAM.</p>
</li></ul>

<p><strong>protocol:</strong> Typically <em>zero</em>. This may be used to identify a variant of a protocol.</p>

<p><strong>hostname:</strong> The identifier of a network interface:</p>
<ul><li>
<p>a string (hostname, IPv4 or IPv6 address or <code>broadcast</code> which specifies a broadcast address)</p>
</li><li>
<p>a zero-length string which specifies INADDR_ANY</p>
</li><li>
<p>an integer (interpreted as binary address in host byte order).</p>
</li></ul>

<h3 id="class-Socket-label-Quick+start">Quick start</h3>

<p>Many of the classes, such as <a href="TCPSocket.html"><code>TCPSocket</code></a>, <a href="UDPSocket.html"><code>UDPSocket</code></a> or <a href="UNIXSocket.html"><code>UNIXSocket</code></a>, ease the use of sockets comparatively to the equivalent C programming interface.</p>

<p>Let’s create an internet socket using the IPv4 protocol in a C-like manner:</p>

<pre><code>require &#39;socket&#39;

s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
s.connect Socket.pack_sockaddr_in(80, &#39;example.com&#39;)
</code></pre>

<p>You could also use the <a href="TCPSocket.html"><code>TCPSocket</code></a> class:</p>

<pre><code>s = TCPSocket.new &#39;example.com&#39;, 80
</code></pre>

<p>A simple server might look like this:</p>

<pre><code>require &#39;socket&#39;

server = TCPServer.new 2000 # Server bound to port 2000

loop do
  client = server.accept    # Wait for a client to connect
  client.puts &quot;Hello !&quot;
  client.puts &quot;Time is #{Time.now}&quot;
  client.close
end
</code></pre>

<p>A simple client may look like this:</p>

<pre><code>require &#39;socket&#39;

s = TCPSocket.new &#39;localhost&#39;, 2000

while line = s.gets # Read lines from socket
  puts line         # and print them
end

s.close             # close socket when done
</code></pre>

<h3 id="class-Socket-label-Exception+Handling"><a href="Exception.html"><code>Exception</code></a> Handling</h3>

<p>Ruby’s <a href="Socket.html"><code>Socket</code></a> implementation raises exceptions based on the error generated by the system dependent implementation.  This is why the methods are documented in a way that isolate Unix-based system exceptions from Windows based exceptions. If more information on a particular exception is needed, please refer to the Unix manual pages or the Windows WinSock reference.</p>

<h3 id="class-Socket-label-Convenience+methods">Convenience methods</h3>

<p>Although the general way to create socket is <a href="Socket.html#method-c-new"><code>Socket.new</code></a>, there are several methods of socket creation for most cases.</p>
<dl class="rdoc-list note-list"><dt>TCP client socket
<dd>
<p><a href="Socket.html#method-c-tcp"><code>Socket.tcp</code></a>, <a href="IO.html#method-c-open"><code>TCPSocket.open</code></a></p>
</dd><dt>TCP server socket
<dd>
<p><a href="Socket.html#method-c-tcp_server_loop"><code>Socket.tcp_server_loop</code></a>, <a href="IO.html#method-c-open"><code>TCPServer.open</code></a></p>
</dd><dt>UNIX client socket
<dd>
<p><a href="Socket.html#method-c-unix"><code>Socket.unix</code></a>, <a href="IO.html#method-c-open"><code>UNIXSocket.open</code></a></p>
</dd><dt>UNIX server socket
<dd>
<p><a href="Socket.html#method-c-unix_server_loop"><code>Socket.unix_server_loop</code></a>, <a href="IO.html#method-c-open"><code>UNIXServer.open</code></a></p>
</dd></dl>

<h3 id="class-Socket-label-Documentation+by">Documentation by</h3>
<ul><li>
<p>Zach Dennis</p>
</li><li>
<p>Sam Roberts</p>
</li><li>
<p><em>Programming Ruby</em> from The Pragmatic Bookshelf.</p>
</li></ul>

<p>Much material in this documentation is taken with permission from <em>Programming Ruby</em> from The Pragmatic Bookshelf.</p>

    </div>
  


  


  
  


  
    <!-- Namespace -->
    <div class="sectiontitle">Namespace</div>
    <ul>
      
        <li>
          <span class="type">CLASS</span>
          <a href="Socket/AncillaryData.html">Socket::AncillaryData</a>
        </li>
      
        <li>
          <span class="type">CLASS</span>
          <a href="Socket/Ifaddr.html">Socket::Ifaddr</a>
        </li>
      
        <li>
          <span class="type">CLASS</span>
          <a href="Socket/Option.html">Socket::Option</a>
        </li>
      
        <li>
          <span class="type">CLASS</span>
          <a href="Socket/ResolutionError.html">Socket::ResolutionError</a>
        </li>
      
        <li>
          <span class="type">CLASS</span>
          <a href="Socket/UDPSource.html">Socket::UDPSource</a>
        </li>
      
    </ul>
  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>A</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-accept">accept</a>,
              </li>
            
              
              <li>
                <a href="#method-c-accept_loop">accept_loop</a>,
              </li>
            
              
              <li>
                <a href="#method-i-accept_nonblock">accept_nonblock</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>B</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-bind">bind</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>C</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-connect">connect</a>,
              </li>
            
              
              <li>
                <a href="#method-i-connect_nonblock">connect_nonblock</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>G</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-getaddrinfo">getaddrinfo</a>,
              </li>
            
              
              <li>
                <a href="#method-c-gethostbyaddr">gethostbyaddr</a>,
              </li>
            
              
              <li>
                <a href="#method-c-gethostbyname">gethostbyname</a>,
              </li>
            
              
              <li>
                <a href="#method-c-gethostname">gethostname</a>,
              </li>
            
              
              <li>
                <a href="#method-c-getifaddrs">getifaddrs</a>,
              </li>
            
              
              <li>
                <a href="#method-c-getnameinfo">getnameinfo</a>,
              </li>
            
              
              <li>
                <a href="#method-c-getservbyname">getservbyname</a>,
              </li>
            
              
              <li>
                <a href="#method-c-getservbyport">getservbyport</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>I</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-ip_address_list">ip_address_list</a>,
              </li>
            
              
              <li>
                <a href="#method-i-ipv6only-21">ipv6only!</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>L</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-listen">listen</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>N</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-new">new</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>P</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-pack_sockaddr_in">pack_sockaddr_in</a>,
              </li>
            
              
              <li>
                <a href="#method-c-pack_sockaddr_un">pack_sockaddr_un</a>,
              </li>
            
              
              <li>
                <a href="#method-c-pair">pair</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>R</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-recvfrom">recvfrom</a>,
              </li>
            
              
              <li>
                <a href="#method-i-recvfrom_nonblock">recvfrom_nonblock</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>S</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-sockaddr_in">sockaddr_in</a>,
              </li>
            
              
              <li>
                <a href="#method-c-sockaddr_un">sockaddr_un</a>,
              </li>
            
              
              <li>
                <a href="#method-c-socketpair">socketpair</a>,
              </li>
            
              
              <li>
                <a href="#method-i-sysaccept">sysaccept</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>T</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-tcp">tcp</a>,
              </li>
            
              
              <li>
                <a href="#method-c-tcp_server_loop">tcp_server_loop</a>,
              </li>
            
              
              <li>
                <a href="#method-c-tcp_server_sockets">tcp_server_sockets</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>U</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-c-udp_server_loop">udp_server_loop</a>,
              </li>
            
              
              <li>
                <a href="#method-c-udp_server_loop_on">udp_server_loop_on</a>,
              </li>
            
              
              <li>
                <a href="#method-c-udp_server_recv">udp_server_recv</a>,
              </li>
            
              
              <li>
                <a href="#method-c-udp_server_sockets">udp_server_sockets</a>,
              </li>
            
              
              <li>
                <a href="#method-c-unix">unix</a>,
              </li>
            
              
              <li>
                <a href="#method-c-unix_server_loop">unix_server_loop</a>,
              </li>
            
              
              <li>
                <a href="#method-c-unix_server_socket">unix_server_socket</a>,
              </li>
            
              
              <li>
                <a href="#method-c-unpack_sockaddr_in">unpack_sockaddr_in</a>,
              </li>
            
              
              <li>
                <a href="#method-c-unpack_sockaddr_un">unpack_sockaddr_un</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    
      <!-- Section constants -->
      <h2 class="sectiontitle">Constants</h2>
      <table border='0' cellpadding='5'>
        
          <tr valign='top'>
            <td class="attr-name">AF_INET6</td>
            <td>=</td>
            <td class="attr-value">Object.new.freeze</td>
          </tr>
          
            <tr valign='top'>
              <td>&nbsp;</td>
              <td colspan="2" class="attr-desc"><p>IPv6 protocol family</p></td>
            </tr>
          
        
      </table>
    


    


    <!-- Methods -->
    
      <h2 class="sectiontitle">Class Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-c-accept_loop">
            
              <b>accept_loop</b>(*sockets)
            
            <a href="../classes/Socket.html#method-c-accept_loop" name="method-c-accept_loop" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>yield socket and client address for each a connection accepted via given sockets.</p>

<p>The arguments are a list of sockets. The individual argument should be a socket or an array of sockets.</p>

<p>This method yields the block sequentially. It means that the next connection is not accepted until the block returns. So concurrent mechanism, thread for example, should be used to service multiple clients at a time.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-accept_loop_source')" id="l_method-c-accept_loop_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L805" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-accept_loop_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 805</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">accept_loop</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">sockets</span>) <span class="ruby-comment"># :yield: socket, client_addrinfo</span>
  <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;no sockets&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">loop</span> {
    <span class="ruby-identifier">readable</span>, <span class="ruby-identifier">_</span>, <span class="ruby-identifier">_</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>(<span class="ruby-identifier">sockets</span>)
    <span class="ruby-identifier">readable</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">sock</span>, <span class="ruby-identifier">addr</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">accept_nonblock</span>(<span class="ruby-value">exception:</span> <span class="ruby-keyword">false</span>)
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">sock</span> <span class="ruby-operator">==</span> <span class="ruby-value">:wait_readable</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">sock</span>, <span class="ruby-identifier">addr</span>
    }
  }
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-getaddrinfo">
            
              <b>Socket.getaddrinfo(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) => array
</b>
            
            <a href="../classes/Socket.html#method-c-getaddrinfo" name="method-c-getaddrinfo" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Obtains address information for <em>nodename</em>:<em>servname</em>.</p>

<p>Note that <a href="Addrinfo.html#method-c-getaddrinfo"><code>Addrinfo.getaddrinfo</code></a> provides the same functionality in an object oriented style.</p>

<p><em>family</em> should be an address family such as: :INET, :INET6, etc.</p>

<p><em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</p>

<p><em>protocol</em> should be a protocol defined in the family, and defaults to 0 for the family.</p>

<p><em>flags</em> should be bitwise OR of Socket::AI_* constants.</p>

<pre><code>Socket.getaddrinfo(&quot;www.ruby-lang.org&quot;, &quot;http&quot;, nil, :STREAM)
#=&gt; [[&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;, 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP

Socket.getaddrinfo(&quot;localhost&quot;, nil)
#=&gt; [[&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
#    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
#    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP
</code></pre>

<p><em>reverse_lookup</em> directs the form of the third element, and has to be one of below.  If <em>reverse_lookup</em> is omitted, the default value is <code>nil</code>.</p>

<pre><code>+true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
+false+, +:numeric+:  hostname is the same as numeric address.
+nil+:              obey to the current +do_not_reverse_lookup+ flag.
</code></pre>

<p>If <a href="Addrinfo.html"><code>Addrinfo</code></a> object is preferred, use <a href="Addrinfo.html#method-c-getaddrinfo"><code>Addrinfo.getaddrinfo</code></a>.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-getaddrinfo_source')" id="l_method-c-getaddrinfo_source">show</a>
                
              </p>
              <div id="method-c-getaddrinfo_source" class="dyn-source">
                <pre>static VALUE
sock_s_getaddrinfo(int argc, VALUE *argv, VALUE _)
{
    VALUE host, port, family, socktype, protocol, flags, ret, revlookup;
    struct addrinfo hints;
    struct rb_addrinfo *res;
    int norevlookup;

    rb_scan_args(argc, argv, &quot;25&quot;, &amp;host, &amp;port, &amp;family, &amp;socktype, &amp;protocol, &amp;flags, &amp;revlookup);

    MEMZERO(&amp;hints, struct addrinfo, 1);
    hints.ai_family = NIL_P(family) ? PF_UNSPEC : rsock_family_arg(family);

    if (!NIL_P(socktype)) {
        hints.ai_socktype = rsock_socktype_arg(socktype);
    }
    if (!NIL_P(protocol)) {
        hints.ai_protocol = NUM2INT(protocol);
    }
    if (!NIL_P(flags)) {
        hints.ai_flags = NUM2INT(flags);
    }
    if (NIL_P(revlookup) || !rsock_revlookup_flag(revlookup, &amp;norevlookup)) {
        norevlookup = rsock_do_not_reverse_lookup;
    }

    res = rsock_getaddrinfo(host, port, &amp;hints, 0);

    ret = make_addrinfo(res, norevlookup);
    rb_freeaddrinfo(res);
    return ret;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-gethostbyaddr">
            
              <b>Socket.gethostbyaddr(address_string [, address_family]) => hostent
</b>
            
            <a href="../classes/Socket.html#method-c-gethostbyaddr" name="method-c-gethostbyaddr" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Use <a href="Addrinfo.html#method-i-getnameinfo"><code>Addrinfo#getnameinfo</code></a> instead. This method is deprecated for the following reasons:</p>
<ul><li>
<p>Uncommon address representation: 4/16-bytes binary string to represent IPv4/IPv6 address.</p>
</li><li>
<p>gethostbyaddr() may take a long time and it may block other threads. (GVL cannot be released since gethostbyname() is not thread safe.)</p>
</li><li>
<p>This method uses gethostbyname() function already removed from POSIX.</p>
</li></ul>

<p>This method obtains the host information for <em>address</em>.</p>

<pre><code>p Socket.gethostbyaddr([221,186,184,68].pack(&quot;CCCC&quot;))
#=&gt; [&quot;carbon.ruby-lang.org&quot;, [], 2, &quot;\xDD\xBA\xB8D&quot;]

p Socket.gethostbyaddr([127,0,0,1].pack(&quot;CCCC&quot;))
[&quot;localhost&quot;, [], 2, &quot;\x7F\x00\x00\x01&quot;]
p Socket.gethostbyaddr(([0]*15+[1]).pack(&quot;C&quot;*16))
#=&gt; [&quot;localhost&quot;, [&quot;ip6-localhost&quot;, &quot;ip6-loopback&quot;], 10,
     &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&quot;]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-gethostbyaddr_source')" id="l_method-c-gethostbyaddr_source">show</a>
                
              </p>
              <div id="method-c-gethostbyaddr_source" class="dyn-source">
                <pre>static VALUE
sock_s_gethostbyaddr(int argc, VALUE *argv, VALUE _)
{
    VALUE addr, family;
    struct hostent *h;
    char **pch;
    VALUE ary, names;
    int t = AF_INET;

    rb_warn(&quot;Socket.gethostbyaddr is deprecated; use Addrinfo#getnameinfo instead.&quot;);

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;addr, &amp;family);
    StringValue(addr);
    if (!NIL_P(family)) {
        t = rsock_family_arg(family);
    }
#ifdef AF_INET6
    else if (RSTRING_LEN(addr) == 16) {
        t = AF_INET6;
    }
#endif
    h = gethostbyaddr(RSTRING_PTR(addr), RSTRING_SOCKLEN(addr), t);
    if (h == NULL) {
#ifdef HAVE_HSTRERROR
        extern int h_errno;
        rb_raise(rb_eSocket, &quot;%s&quot;, (char*)hstrerror(h_errno));
#else
        rb_raise(rb_eSocket, &quot;host not found&quot;);
#endif
    }
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h-&gt;h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    if (h-&gt;h_aliases != NULL) {
        for (pch = h-&gt;h_aliases; *pch; pch++) {
            rb_ary_push(names, rb_str_new2(*pch));
        }
    }
    rb_ary_push(ary, INT2NUM(h-&gt;h_addrtype));
#ifdef h_addr
    for (pch = h-&gt;h_addr_list; *pch; pch++) {
        rb_ary_push(ary, rb_str_new(*pch, h-&gt;h_length));
    }
#else
    rb_ary_push(ary, rb_str_new(h-&gt;h_addr, h-&gt;h_length));
#endif

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-gethostbyname">
            
              <b>Socket.gethostbyname(hostname) => [official_hostname, alias_hostnames, address_family, *address_list]
</b>
            
            <a href="../classes/Socket.html#method-c-gethostbyname" name="method-c-gethostbyname" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Use <a href="Addrinfo.html#method-c-getaddrinfo"><code>Addrinfo.getaddrinfo</code></a> instead. This method is deprecated for the following reasons:</p>
<ul><li>
<p>The 3rd element of the result is the address family of the first address. The address families of the rest of the addresses are not returned.</p>
</li><li>
<p>Uncommon address representation: 4/16-bytes binary string to represent IPv4/IPv6 address.</p>
</li><li>
<p>gethostbyname() may take a long time and it may block other threads. (GVL cannot be released since gethostbyname() is not thread safe.)</p>
</li><li>
<p>This method uses gethostbyname() function already removed from POSIX.</p>
</li></ul>

<p>This method obtains the host information for <em>hostname</em>.</p>

<pre><code>p Socket.gethostbyname(&quot;hal&quot;) #=&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;\x7F\x00\x00\x01&quot;]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-gethostbyname_source')" id="l_method-c-gethostbyname_source">show</a>
                
              </p>
              <div id="method-c-gethostbyname_source" class="dyn-source">
                <pre>static VALUE
sock_s_gethostbyname(VALUE obj, VALUE host)
{
    rb_warn(&quot;Socket.gethostbyname is deprecated; use Addrinfo.getaddrinfo instead.&quot;);
    struct rb_addrinfo *res =
        rsock_addrinfo(host, Qnil, AF_UNSPEC, SOCK_STREAM, AI_CANONNAME);
    return rsock_make_hostent(host, res, sock_sockaddr);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-gethostname">
            
              <b>Socket.gethostname => hostname
</b>
            
            <a href="../classes/Socket.html#method-c-gethostname" name="method-c-gethostname" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the hostname.</p>

<pre><code>p Socket.gethostname #=&gt; &quot;hal&quot;
</code></pre>

<p>Note that it is not guaranteed to be able to convert to IP address using gethostbyname, getaddrinfo, etc. If you need local IP address, use <a href="Socket.html#method-c-ip_address_list"><code>Socket.ip_address_list</code></a>.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-gethostname_source')" id="l_method-c-gethostname_source">show</a>
                
              </p>
              <div id="method-c-gethostname_source" class="dyn-source">
                <pre>static VALUE
sock_gethostname(VALUE obj)
{
#if defined(NI_MAXHOST)
#  define RUBY_MAX_HOST_NAME_LEN NI_MAXHOST
#elif defined(HOST_NAME_MAX)
#  define RUBY_MAX_HOST_NAME_LEN HOST_NAME_MAX
#else
#  define RUBY_MAX_HOST_NAME_LEN 1024
#endif

    long len = RUBY_MAX_HOST_NAME_LEN;
    VALUE name;

    name = rb_str_new(0, len);
    while (gethostname(RSTRING_PTR(name), len) &lt; 0) {
        int e = errno;
        switch (e) {
          case ENAMETOOLONG:
#ifdef __linux__
          case EINVAL:
            /* glibc before version 2.1 uses EINVAL instead of ENAMETOOLONG */
#endif
            break;
          default:
            rb_syserr_fail(e, &quot;gethostname(3)&quot;);
        }
        rb_str_modify_expand(name, len);
        len += len;
    }
    rb_str_resize(name, strlen(RSTRING_PTR(name)));
    return name;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-getifaddrs">
            
              <b>Socket.getifaddrs => [ifaddr1, ...]
</b>
            
            <a href="../classes/Socket.html#method-c-getifaddrs" name="method-c-getifaddrs" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns an array of interface addresses. An element of the array is an instance of <a href="Socket/Ifaddr.html"><code>Socket::Ifaddr</code></a>.</p>

<p>This method can be used to find multicast-enabled interfaces:</p>

<pre><code>pp Socket.getifaddrs.reject {|ifaddr|
  !ifaddr.addr.ip? || (ifaddr.flags &amp; Socket::IFF_MULTICAST == 0)
}.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
#=&gt; [[&quot;eth0&quot;, 2, #&lt;Addrinfo: 221.186.184.67&gt;],
#    [&quot;eth0&quot;, 2, #&lt;Addrinfo: fe80::216:3eff:fe95:88bb%eth0&gt;]]
</code></pre>

<p>Example result on GNU/Linux:</p>

<pre><code>pp Socket.getifaddrs
#=&gt; [#&lt;Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]&gt;,
#    #&lt;Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]&gt;,
#    #&lt;Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]&gt;,
#    #&lt;Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0&gt;,
#    #&lt;Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79&gt;,
#    #&lt;Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&gt;,
#    #&lt;Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::&gt;]
</code></pre>

<p>Example result on FreeBSD:</p>

<pre><code>pp Socket.getifaddrs
#=&gt; [#&lt;Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]&gt;,
#    #&lt;Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]&gt;,
#    #&lt;Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255&gt;,
#    #&lt;Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::&gt;,
#    #&lt;Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC&gt;,
#    #&lt;Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]&gt;,
#    #&lt;Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]&gt;,
#    #&lt;Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&gt;,
#    #&lt;Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::&gt;,
#    #&lt;Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)&gt;]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-getifaddrs_source')" id="l_method-c-getifaddrs_source">show</a>
                
              </p>
              <div id="method-c-getifaddrs_source" class="dyn-source">
                <pre>static VALUE
socket_s_getifaddrs(VALUE self)
{
    return rsock_getifaddrs();
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-getnameinfo">
            
              <b>Socket.getnameinfo(sockaddr [, flags]) => [hostname, servicename]
</b>
            
            <a href="../classes/Socket.html#method-c-getnameinfo" name="method-c-getnameinfo" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Obtains name information for <em>sockaddr</em>.</p>

<p><em>sockaddr</em> should be one of follows.</p>
<ul><li>
<p>packed sockaddr string such as <a href="Socket.html#method-c-sockaddr_in"><code>Socket.sockaddr_in</code></a>(80, “127.0.0.1”)</p>
</li><li>
<p>3-elements array such as [“AF_INET”, 80, “127.0.0.1”]</p>
</li><li>
<p>4-elements array such as [“AF_INET”, 80, ignored, “127.0.0.1”]</p>
</li></ul>

<p><em>flags</em> should be bitwise OR of Socket::NI_* constants.</p>

<p>Note: The last form is compatible with <a href="IPSocket.html#method-i-addr"><code>IPSocket#addr</code></a> and <a href="IPSocket.html#method-i-peeraddr"><code>IPSocket#peeraddr</code></a>.</p>

<pre><code>Socket.getnameinfo(Socket.sockaddr_in(80, &quot;127.0.0.1&quot;))       #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;])              #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;localhost&quot;, &quot;127.0.0.1&quot;]) #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
</code></pre>

<p>If <a href="Addrinfo.html"><code>Addrinfo</code></a> object is preferred, use <a href="Addrinfo.html#method-i-getnameinfo"><code>Addrinfo#getnameinfo</code></a>.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-getnameinfo_source')" id="l_method-c-getnameinfo_source">show</a>
                
              </p>
              <div id="method-c-getnameinfo_source" class="dyn-source">
                <pre>static VALUE
sock_s_getnameinfo(int argc, VALUE *argv, VALUE _)
{
    VALUE sa, af = Qnil, host = Qnil, port = Qnil, flags, tmp;
    char hbuf[1024], pbuf[1024];
    int fl;
    struct rb_addrinfo *res = NULL;
    struct addrinfo hints, *r;
    int error, saved_errno;
    union_sockaddr ss;
    struct sockaddr *sap;
    socklen_t salen;

    sa = flags = Qnil;
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;sa, &amp;flags);

    fl = 0;
    if (!NIL_P(flags)) {
        fl = NUM2INT(flags);
    }
    tmp = rb_check_sockaddr_string_type(sa);
    if (!NIL_P(tmp)) {
        sa = tmp;
        if (sizeof(ss) &lt; (size_t)RSTRING_LEN(sa)) {
            rb_raise(rb_eTypeError, &quot;sockaddr length too big&quot;);
        }
        memcpy(&amp;ss, RSTRING_PTR(sa), RSTRING_LEN(sa));
        if (!VALIDATE_SOCKLEN(&amp;ss.addr, RSTRING_LEN(sa))) {
            rb_raise(rb_eTypeError, &quot;sockaddr size differs - should not happen&quot;);
        }
        sap = &amp;ss.addr;
        salen = RSTRING_SOCKLEN(sa);
        goto call_nameinfo;
    }
    tmp = rb_check_array_type(sa);
    if (!NIL_P(tmp)) {
        sa = tmp;
        MEMZERO(&amp;hints, struct addrinfo, 1);
        if (RARRAY_LEN(sa) == 3) {
            af = RARRAY_AREF(sa, 0);
            port = RARRAY_AREF(sa, 1);
            host = RARRAY_AREF(sa, 2);
        }
        else if (RARRAY_LEN(sa) &gt;= 4) {
            af = RARRAY_AREF(sa, 0);
            port = RARRAY_AREF(sa, 1);
            host = RARRAY_AREF(sa, 3);
            if (NIL_P(host)) {
                host = RARRAY_AREF(sa, 2);
            }
            else {
                /*
                 * 4th element holds numeric form, don&#39;t resolve.
                 * see rsock_ipaddr().
                 */
#ifdef AI_NUMERICHOST /* AIX 4.3.3 doesn&#39;t have AI_NUMERICHOST. */
                hints.ai_flags |= AI_NUMERICHOST;
#endif
            }
        }
        else {
            rb_raise(rb_eArgError, &quot;array size should be 3 or 4, %ld given&quot;,
                     RARRAY_LEN(sa));
        }
        hints.ai_socktype = (fl &amp; NI_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
        /* af */
        hints.ai_family = NIL_P(af) ? PF_UNSPEC : rsock_family_arg(af);
        res = rsock_getaddrinfo(host, port, &amp;hints, 0);
        sap = res-&gt;ai-&gt;ai_addr;
        salen = res-&gt;ai-&gt;ai_addrlen;
    }
    else {
        rb_raise(rb_eTypeError, &quot;expecting String or Array&quot;);
    }

  call_nameinfo:
    error = rb_getnameinfo(sap, salen, hbuf, sizeof(hbuf),
                           pbuf, sizeof(pbuf), fl);
    if (error) goto error_exit_name;
    if (res) {
        for (r = res-&gt;ai-&gt;ai_next; r; r = r-&gt;ai_next) {
            char hbuf2[1024], pbuf2[1024];

            sap = r-&gt;ai_addr;
            salen = r-&gt;ai_addrlen;
            error = rb_getnameinfo(sap, salen, hbuf2, sizeof(hbuf2),
                                   pbuf2, sizeof(pbuf2), fl);
            if (error) goto error_exit_name;
            if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
                rb_freeaddrinfo(res);
                rb_raise(rb_eSocket, &quot;sockaddr resolved to multiple nodename&quot;);
            }
        }
        rb_freeaddrinfo(res);
    }
    return rb_assoc_new(rb_str_new2(hbuf), rb_str_new2(pbuf));

  error_exit_name:
    saved_errno = errno;
    if (res) rb_freeaddrinfo(res);
    errno = saved_errno;
    rsock_raise_resolution_error(&quot;getnameinfo&quot;, error);

    UNREACHABLE_RETURN(Qnil);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-getservbyname">
            
              <b>Socket.getservbyname(service_name)                => port_number<br />Socket.getservbyname(service_name, protocol_name) => port_number
</b>
            
            <a href="../classes/Socket.html#method-c-getservbyname" name="method-c-getservbyname" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Obtains the port number for <em>service_name</em>.</p>

<p>If <em>protocol_name</em> is not given, “tcp” is assumed.</p>

<pre><code>Socket.getservbyname(&quot;smtp&quot;)          #=&gt; 25
Socket.getservbyname(&quot;shell&quot;)         #=&gt; 514
Socket.getservbyname(&quot;syslog&quot;, &quot;udp&quot;) #=&gt; 514
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-getservbyname_source')" id="l_method-c-getservbyname_source">show</a>
                
              </p>
              <div id="method-c-getservbyname_source" class="dyn-source">
                <pre>static VALUE
sock_s_getservbyname(int argc, VALUE *argv, VALUE _)
{
    VALUE service, proto;
    struct servent *sp;
    long port;
    const char *servicename, *protoname = &quot;tcp&quot;;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;service, &amp;proto);
    StringValue(service);
    if (!NIL_P(proto)) StringValue(proto);
    servicename = StringValueCStr(service);
    if (!NIL_P(proto)) protoname = StringValueCStr(proto);
    sp = getservbyname(servicename, protoname);
    if (sp) {
        port = ntohs(sp-&gt;s_port);
    }
    else {
        char *end;

        port = STRTOUL(servicename, &amp;end, 0);
        if (*end != &#39;\0&#39;) {
            rb_raise(rb_eSocket, &quot;no such service %s/%s&quot;, servicename, protoname);
        }
    }
    return INT2FIX(port);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-getservbyport">
            
              <b>Socket.getservbyport(port [, protocol_name]) => service
</b>
            
            <a href="../classes/Socket.html#method-c-getservbyport" name="method-c-getservbyport" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Obtains the port number for <em>port</em>.</p>

<p>If <em>protocol_name</em> is not given, “tcp” is assumed.</p>

<pre><code>Socket.getservbyport(80)         #=&gt; &quot;www&quot;
Socket.getservbyport(514, &quot;tcp&quot;) #=&gt; &quot;shell&quot;
Socket.getservbyport(514, &quot;udp&quot;) #=&gt; &quot;syslog&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-getservbyport_source')" id="l_method-c-getservbyport_source">show</a>
                
              </p>
              <div id="method-c-getservbyport_source" class="dyn-source">
                <pre>static VALUE
sock_s_getservbyport(int argc, VALUE *argv, VALUE _)
{
    VALUE port, proto;
    struct servent *sp;
    long portnum;
    const char *protoname = &quot;tcp&quot;;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;port, &amp;proto);
    portnum = NUM2LONG(port);
    if (portnum != (uint16_t)portnum) {
        const char *s = portnum &gt; 0 ? &quot;big&quot; : &quot;small&quot;;
        rb_raise(rb_eRangeError, &quot;integer %ld too %s to convert into `int16_t&#39;&quot;, portnum, s);
    }
    if (!NIL_P(proto)) protoname = StringValueCStr(proto);

    sp = getservbyport((int)htons((uint16_t)portnum), protoname);
    if (!sp) {
        rb_raise(rb_eSocket, &quot;no such service for port %d/%s&quot;, (int)portnum, protoname);
    }
    return rb_str_new2(sp-&gt;s_name);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-ip_address_list">
            
              <b>Socket.ip_address_list => array
</b>
            
            <a href="../classes/Socket.html#method-c-ip_address_list" name="method-c-ip_address_list" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns local IP addresses as an array.</p>

<p>The array contains <a href="Addrinfo.html"><code>Addrinfo</code></a> objects.</p>

<pre><code>pp Socket.ip_address_list
#=&gt; [#&lt;Addrinfo: 127.0.0.1&gt;,
     #&lt;Addrinfo: 192.168.0.128&gt;,
     #&lt;Addrinfo: ::1&gt;,
     ...]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-ip_address_list_source')" id="l_method-c-ip_address_list_source">show</a>
                
              </p>
              <div id="method-c-ip_address_list_source" class="dyn-source">
                <pre>static VALUE
socket_s_ip_address_list(VALUE self)
{
#if defined(HAVE_GETIFADDRS)
    struct ifaddrs *ifp = NULL;
    struct ifaddrs *p;
    int ret;
    VALUE list;

    ret = getifaddrs(&amp;ifp);
    if (ret == -1) {
        rb_sys_fail(&quot;getifaddrs&quot;);
    }

    list = rb_ary_new();
    for (p = ifp; p; p = p-&gt;ifa_next) {
        if (p-&gt;ifa_addr != NULL &amp;&amp; IS_IP_FAMILY(p-&gt;ifa_addr-&gt;sa_family)) {
            struct sockaddr *addr = p-&gt;ifa_addr;
#if defined(AF_INET6) &amp;&amp; defined(__sun)
            /*
             * OpenIndiana SunOS 5.11 getifaddrs() returns IPv6 link local
             * address with sin6_scope_id == 0.
             * So fill it from the interface name (ifa_name).
             */
            struct sockaddr_in6 addr6;
            if (addr-&gt;sa_family == AF_INET6) {
                socklen_t len = (socklen_t)sizeof(struct sockaddr_in6);
                memcpy(&amp;addr6, addr, len);
                addr = (struct sockaddr *)&amp;addr6;
                if (IN6_IS_ADDR_LINKLOCAL(&amp;addr6.sin6_addr) &amp;&amp;
                    addr6.sin6_scope_id == 0) {
                    unsigned int ifindex = if_nametoindex(p-&gt;ifa_name);
                    if (ifindex != 0) {
                        addr6.sin6_scope_id = ifindex;
                    }
                }
            }
#endif
            rb_ary_push(list, sockaddr_obj(addr, sockaddr_len(addr)));
        }
    }

    freeifaddrs(ifp);

    return list;
#elif defined(SIOCGLIFCONF) &amp;&amp; defined(SIOCGLIFNUM)
    /* Solaris if_tcp(7P) */
    int fd = -1;
    int ret;
    struct lifnum ln;
    struct lifconf lc;
    const char *reason = NULL;
    int save_errno;
    int i;
    VALUE list = Qnil;

    lc.lifc_buf = NULL;

    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd == -1)
        rb_sys_fail(&quot;socket(2)&quot;);

    memset(&amp;ln, 0, sizeof(ln));
    ln.lifn_family = AF_UNSPEC;

    ret = ioctl(fd, SIOCGLIFNUM, &amp;ln);
    if (ret == -1) {
        reason = &quot;SIOCGLIFNUM&quot;;
        goto finish;
    }

    memset(&amp;lc, 0, sizeof(lc));
    lc.lifc_family = AF_UNSPEC;
    lc.lifc_flags = 0;
    lc.lifc_len = sizeof(struct lifreq) * ln.lifn_count;
    lc.lifc_req = xmalloc(lc.lifc_len);

    ret = ioctl(fd, SIOCGLIFCONF, &amp;lc);
    if (ret == -1) {
        reason = &quot;SIOCGLIFCONF&quot;;
        goto finish;
    }

    list = rb_ary_new();
    for (i = 0; i &lt; ln.lifn_count; i++) {
        struct lifreq *req = &amp;lc.lifc_req[i];
        if (IS_IP_FAMILY(req-&gt;lifr_addr.ss_family)) {
            if (req-&gt;lifr_addr.ss_family == AF_INET6 &amp;&amp;
                IN6_IS_ADDR_LINKLOCAL(&amp;((struct sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_addr) &amp;&amp;
                ((struct sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_scope_id == 0) {
                struct lifreq req2;
                memcpy(req2.lifr_name, req-&gt;lifr_name, LIFNAMSIZ);
                ret = ioctl(fd, SIOCGLIFINDEX, &amp;req2);
                if (ret == -1) {
                    reason = &quot;SIOCGLIFINDEX&quot;;
                    goto finish;
                }
                ((struct sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_scope_id = req2.lifr_index;
            }
            rb_ary_push(list, sockaddr_obj((struct sockaddr *)&amp;req-&gt;lifr_addr, req-&gt;lifr_addrlen));
        }
    }

  finish:
    save_errno = errno;
    xfree(lc.lifc_req);
    if (fd != -1)
        close(fd);
    errno = save_errno;

    if (reason)
        rb_syserr_fail(save_errno, reason);
    return list;

#elif defined(SIOCGIFCONF)
    int fd = -1;
    int ret;
#define EXTRA_SPACE ((int)(sizeof(struct ifconf) + sizeof(union_sockaddr)))
    char initbuf[4096+EXTRA_SPACE];
    char *buf = initbuf;
    int bufsize;
    struct ifconf conf;
    struct ifreq *req;
    VALUE list = Qnil;
    const char *reason = NULL;
    int save_errno;

    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd == -1)
        rb_sys_fail(&quot;socket(2)&quot;);

    bufsize = sizeof(initbuf);
    buf = initbuf;

  retry:
    conf.ifc_len = bufsize;
    conf.ifc_req = (struct ifreq *)buf;

    /* fprintf(stderr, &quot;bufsize: %d\n&quot;, bufsize); */

    ret = ioctl(fd, SIOCGIFCONF, &amp;conf);
    if (ret == -1) {
        reason = &quot;SIOCGIFCONF&quot;;
        goto finish;
    }

    /* fprintf(stderr, &quot;conf.ifc_len: %d\n&quot;, conf.ifc_len); */

    if (bufsize - EXTRA_SPACE &lt; conf.ifc_len) {
        if (bufsize &lt; conf.ifc_len) {
            /* NetBSD returns required size for all interfaces. */
            bufsize = conf.ifc_len + EXTRA_SPACE;
        }
        else {
            bufsize = bufsize &lt;&lt; 1;
        }
        if (buf == initbuf)
            buf = NULL;
        buf = xrealloc(buf, bufsize);
        goto retry;
    }

    close(fd);
    fd = -1;

    list = rb_ary_new();
    req = conf.ifc_req;
    while ((char*)req &lt; (char*)conf.ifc_req + conf.ifc_len) {
        struct sockaddr *addr = &amp;req-&gt;ifr_addr;
        if (IS_IP_FAMILY(addr-&gt;sa_family)) {
            rb_ary_push(list, sockaddr_obj(addr, sockaddr_len(addr)));
        }
#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
# ifndef _SIZEOF_ADDR_IFREQ
#  define _SIZEOF_ADDR_IFREQ(r) \
          (sizeof(struct ifreq) + \
           (sizeof(struct sockaddr) &lt; (r).ifr_addr.sa_len ? \
            (r).ifr_addr.sa_len - sizeof(struct sockaddr) : \
            0))
# endif
        req = (struct ifreq *)((char*)req + _SIZEOF_ADDR_IFREQ(*req));
#else
        req = (struct ifreq *)((char*)req + sizeof(struct ifreq));
#endif
    }

  finish:

    save_errno = errno;
    if (buf != initbuf)
        xfree(buf);
    if (fd != -1)
        close(fd);
    errno = save_errno;

    if (reason)
        rb_syserr_fail(save_errno, reason);
    return list;

#undef EXTRA_SPACE
#elif defined(_WIN32)
    typedef struct ip_adapter_unicast_address_st {
        unsigned LONG_LONG dummy0;
        struct ip_adapter_unicast_address_st *Next;
        struct {
            struct sockaddr *lpSockaddr;
            int iSockaddrLength;
        } Address;
        int dummy1;
        int dummy2;
        int dummy3;
        long dummy4;
        long dummy5;
        long dummy6;
    } ip_adapter_unicast_address_t;
    typedef struct ip_adapter_anycast_address_st {
        unsigned LONG_LONG dummy0;
        struct ip_adapter_anycast_address_st *Next;
        struct {
            struct sockaddr *lpSockaddr;
            int iSockaddrLength;
        } Address;
    } ip_adapter_anycast_address_t;
    typedef struct ip_adapter_addresses_st {
        unsigned LONG_LONG dummy0;
        struct ip_adapter_addresses_st *Next;
        void *dummy1;
        ip_adapter_unicast_address_t *FirstUnicastAddress;
        ip_adapter_anycast_address_t *FirstAnycastAddress;
        void *dummy2;
        void *dummy3;
        void *dummy4;
        void *dummy5;
        void *dummy6;
        BYTE dummy7[8];
        DWORD dummy8;
        DWORD dummy9;
        DWORD dummy10;
        DWORD IfType;
        int OperStatus;
        DWORD dummy12;
        DWORD dummy13[16];
        void *dummy14;
    } ip_adapter_addresses_t;
    typedef ULONG (WINAPI *GetAdaptersAddresses_t)(ULONG, ULONG, PVOID, ip_adapter_addresses_t *, PULONG);
    HMODULE h;
    GetAdaptersAddresses_t pGetAdaptersAddresses;
    ULONG len;
    DWORD ret;
    ip_adapter_addresses_t *adapters;
    VALUE list;

    h = LoadLibrary(&quot;iphlpapi.dll&quot;);
    if (!h)
        rb_notimplement();
    pGetAdaptersAddresses = (GetAdaptersAddresses_t)GetProcAddress(h, &quot;GetAdaptersAddresses&quot;);
    if (!pGetAdaptersAddresses) {
        FreeLibrary(h);
        rb_notimplement();
    }

    ret = pGetAdaptersAddresses(AF_UNSPEC, 0, NULL, NULL, &amp;len);
    if (ret != ERROR_SUCCESS &amp;&amp; ret != ERROR_BUFFER_OVERFLOW) {
        errno = rb_w32_map_errno(ret);
        FreeLibrary(h);
        rb_sys_fail(&quot;GetAdaptersAddresses&quot;);
    }
    adapters = (ip_adapter_addresses_t *)ALLOCA_N(BYTE, len);
    ret = pGetAdaptersAddresses(AF_UNSPEC, 0, NULL, adapters, &amp;len);
    if (ret != ERROR_SUCCESS) {
        errno = rb_w32_map_errno(ret);
        FreeLibrary(h);
        rb_sys_fail(&quot;GetAdaptersAddresses&quot;);
    }

    list = rb_ary_new();
    for (; adapters; adapters = adapters-&gt;Next) {
        ip_adapter_unicast_address_t *uni;
        ip_adapter_anycast_address_t *any;
        if (adapters-&gt;OperStatus != 1)  /* 1 means IfOperStatusUp */
            continue;
        for (uni = adapters-&gt;FirstUnicastAddress; uni; uni = uni-&gt;Next) {
#ifndef INET6
            if (uni-&gt;Address.lpSockaddr-&gt;sa_family == AF_INET)
#else
            if (IS_IP_FAMILY(uni-&gt;Address.lpSockaddr-&gt;sa_family))
#endif
                rb_ary_push(list, sockaddr_obj(uni-&gt;Address.lpSockaddr, uni-&gt;Address.iSockaddrLength));
        }
        for (any = adapters-&gt;FirstAnycastAddress; any; any = any-&gt;Next) {
#ifndef INET6
            if (any-&gt;Address.lpSockaddr-&gt;sa_family == AF_INET)
#else
            if (IS_IP_FAMILY(any-&gt;Address.lpSockaddr-&gt;sa_family))
#endif
                rb_ary_push(list, sockaddr_obj(any-&gt;Address.lpSockaddr, any-&gt;Address.iSockaddrLength));
        }
    }

    FreeLibrary(h);
    return list;
#endif
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-new">
            
              <b>Socket.new(domain, socktype [, protocol]) => socket
</b>
            
            <a href="../classes/Socket.html#method-c-new" name="method-c-new" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Creates a new socket object.</p>

<p><em>domain</em> should be a communications domain such as: :INET, :INET6, :UNIX, etc.</p>

<p><em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</p>

<p><em>protocol</em> is optional and should be a protocol defined in the domain. If protocol is not given, 0 is used internally.</p>

<pre><code>Socket.new(:INET, :STREAM) # TCP socket
Socket.new(:INET, :DGRAM)  # UDP socket
Socket.new(:UNIX, :STREAM) # UNIX stream socket
Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-new_source')" id="l_method-c-new_source">show</a>
                
              </p>
              <div id="method-c-new_source" class="dyn-source">
                <pre>static VALUE
sock_initialize(int argc, VALUE *argv, VALUE sock)
{
    VALUE domain, type, protocol;
    int fd;
    int d, t;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;domain, &amp;type, &amp;protocol);
    if (NIL_P(protocol))
        protocol = INT2FIX(0);

    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    fd = rsock_socket(d, t, NUM2INT(protocol));
    if (fd &lt; 0) rb_sys_fail(&quot;socket(2)&quot;);

    return rsock_init_sock(sock, fd);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-pack_sockaddr_in">
            
              <b>Socket.sockaddr_in(port, host)      => sockaddr<br />Socket.pack_sockaddr_in(port, host) => sockaddr
</b>
            
            <a href="../classes/Socket.html#method-c-pack_sockaddr_in" name="method-c-pack_sockaddr_in" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Packs <em>port</em> and <em>host</em> as an AF_INET/AF_INET6 sockaddr string.</p>

<pre><code>Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
#=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;

Socket.sockaddr_in(80, &quot;::1&quot;)
#=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-pack_sockaddr_in_source')" id="l_method-c-pack_sockaddr_in_source">show</a>
                
              </p>
              <div id="method-c-pack_sockaddr_in_source" class="dyn-source">
                <pre>static VALUE
sock_s_pack_sockaddr_in(VALUE self, VALUE port, VALUE host)
{
    struct rb_addrinfo *res = rsock_addrinfo(host, port, AF_UNSPEC, 0, 0);
    VALUE addr = rb_str_new((char*)res-&gt;ai-&gt;ai_addr, res-&gt;ai-&gt;ai_addrlen);

    rb_freeaddrinfo(res);

    return addr;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-pack_sockaddr_un">
            
              <b>Socket.sockaddr_un(path)      => sockaddr<br />Socket.pack_sockaddr_un(path) => sockaddr
</b>
            
            <a href="../classes/Socket.html#method-c-pack_sockaddr_un" name="method-c-pack_sockaddr_un" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Packs <em>path</em> as an AF_UNIX sockaddr string.</p>

<pre><code>Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-pack_sockaddr_un_source')" id="l_method-c-pack_sockaddr_un_source">show</a>
                
              </p>
              <div id="method-c-pack_sockaddr_un_source" class="dyn-source">
                <pre>static VALUE
sock_s_pack_sockaddr_un(VALUE self, VALUE path)
{
    struct sockaddr_un sockaddr;
    VALUE addr;

    StringValue(path);
    INIT_SOCKADDR_UN(&amp;sockaddr, sizeof(struct sockaddr_un));
    if (sizeof(sockaddr.sun_path) &lt; (size_t)RSTRING_LEN(path)) {
        rb_raise(rb_eArgError, &quot;too long unix socket path (%&quot;PRIuSIZE&quot; bytes given but %&quot;PRIuSIZE&quot; bytes max)&quot;,
            (size_t)RSTRING_LEN(path), sizeof(sockaddr.sun_path));
    }
    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));
    addr = rb_str_new((char*)&amp;sockaddr, rsock_unix_sockaddr_len(path));

    return addr;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-pair">
            
              <b>Socket.pair(domain, type, protocol)       => [socket1, socket2]<br />Socket.socketpair(domain, type, protocol) => [socket1, socket2]
</b>
            
            <a href="../classes/Socket.html#method-c-pair" name="method-c-pair" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Creates a pair of sockets connected each other.</p>

<p><em>domain</em> should be a communications domain such as: :INET, :INET6, :UNIX, etc.</p>

<p><em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</p>

<p><em>protocol</em> should be a protocol defined in the domain, defaults to 0 for the domain.</p>

<pre><code>s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
s1.send &quot;a&quot;, 0
s1.send &quot;b&quot;, 0
s1.close
p s2.recv(10) #=&gt; &quot;ab&quot;
p s2.recv(10) #=&gt; &quot;&quot;
p s2.recv(10) #=&gt; &quot;&quot;

s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
s1.send &quot;a&quot;, 0
s1.send &quot;b&quot;, 0
p s2.recv(10) #=&gt; &quot;a&quot;
p s2.recv(10) #=&gt; &quot;b&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-pair_source')" id="l_method-c-pair_source">show</a>
                
              </p>
              <div id="method-c-pair_source" class="dyn-source">
                <pre>VALUE
rsock_sock_s_socketpair(int argc, VALUE *argv, VALUE klass)
{
    VALUE domain, type, protocol;
    int d, t, p, sp[2];
    int ret;
    VALUE s1, s2, r;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;domain, &amp;type, &amp;protocol);
    if (NIL_P(protocol))
        protocol = INT2FIX(0);

    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    p = NUM2INT(protocol);
    ret = rsock_socketpair(d, t, p, sp);
    if (ret &lt; 0) {
        rb_sys_fail(&quot;socketpair(2)&quot;);
    }

    s1 = rsock_init_sock(rb_obj_alloc(klass), sp[0]);
    s2 = rsock_init_sock(rb_obj_alloc(klass), sp[1]);
    r = rb_assoc_new(s1, s2);
    if (rb_block_given_p()) {
        return rb_ensure(pair_yield, r, io_close, s1);
    }
    return r;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-sockaddr_in">
            
              <b>Socket.sockaddr_in(port, host)      => sockaddr<br />Socket.pack_sockaddr_in(port, host) => sockaddr
</b>
            
            <a href="../classes/Socket.html#method-c-sockaddr_in" name="method-c-sockaddr_in" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Packs <em>port</em> and <em>host</em> as an AF_INET/AF_INET6 sockaddr string.</p>

<pre><code>Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
#=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;

Socket.sockaddr_in(80, &quot;::1&quot;)
#=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-sockaddr_in_source')" id="l_method-c-sockaddr_in_source">show</a>
                
              </p>
              <div id="method-c-sockaddr_in_source" class="dyn-source">
                <pre>static VALUE
sock_s_pack_sockaddr_in(VALUE self, VALUE port, VALUE host)
{
    struct rb_addrinfo *res = rsock_addrinfo(host, port, AF_UNSPEC, 0, 0);
    VALUE addr = rb_str_new((char*)res-&gt;ai-&gt;ai_addr, res-&gt;ai-&gt;ai_addrlen);

    rb_freeaddrinfo(res);

    return addr;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-sockaddr_un">
            
              <b>Socket.sockaddr_un(path)      => sockaddr<br />Socket.pack_sockaddr_un(path) => sockaddr
</b>
            
            <a href="../classes/Socket.html#method-c-sockaddr_un" name="method-c-sockaddr_un" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Packs <em>path</em> as an AF_UNIX sockaddr string.</p>

<pre><code>Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-sockaddr_un_source')" id="l_method-c-sockaddr_un_source">show</a>
                
              </p>
              <div id="method-c-sockaddr_un_source" class="dyn-source">
                <pre>static VALUE
sock_s_pack_sockaddr_un(VALUE self, VALUE path)
{
    struct sockaddr_un sockaddr;
    VALUE addr;

    StringValue(path);
    INIT_SOCKADDR_UN(&amp;sockaddr, sizeof(struct sockaddr_un));
    if (sizeof(sockaddr.sun_path) &lt; (size_t)RSTRING_LEN(path)) {
        rb_raise(rb_eArgError, &quot;too long unix socket path (%&quot;PRIuSIZE&quot; bytes given but %&quot;PRIuSIZE&quot; bytes max)&quot;,
            (size_t)RSTRING_LEN(path), sizeof(sockaddr.sun_path));
    }
    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));
    addr = rb_str_new((char*)&amp;sockaddr, rsock_unix_sockaddr_len(path));

    return addr;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-socketpair">
            
              <b>Socket.pair(domain, type, protocol)       => [socket1, socket2]<br />Socket.socketpair(domain, type, protocol) => [socket1, socket2]
</b>
            
            <a href="../classes/Socket.html#method-c-socketpair" name="method-c-socketpair" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Creates a pair of sockets connected each other.</p>

<p><em>domain</em> should be a communications domain such as: :INET, :INET6, :UNIX, etc.</p>

<p><em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</p>

<p><em>protocol</em> should be a protocol defined in the domain, defaults to 0 for the domain.</p>

<pre><code>s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
s1.send &quot;a&quot;, 0
s1.send &quot;b&quot;, 0
s1.close
p s2.recv(10) #=&gt; &quot;ab&quot;
p s2.recv(10) #=&gt; &quot;&quot;
p s2.recv(10) #=&gt; &quot;&quot;

s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
s1.send &quot;a&quot;, 0
s1.send &quot;b&quot;, 0
p s2.recv(10) #=&gt; &quot;a&quot;
p s2.recv(10) #=&gt; &quot;b&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-socketpair_source')" id="l_method-c-socketpair_source">show</a>
                
              </p>
              <div id="method-c-socketpair_source" class="dyn-source">
                <pre>VALUE
rsock_sock_s_socketpair(int argc, VALUE *argv, VALUE klass)
{
    VALUE domain, type, protocol;
    int d, t, p, sp[2];
    int ret;
    VALUE s1, s2, r;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;domain, &amp;type, &amp;protocol);
    if (NIL_P(protocol))
        protocol = INT2FIX(0);

    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    p = NUM2INT(protocol);
    ret = rsock_socketpair(d, t, p, sp);
    if (ret &lt; 0) {
        rb_sys_fail(&quot;socketpair(2)&quot;);
    }

    s1 = rsock_init_sock(rb_obj_alloc(klass), sp[0]);
    s2 = rsock_init_sock(rb_obj_alloc(klass), sp[1]);
    r = rb_assoc_new(s1, s2);
    if (rb_block_given_p()) {
        return rb_ensure(pair_yield, r, io_close, s1);
    }
    return r;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-tcp">
            
              <b>Socket.tcp(host, port, local_host=nil, local_port=nil, [opts]) {|socket| ... }<br />Socket.tcp(host, port, local_host=nil, local_port=nil, [opts])
</b>
            
            <a href="../classes/Socket.html#method-c-tcp" name="method-c-tcp" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates a new socket object connected to host:port using TCP/IP.</p>

<p>If local_host:local_port is given, the socket is bound to it.</p>

<p>The optional last argument <em>opts</em> is options represented by a hash. <em>opts</em> may have following options:</p>
<dl class="rdoc-list label-list"><dt>:connect_timeout
<dd>
<p>specify the timeout in seconds.</p>
</dd></dl>

<p>If a block is given, the block is called with the socket. The value of the block is returned. The socket is closed when this method returns.</p>

<p>If no block is given, the socket is returned.</p>

<pre><code>Socket.tcp(&quot;www.ruby-lang.org&quot;, 80) {|sock|
  sock.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;
  sock.close_write
  puts sock.read
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-tcp_source')" id="l_method-c-tcp_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L628" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-tcp_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 628</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">tcp</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">local_host</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">local_port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-value">connect_timeout:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">resolv_timeout:</span> <span class="ruby-keyword">nil</span>) <span class="ruby-comment"># :yield: socket</span>
  <span class="ruby-identifier">last_error</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">ret</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-identifier">local_addr_list</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_host</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">local_port</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">local_addr_list</span> = <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">getaddrinfo</span>(<span class="ruby-identifier">local_host</span>, <span class="ruby-identifier">local_port</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">:STREAM</span>, <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">:STREAM</span>, <span class="ruby-value">timeout:</span> <span class="ruby-identifier">resolv_timeout</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">ai</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_addr_list</span>
      <span class="ruby-identifier">local_addr</span> = <span class="ruby-identifier">local_addr_list</span>.<span class="ruby-identifier">find</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">local_ai</span><span class="ruby-operator">|</span> <span class="ruby-identifier">local_ai</span>.<span class="ruby-identifier">afamily</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">afamily</span> }
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">local_addr</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">local_addr</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">sock</span> = <span class="ruby-identifier">local_addr</span> <span class="ruby-operator">?</span>
        <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">connect_from</span>(<span class="ruby-identifier">local_addr</span>, <span class="ruby-value">timeout:</span> <span class="ruby-identifier">connect_timeout</span>) <span class="ruby-operator">:</span>
        <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-value">timeout:</span> <span class="ruby-identifier">connect_timeout</span>)
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">SystemCallError</span>
      <span class="ruby-identifier">last_error</span> = <span class="ruby-identifier">$!</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">ret</span> = <span class="ruby-identifier">sock</span>
    <span class="ruby-keyword">break</span>
  }
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ret</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">last_error</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-identifier">last_error</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">SocketError</span>, <span class="ruby-string">&quot;no appropriate local address&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">ret</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">ret</span>.<span class="ruby-identifier">close</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">ret</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-tcp_server_loop">
            
              <b>tcp_server_loop</b>(host=nil, port)
            
            <a href="../classes/Socket.html#method-c-tcp_server_loop" name="method-c-tcp_server_loop" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates a TCP/IP server on <em>port</em> and calls the block for each connection accepted. The block is called with a socket and a client_address as an <a href="Addrinfo.html"><code>Addrinfo</code></a> object.</p>

<p>If <em>host</em> is specified, it is used with <em>port</em> to determine the server addresses.</p>

<p>The socket is <strong>not</strong> closed when the block returns. So application should close it explicitly.</p>

<p>This method calls the block sequentially. It means that the next connection is not accepted until the block returns. So concurrent mechanism, thread for example, should be used to service multiple clients at a time.</p>

<p>Note that <a href="Addrinfo.html#method-c-getaddrinfo"><code>Addrinfo.getaddrinfo</code></a> is used to determine the server socket addresses. When <a href="Addrinfo.html#method-c-getaddrinfo"><code>Addrinfo.getaddrinfo</code></a> returns two or more addresses, IPv4 and IPv6 address for example, all of them are used. <a href="Socket.html#method-c-tcp_server_loop"><code>Socket.tcp_server_loop</code></a> succeeds if one socket can be used at least.</p>

<pre><code># Sequential echo server.
# It services only one client at a time.
Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  begin
    IO.copy_stream(sock, sock)
  ensure
    sock.close
  end
}

# Threaded echo server
# It services multiple clients at a time.
# Note that it may accept connections too much.
Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  Thread.new {
    begin
      IO.copy_stream(sock, sock)
    ensure
      sock.close
    end
  }
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-tcp_server_loop_source')" id="l_method-c-tcp_server_loop_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L861" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-tcp_server_loop_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 861</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">tcp_server_loop</span>(<span class="ruby-identifier">host</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-comment"># :yield: socket, client_addrinfo</span>
  <span class="ruby-identifier">tcp_server_sockets</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">sockets</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">accept_loop</span>(<span class="ruby-identifier">sockets</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
  }
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-tcp_server_sockets">
            
              <b>tcp_server_sockets</b>(host=nil, port)
            
            <a href="../classes/Socket.html#method-c-tcp_server_sockets" name="method-c-tcp_server_sockets" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates TCP/IP server sockets for <em>host</em> and <em>port</em>. <em>host</em> is optional.</p>

<p>If no block given, it returns an array of listening sockets.</p>

<p>If a block is given, the block is called with the sockets. The value of the block is returned. The socket is closed when this method returns.</p>

<p>If <em>port</em> is 0, actual port number is chosen dynamically. However all sockets in the result has same port number.</p>

<pre><code># tcp_server_sockets returns two sockets.
sockets = Socket.tcp_server_sockets(1296)
p sockets #=&gt; [#&lt;Socket:fd 3&gt;, #&lt;Socket:fd 4&gt;]

# The sockets contains IPv6 and IPv4 sockets.
sockets.each {|s| p s.local_address }
#=&gt; #&lt;Addrinfo: [::]:1296 TCP&gt;
#   #&lt;Addrinfo: 0.0.0.0:1296 TCP&gt;

# IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
sockets = Socket.tcp_server_sockets(0)
sockets.each {|s| p s.local_address }
#=&gt; #&lt;Addrinfo: [::]:53114 TCP&gt;
#   #&lt;Addrinfo: 0.0.0.0:53114 TCP&gt;

# The block is called with the sockets.
Socket.tcp_server_sockets(0) {|sockets|
  p sockets #=&gt; [#&lt;Socket:fd 3&gt;, #&lt;Socket:fd 4&gt;]
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-tcp_server_sockets_source')" id="l_method-c-tcp_server_sockets_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L761" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-tcp_server_sockets_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 761</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">tcp_server_sockets</span>(<span class="ruby-identifier">host</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">sockets</span> = <span class="ruby-identifier">tcp_server_sockets_port0</span>(<span class="ruby-identifier">host</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">last_error</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">sockets</span> = []
    <span class="ruby-keyword">begin</span>
      <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">:STREAM</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">AI_PASSIVE</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">ai</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-identifier">s</span> = <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">listen</span>
        <span class="ruby-keyword">rescue</span> <span class="ruby-constant">SystemCallError</span>
          <span class="ruby-identifier">last_error</span> = <span class="ruby-identifier">$!</span>
          <span class="ruby-keyword">next</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">sockets</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">s</span>
      }
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-identifier">last_error</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span>
      <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:close</span>)
      <span class="ruby-identifier">raise</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">sockets</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:close</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">sockets</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-udp_server_loop">
            
              <b>Socket.udp_server_loop(port) {|msg, msg_src| ... }<br />Socket.udp_server_loop(host, port) {|msg, msg_src| ... }
</b>
            
            <a href="../classes/Socket.html#method-c-udp_server_loop" name="method-c-udp_server_loop" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates a UDP/IP server on <em>port</em> and calls the block for each message arrived. The block is called with the message and its source information.</p>

<p>This method allocates sockets internally using <em>port</em>. If <em>host</em> is specified, it is used conjunction with <em>port</em> to determine the server addresses.</p>

<p>The <em>msg</em> is a string.</p>

<p>The <em>msg_src</em> is a <a href="Socket/UDPSource.html"><code>Socket::UDPSource</code></a> object. It is used for reply.</p>

<pre><code># UDP/IP echo server.
Socket.udp_server_loop(9261) {|msg, msg_src|
  msg_src.reply msg
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-udp_server_loop_source')" id="l_method-c-udp_server_loop_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L1031" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-udp_server_loop_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1031</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">udp_server_loop</span>(<span class="ruby-identifier">host</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-comment"># :yield: message, message_source</span>
  <span class="ruby-identifier">udp_server_sockets</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">sockets</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">udp_server_loop_on</span>(<span class="ruby-identifier">sockets</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
  }
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-udp_server_loop_on">
            
              <b>Socket.udp_server_loop_on(sockets) {|msg, msg_src| ... }
</b>
            
            <a href="../classes/Socket.html#method-c-udp_server_loop_on" name="method-c-udp_server_loop_on" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Run UDP/IP server loop on the given sockets.</p>

<p>The return value of <a href="Socket.html#method-c-udp_server_sockets"><code>Socket.udp_server_sockets</code></a> is appropriate for the argument.</p>

<p>It calls the block for each message received.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-udp_server_loop_on_source')" id="l_method-c-udp_server_loop_on_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L1004" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-udp_server_loop_on_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1004</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">udp_server_loop_on</span>(<span class="ruby-identifier">sockets</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-comment"># :yield: msg, msg_src</span>
  <span class="ruby-identifier">loop</span> {
    <span class="ruby-identifier">readable</span>, <span class="ruby-identifier">_</span>, <span class="ruby-identifier">_</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>(<span class="ruby-identifier">sockets</span>)
    <span class="ruby-identifier">udp_server_recv</span>(<span class="ruby-identifier">readable</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
  }
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-udp_server_recv">
            
              <b>Socket.udp_server_recv(sockets) {|msg, msg_src| ... }
</b>
            
            <a href="../classes/Socket.html#method-c-udp_server_recv" name="method-c-udp_server_recv" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Receive UDP/IP packets from the given <em>sockets</em>. For each packet received, the block is called.</p>

<p>The block receives <em>msg</em> and <em>msg_src</em>. <em>msg</em> is a string which is the payload of the received packet. <em>msg_src</em> is a <a href="Socket/UDPSource.html"><code>Socket::UDPSource</code></a> object which is used for reply.</p>

<p><a href="Socket.html#method-c-udp_server_loop"><code>Socket.udp_server_loop</code></a> can be implemented using this method as follows.</p>

<pre><code>udp_server_sockets(host, port) {|sockets|
  loop {
    readable, _, _ = IO.select(sockets)
    udp_server_recv(readable) {|msg, msg_src| ... }
  }
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-udp_server_recv_source')" id="l_method-c-udp_server_recv_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L977" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-udp_server_recv_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 977</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">udp_server_recv</span>(<span class="ruby-identifier">sockets</span>)
  <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">msg</span>, <span class="ruby-identifier">sender_addrinfo</span>, <span class="ruby-identifier">_</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">controls</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">recvmsg_nonblock</span>(<span class="ruby-value">exception:</span> <span class="ruby-keyword">false</span>)
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">msg</span> <span class="ruby-operator">==</span> <span class="ruby-value">:wait_readable</span>
    <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">local_address</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ipv6?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">pktinfo</span> = <span class="ruby-identifier">controls</span>.<span class="ruby-identifier">find</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">cmsg_is?</span>(<span class="ruby-value">:IPV6</span>, <span class="ruby-value">:PKTINFO</span>) }
      <span class="ruby-identifier">ai</span> = <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">udp</span>(<span class="ruby-identifier">pktinfo</span>.<span class="ruby-identifier">ipv6_pktinfo_addr</span>.<span class="ruby-identifier">ip_address</span>, <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ip_port</span>)
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">msg</span>, <span class="ruby-constant">UDPSource</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">sender_addrinfo</span>, <span class="ruby-identifier">ai</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">reply_msg</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">sendmsg</span> <span class="ruby-identifier">reply_msg</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">sender_addrinfo</span>, <span class="ruby-identifier">pktinfo</span>
      }
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">msg</span>, <span class="ruby-constant">UDPSource</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">sender_addrinfo</span>, <span class="ruby-identifier">ai</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">reply_msg</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">send</span> <span class="ruby-identifier">reply_msg</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">sender_addrinfo</span>
      }
    <span class="ruby-keyword">end</span>
  }
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-udp_server_sockets">
            
              <b>Socket.udp_server_sockets([host, ] port)
</b>
            
            <a href="../classes/Socket.html#method-c-udp_server_sockets" name="method-c-udp_server_sockets" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Creates UDP/IP sockets for a UDP server.</p>

<p>If no block given, it returns an array of sockets.</p>

<p>If a block is given, the block is called with the sockets. The value of the block is returned. The sockets are closed when this method returns.</p>

<p>If <em>port</em> is zero, some port is chosen. But the chosen port is used for the all sockets.</p>

<pre><code># UDP/IP echo server
Socket.udp_server_sockets(0) {|sockets|
  p sockets.first.local_address.ip_port     #=&gt; 32963
  Socket.udp_server_loop_on(sockets) {|msg, msg_src|
    msg_src.reply msg
  }
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-udp_server_sockets_source')" id="l_method-c-udp_server_sockets_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L889" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-udp_server_sockets_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 889</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">udp_server_sockets</span>(<span class="ruby-identifier">host</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span>)
  <span class="ruby-identifier">last_error</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sockets</span> = []

  <span class="ruby-identifier">ipv6_recvpktinfo</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span> <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">AncillaryData</span>
    <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span> <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">IPV6_RECVPKTINFO</span> <span class="ruby-comment"># RFC 3542</span>
      <span class="ruby-identifier">ipv6_recvpktinfo</span> = <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">IPV6_RECVPKTINFO</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">defined?</span> <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">IPV6_PKTINFO</span> <span class="ruby-comment"># RFC 2292</span>
      <span class="ruby-identifier">ipv6_recvpktinfo</span> = <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">IPV6_PKTINFO</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">local_addrs</span> = <span class="ruby-constant">Socket</span>.<span class="ruby-identifier">ip_address_list</span>

  <span class="ruby-identifier">ip_list</span> = []
  <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">:DGRAM</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">AI_PASSIVE</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">ai</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ipv4?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ip_address</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;0.0.0.0&quot;</span>
      <span class="ruby-identifier">local_addrs</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">ipv4?</span>
        <span class="ruby-identifier">ip_list</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_sockaddr</span>, <span class="ruby-value">:INET</span>, <span class="ruby-value">:DGRAM</span>, <span class="ruby-value">0</span>);
      }
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ipv6?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ip_address</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;::&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">ipv6_recvpktinfo</span>
      <span class="ruby-identifier">local_addrs</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">ipv6?</span>
        <span class="ruby-identifier">ip_list</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_sockaddr</span>, <span class="ruby-value">:INET6</span>, <span class="ruby-value">:DGRAM</span>, <span class="ruby-value">0</span>);
      }
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">ip_list</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ai</span>
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-identifier">ip_list</span>.<span class="ruby-identifier">uniq!</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:to_sockaddr</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">sockets</span> = <span class="ruby-identifier">ip_sockets_port0</span>(<span class="ruby-identifier">ip_list</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">ip_list</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ip</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">ai</span> = <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">udp</span>(<span class="ruby-identifier">ip</span>.<span class="ruby-identifier">ip_address</span>, <span class="ruby-identifier">port</span>)
      <span class="ruby-keyword">begin</span>
        <span class="ruby-identifier">s</span> = <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">bind</span>
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">SystemCallError</span>
        <span class="ruby-identifier">last_error</span> = <span class="ruby-identifier">$!</span>
        <span class="ruby-keyword">next</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">sockets</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">s</span>
    }
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-identifier">last_error</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">ai</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">local_address</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ipv6_recvpktinfo</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ipv6?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">ai</span>.<span class="ruby-identifier">ip_address</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;::&quot;</span>
      <span class="ruby-identifier">s</span>.<span class="ruby-identifier">setsockopt</span>(<span class="ruby-value">:IPV6</span>, <span class="ruby-identifier">ipv6_recvpktinfo</span>, <span class="ruby-value">1</span>)
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">sockets</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">sockets</span>.<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:close</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">sockets</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">sockets</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-unix">
            
              <b>unix</b>(path)
            
            <a href="../classes/Socket.html#method-c-unix" name="method-c-unix" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates a new socket connected to path using UNIX socket socket.</p>

<p>If a block is given, the block is called with the socket. The value of the block is returned. The socket is closed when this method returns.</p>

<p>If no block is given, the socket is returned.</p>

<pre><code># talk to /tmp/sock socket.
Socket.unix(&quot;/tmp/sock&quot;) {|sock|
  t = Thread.new { IO.copy_stream(sock, STDOUT) }
  IO.copy_stream(STDIN, sock)
  t.join
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-unix_source')" id="l_method-c-unix_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L1081" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-unix_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1081</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">unix</span>(<span class="ruby-identifier">path</span>) <span class="ruby-comment"># :yield: socket</span>
  <span class="ruby-identifier">addr</span> = <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">unix</span>(<span class="ruby-identifier">path</span>)
  <span class="ruby-identifier">sock</span> = <span class="ruby-identifier">addr</span>.<span class="ruby-identifier">connect</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">sock</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">sock</span>.<span class="ruby-identifier">close</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">sock</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-unix_server_loop">
            
              <b>unix_server_loop</b>(path)
            
            <a href="../classes/Socket.html#method-c-unix_server_loop" name="method-c-unix_server_loop" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates a UNIX socket server on <em>path</em>. It calls the block for each socket accepted.</p>

<p>If <em>host</em> is specified, it is used with <em>port</em> to determine the server ports.</p>

<p>The socket is <strong>not</strong> closed when the block returns. So application should close it.</p>

<p>This method deletes the socket file pointed by <em>path</em> at first if the file is a socket file and it is owned by the user of the application. This is safe only if the directory of <em>path</em> is not changed by a malicious user. So don’t use /tmp/malicious-users-directory/socket. Note that /tmp/socket and /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.</p>

<pre><code># Sequential echo server.
# It services only one client at a time.
Socket.unix_server_loop(&quot;/tmp/sock&quot;) {|sock, client_addrinfo|
  begin
    IO.copy_stream(sock, sock)
  ensure
    sock.close
  end
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-unix_server_loop_source')" id="l_method-c-unix_server_loop_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L1168" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-unix_server_loop_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1168</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">unix_server_loop</span>(<span class="ruby-identifier">path</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-comment"># :yield: socket, client_addrinfo</span>
  <span class="ruby-identifier">unix_server_socket</span>(<span class="ruby-identifier">path</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">serv</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">accept_loop</span>(<span class="ruby-identifier">serv</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
  }
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-unix_server_socket">
            
              <b>unix_server_socket</b>(path)
            
            <a href="../classes/Socket.html#method-c-unix_server_socket" name="method-c-unix_server_socket" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>creates a UNIX server socket on <em>path</em></p>

<p>If no block given, it returns a listening socket.</p>

<p>If a block is given, it is called with the socket and the block value is returned. When the block exits, the socket is closed and the socket file is removed.</p>

<pre><code>socket = Socket.unix_server_socket(&quot;/tmp/s&quot;)
p socket                  #=&gt; #&lt;Socket:fd 3&gt;
p socket.local_address    #=&gt; #&lt;Addrinfo: /tmp/s SOCK_STREAM&gt;

Socket.unix_server_socket(&quot;/tmp/sock&quot;) {|s|
  p s                     #=&gt; #&lt;Socket:fd 3&gt;
  p s.local_address       #=&gt; # #&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;
}
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-unix_server_socket_source')" id="l_method-c-unix_server_socket_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L1111" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-c-unix_server_socket_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1111</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">unix_server_socket</span>(<span class="ruby-identifier">path</span>)
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">unix_socket_abstract_name?</span>(<span class="ruby-identifier">path</span>)
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">st</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">lstat</span>(<span class="ruby-identifier">path</span>)
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ENOENT</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">st</span>&amp;.<span class="ruby-identifier">socket?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">st</span>.<span class="ruby-identifier">owned?</span>
      <span class="ruby-constant">File</span>.<span class="ruby-identifier">unlink</span> <span class="ruby-identifier">path</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">Addrinfo</span>.<span class="ruby-identifier">unix</span>(<span class="ruby-identifier">path</span>).<span class="ruby-identifier">listen</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">yield</span> <span class="ruby-identifier">s</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">s</span>.<span class="ruby-identifier">close</span>
      <span class="ruby-keyword">unless</span> <span class="ruby-identifier">unix_socket_abstract_name?</span>(<span class="ruby-identifier">path</span>)
        <span class="ruby-constant">File</span>.<span class="ruby-identifier">unlink</span> <span class="ruby-identifier">path</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-unpack_sockaddr_in">
            
              <b>Socket.unpack_sockaddr_in(sockaddr) => [port, ip_address]
</b>
            
            <a href="../classes/Socket.html#method-c-unpack_sockaddr_in" name="method-c-unpack_sockaddr_in" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Unpacks <em>sockaddr</em> into port and ip_address.</p>

<p><em>sockaddr</em> should be a string or an addrinfo for AF_INET/AF_INET6.</p>

<pre><code>sockaddr = Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
p sockaddr #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
p Socket.unpack_sockaddr_in(sockaddr) #=&gt; [80, &quot;127.0.0.1&quot;]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-unpack_sockaddr_in_source')" id="l_method-c-unpack_sockaddr_in_source">show</a>
                
              </p>
              <div id="method-c-unpack_sockaddr_in_source" class="dyn-source">
                <pre>static VALUE
sock_s_unpack_sockaddr_in(VALUE self, VALUE addr)
{
    struct sockaddr_in * sockaddr;
    VALUE host;

    sockaddr = (struct sockaddr_in*)SockAddrStringValuePtr(addr);
    if (RSTRING_LEN(addr) &lt;
        (char*)&amp;((struct sockaddr *)sockaddr)-&gt;sa_family +
        sizeof(((struct sockaddr *)sockaddr)-&gt;sa_family) -
        (char*)sockaddr)
        rb_raise(rb_eArgError, &quot;too short sockaddr&quot;);
    if (((struct sockaddr *)sockaddr)-&gt;sa_family != AF_INET
#ifdef INET6
        &amp;&amp; ((struct sockaddr *)sockaddr)-&gt;sa_family != AF_INET6
#endif
        ) {
#ifdef INET6
        rb_raise(rb_eArgError, &quot;not an AF_INET/AF_INET6 sockaddr&quot;);
#else
        rb_raise(rb_eArgError, &quot;not an AF_INET sockaddr&quot;);
#endif
    }
    host = rsock_make_ipaddr((struct sockaddr*)sockaddr, RSTRING_SOCKLEN(addr));
    return rb_assoc_new(INT2NUM(ntohs(sockaddr-&gt;sin_port)), host);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-c-unpack_sockaddr_un">
            
              <b>Socket.unpack_sockaddr_un(sockaddr) => path
</b>
            
            <a href="../classes/Socket.html#method-c-unpack_sockaddr_un" name="method-c-unpack_sockaddr_un" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Unpacks <em>sockaddr</em> into path.</p>

<p><em>sockaddr</em> should be a string or an addrinfo for AF_UNIX.</p>

<pre><code>sockaddr = Socket.sockaddr_un(&quot;/tmp/sock&quot;)
p Socket.unpack_sockaddr_un(sockaddr) #=&gt; &quot;/tmp/sock&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-c-unpack_sockaddr_un_source')" id="l_method-c-unpack_sockaddr_un_source">show</a>
                
              </p>
              <div id="method-c-unpack_sockaddr_un_source" class="dyn-source">
                <pre>static VALUE
sock_s_unpack_sockaddr_un(VALUE self, VALUE addr)
{
    struct sockaddr_un * sockaddr;
    VALUE path;

    sockaddr = (struct sockaddr_un*)SockAddrStringValuePtr(addr);
    if (RSTRING_LEN(addr) &lt;
        (char*)&amp;((struct sockaddr *)sockaddr)-&gt;sa_family +
        sizeof(((struct sockaddr *)sockaddr)-&gt;sa_family) -
        (char*)sockaddr)
        rb_raise(rb_eArgError, &quot;too short sockaddr&quot;);
    if (((struct sockaddr *)sockaddr)-&gt;sa_family != AF_UNIX) {
        rb_raise(rb_eArgError, &quot;not an AF_UNIX sockaddr&quot;);
    }
    if (sizeof(struct sockaddr_un) &lt; (size_t)RSTRING_LEN(addr)) {
        rb_raise(rb_eTypeError, &quot;too long sockaddr_un - %ld longer than %d&quot;,
                 RSTRING_LEN(addr), (int)sizeof(struct sockaddr_un));
    }
    path = rsock_unixpath_str(sockaddr, RSTRING_SOCKLEN(addr));
    return path;
}</pre>
              </div>
            </div>
            
          </div>
        
      
    
      <h2 class="sectiontitle">Instance Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-i-accept">
            
              <b>socket.accept => [client_socket, client_addrinfo]
</b>
            
            <a href="../classes/Socket.html#method-i-accept" name="method-i-accept" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Accepts a next connection. Returns a new <a href="Socket.html"><code>Socket</code></a> object and <a href="Addrinfo.html"><code>Addrinfo</code></a> object.</p>

<pre><code>serv = Socket.new(:INET, :STREAM, 0)
serv.listen(5)
c = Socket.new(:INET, :STREAM, 0)
c.connect(serv.connect_address)
p serv.accept #=&gt; [#&lt;Socket:fd 6&gt;, #&lt;Addrinfo: 127.0.0.1:48555 TCP&gt;]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-accept_source')" id="l_method-i-accept_source">show</a>
                
              </p>
              <div id="method-i-accept_source" class="dyn-source">
                <pre>static VALUE
sock_accept(VALUE server)
{
    union_sockaddr buffer;
    socklen_t length = (socklen_t)sizeof(buffer);

    VALUE peer = rsock_s_accept(rb_cSocket, server, &amp;buffer.addr, &amp;length);

    return rb_assoc_new(peer, rsock_io_socket_addrinfo(peer, &amp;buffer.addr, length));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-accept_nonblock">
            
              <b>socket.accept_nonblock([options]) => [client_socket, client_addrinfo]
</b>
            
            <a href="../classes/Socket.html#method-i-accept_nonblock" name="method-i-accept_nonblock" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an array containing the accepted socket for the incoming connection, <em>client_socket</em>, and an <a href="Addrinfo.html"><code>Addrinfo</code></a>, <em>client_addrinfo</em>.</p>

<h3 id="method-i-accept_nonblock-label-Example">Example</h3>

<pre><code># In one script, start this first
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new(AF_INET, SOCK_STREAM, 0)
sockaddr = Socket.sockaddr_in(2200, &#39;localhost&#39;)
socket.bind(sockaddr)
socket.listen(5)
begin # emulate blocking accept
  client_socket, client_addrinfo = socket.accept_nonblock
rescue IO::WaitReadable, Errno::EINTR
  IO.select([socket])
  retry
end
puts &quot;The client said, &#39;#{client_socket.readline.chomp}&#39;&quot;
client_socket.puts &quot;Hello from script one!&quot;
socket.close

# In another script, start this second
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new(AF_INET, SOCK_STREAM, 0)
sockaddr = Socket.sockaddr_in(2200, &#39;localhost&#39;)
socket.connect(sockaddr)
socket.puts &quot;Hello from script 2.&quot;
puts &quot;The server said, &#39;#{socket.readline.chomp}&#39;&quot;
socket.close
</code></pre>

<p>Refer to <a href="Socket.html#method-i-accept"><code>Socket#accept</code></a> for the exceptions that may be thrown if the call to <em>accept_nonblock</em> fails.</p>

<p><a href="Socket.html#method-i-accept_nonblock"><code>Socket#accept_nonblock</code></a> may raise any error corresponding to accept(2) failure, including Errno::EWOULDBLOCK.</p>

<p>If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or Errno::EPROTO, it is extended by <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a>. So <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a> can be used to rescue the exceptions for retrying accept_nonblock.</p>

<p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="Socket.html#method-i-accept_nonblock"><code>accept_nonblock</code></a> should not raise an <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p>

<h3 id="method-i-accept_nonblock-label-See">See</h3>
<ul><li>
<p><a href="Socket.html#method-i-accept"><code>Socket#accept</code></a></p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-accept_nonblock_source')" id="l_method-i-accept_nonblock_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L598" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-i-accept_nonblock_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 598</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_nonblock</span>(<span class="ruby-value">exception:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">__accept_nonblock</span>(<span class="ruby-identifier">exception</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-bind">
            
              <b>socket.bind(local_sockaddr) => 0
</b>
            
            <a href="../classes/Socket.html#method-i-bind" name="method-i-bind" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Binds to the given local address.</p>

<h3 id="method-i-bind-label-Parameter">Parameter</h3>
<ul><li>
<p><code>local_sockaddr</code> - the <code>struct</code> sockaddr contained in a string or an <a href="Addrinfo.html"><code>Addrinfo</code></a> object</p>
</li></ul>

<h3 id="method-i-bind-label-Example">Example</h3>

<pre><code>require &#39;socket&#39;

# use Addrinfo
socket = Socket.new(:INET, :STREAM, 0)
socket.bind(Addrinfo.tcp(&quot;127.0.0.1&quot;, 2222))
p socket.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:2222 TCP&gt;

# use struct sockaddr
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.bind( sockaddr )
</code></pre>

<h3 id="method-i-bind-label-Unix-based+Exceptions">Unix-based Exceptions</h3>

<p>On unix-based based systems the following system exceptions may be raised if the call to <em>bind</em> fails:</p>
<ul><li>
<p>Errno::EACCES - the specified <em>sockaddr</em> is protected and the current user does not have permission to bind to it</p>
</li><li>
<p>Errno::EADDRINUSE - the specified <em>sockaddr</em> is already in use</p>
</li><li>
<p>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available from the local machine</p>
</li><li>
<p>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid address for the family of the calling <code>socket</code></p>
</li><li>
<p>Errno::EBADF - the <em>sockaddr</em> specified is not a valid file descriptor</p>
</li><li>
<p>Errno::EFAULT - the <em>sockaddr</em> argument cannot be accessed</p>
</li><li>
<p>Errno::EINVAL - the <code>socket</code> is already bound to an address, and the protocol does not support binding to the new <em>sockaddr</em> or the <code>socket</code> has been shut down.</p>
</li><li>
<p>Errno::EINVAL - the address length is not a valid length for the address family</p>
</li><li>
<p>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded PATH_MAX</p>
</li><li>
<p>Errno::ENOBUFS - no buffer space is available</p>
</li><li>
<p>Errno::ENOSR - there were insufficient STREAMS resources available to complete the operation</p>
</li><li>
<p>Errno::ENOTSOCK - the <code>socket</code> does not refer to a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the socket type of the <code>socket</code> does not support binding to an address</p>
</li></ul>

<p>On unix-based based systems if the address family of the calling <code>socket</code> is Socket::AF_UNIX the follow exceptions may be raised if the call to <em>bind</em> fails:</p>
<ul><li>
<p>Errno::EACCES - search permission is denied for a component of the prefix path or write access to the <code>socket</code> is denied</p>
</li><li>
<p>Errno::EDESTADDRREQ - the <em>sockaddr</em> argument is a null pointer</p>
</li><li>
<p>Errno::EISDIR - same as Errno::EDESTADDRREQ</p>
</li><li>
<p>Errno::EIO - an i/o error occurred</p>
</li><li>
<p>Errno::ELOOP - too many symbolic links were encountered in translating the pathname in <em>sockaddr</em></p>
</li><li>
<p>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX characters, or an entire pathname exceeded PATH_MAX characters</p>
</li><li>
<p>Errno::ENOENT - a component of the pathname does not name an existing file or the pathname is an empty string</p>
</li><li>
<p>Errno::ENOTDIR - a component of the path prefix of the pathname in <em>sockaddr</em> is not a directory</p>
</li><li>
<p>Errno::EROFS - the name would reside on a read only filesystem</p>
</li></ul>

<h3 id="method-i-bind-label-Windows+Exceptions">Windows Exceptions</h3>

<p>On Windows systems the following system exceptions may be raised if the call to <em>bind</em> fails:</p>
<ul><li>
<p>Errno::ENETDOWN– the network is down</p>
</li><li>
<p>Errno::EACCES - the attempt to connect the datagram socket to the broadcast address failed</p>
</li><li>
<p>Errno::EADDRINUSE - the socket’s local address is already in use</p>
</li><li>
<p>Errno::EADDRNOTAVAIL - the specified address is not a valid address for this computer</p>
</li><li>
<p>Errno::EFAULT - the socket’s internal address or address length parameter is too small or is not a valid part of the user space addressed</p>
</li><li>
<p>Errno::EINVAL - the <code>socket</code> is already bound to an address</p>
</li><li>
<p>Errno::ENOBUFS - no buffer space is available</p>
</li><li>
<p>Errno::ENOTSOCK - the <code>socket</code> argument does not refer to a socket</p>
</li></ul>

<h3 id="method-i-bind-label-See">See</h3>
<ul><li>
<p>bind manual pages on unix-based systems</p>
</li><li>
<p>bind function in Microsoft’s Winsock functions reference</p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-bind_source')" id="l_method-i-bind_source">show</a>
                
              </p>
              <div id="method-i-bind_source" class="dyn-source">
                <pre>static VALUE
sock_bind(VALUE sock, VALUE addr)
{
    VALUE rai;
    rb_io_t *fptr;

    SockAddrStringValueWithAddrinfo(addr, rai);
    GetOpenFile(sock, fptr);
    if (bind(fptr-&gt;fd, (struct sockaddr*)RSTRING_PTR(addr), RSTRING_SOCKLEN(addr)) &lt; 0)
        rsock_sys_fail_raddrinfo_or_sockaddr(&quot;bind(2)&quot;, addr, rai);

    return INT2FIX(0);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-connect">
            
              <b>socket.connect(remote_sockaddr) => 0
</b>
            
            <a href="../classes/Socket.html#method-i-connect" name="method-i-connect" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Requests a connection to be made on the given <code>remote_sockaddr</code>. Returns 0 if successful, otherwise an exception is raised.</p>

<h3 id="method-i-connect-label-Parameter">Parameter</h3>
<ul><li>
<p><code>remote_sockaddr</code> - the <code>struct</code> sockaddr contained in a string or <a href="Addrinfo.html"><code>Addrinfo</code></a> object</p>
</li></ul>

<h3 id="method-i-connect-label-Example-3A">Example:</h3>

<pre><code># Pull down Google&#39;s web page
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 80, &#39;www.google.com&#39; )
socket.connect( sockaddr )
socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
results = socket.read
</code></pre>

<h3 id="method-i-connect-label-Unix-based+Exceptions">Unix-based Exceptions</h3>

<p>On unix-based systems the following system exceptions may be raised if the call to <em>connect</em> fails:</p>
<ul><li>
<p>Errno::EACCES - search permission is denied for a component of the prefix path or write access to the <code>socket</code> is denied</p>
</li><li>
<p>Errno::EADDRINUSE - the <em>sockaddr</em> is already in use</p>
</li><li>
<p>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available from the local machine</p>
</li><li>
<p>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid address for the address family of the specified <code>socket</code></p>
</li><li>
<p>Errno::EALREADY - a connection is already in progress for the specified socket</p>
</li><li>
<p>Errno::EBADF - the <code>socket</code> is not a valid file descriptor</p>
</li><li>
<p>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for connections refused the connection request</p>
</li><li>
<p>Errno::ECONNRESET - the remote host reset the connection request</p>
</li><li>
<p>Errno::EFAULT - the <em>sockaddr</em> cannot be accessed</p>
</li><li>
<p>Errno::EHOSTUNREACH - the destination host cannot be reached (probably because the host is down or a remote router cannot reach it)</p>
</li><li>
<p>Errno::EINPROGRESS - the O_NONBLOCK is set for the <code>socket</code> and the connection cannot be immediately established; the connection will be established asynchronously</p>
</li><li>
<p>Errno::EINTR - the attempt to establish the connection was interrupted by delivery of a signal that was caught; the connection will be established asynchronously</p>
</li><li>
<p>Errno::EISCONN - the specified <code>socket</code> is already connected</p>
</li><li>
<p>Errno::EINVAL - the address length used for the <em>sockaddr</em> is not a valid length for the address family or there is an invalid family in <em>sockaddr</em></p>
</li><li>
<p>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded PATH_MAX</p>
</li><li>
<p>Errno::ENETDOWN - the local interface used to reach the destination is down</p>
</li><li>
<p>Errno::ENETUNREACH - no route to the network is present</p>
</li><li>
<p>Errno::ENOBUFS - no buffer space is available</p>
</li><li>
<p>Errno::ENOSR - there were insufficient STREAMS resources available to complete the operation</p>
</li><li>
<p>Errno::ENOTSOCK - the <code>socket</code> argument does not refer to a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the calling <code>socket</code> is listening and cannot be connected</p>
</li><li>
<p>Errno::EPROTOTYPE - the <em>sockaddr</em> has a different type than the socket bound to the specified peer address</p>
</li><li>
<p>Errno::ETIMEDOUT - the attempt to connect timed out before a connection was made.</p>
</li></ul>

<p>On unix-based systems if the address family of the calling <code>socket</code> is AF_UNIX the follow exceptions may be raised if the call to <em>connect</em> fails:</p>
<ul><li>
<p>Errno::EIO - an i/o error occurred while reading from or writing to the file system</p>
</li><li>
<p>Errno::ELOOP - too many symbolic links were encountered in translating the pathname in <em>sockaddr</em></p>
</li><li>
<p>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX characters, or an entire pathname exceeded PATH_MAX characters</p>
</li><li>
<p>Errno::ENOENT - a component of the pathname does not name an existing file or the pathname is an empty string</p>
</li><li>
<p>Errno::ENOTDIR - a component of the path prefix of the pathname in <em>sockaddr</em> is not a directory</p>
</li></ul>

<h3 id="method-i-connect-label-Windows+Exceptions">Windows Exceptions</h3>

<p>On Windows systems the following system exceptions may be raised if the call to <em>connect</em> fails:</p>
<ul><li>
<p>Errno::ENETDOWN - the network is down</p>
</li><li>
<p>Errno::EADDRINUSE - the socket’s local address is already in use</p>
</li><li>
<p>Errno::EINTR - the socket was cancelled</p>
</li><li>
<p>Errno::EINPROGRESS - a blocking socket is in progress or the service provider is still processing a callback function. Or a nonblocking connect call is in progress on the <code>socket</code>.</p>
</li><li>
<p>Errno::EALREADY - see Errno::EINVAL</p>
</li><li>
<p>Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as ADDR_ANY TODO check ADDRANY TO INADDR_ANY</p>
</li><li>
<p>Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with with this <code>socket</code></p>
</li><li>
<p>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for connections refused the connection request</p>
</li><li>
<p>Errno::EFAULT - the socket’s internal address or address length parameter is too small or is not a valid part of the user space address</p>
</li><li>
<p>Errno::EINVAL - the <code>socket</code> is a listening socket</p>
</li><li>
<p>Errno::EISCONN - the <code>socket</code> is already connected</p>
</li><li>
<p>Errno::ENETUNREACH - the network cannot be reached from this host at this time</p>
</li><li>
<p>Errno::EHOSTUNREACH - no route to the network is present</p>
</li><li>
<p>Errno::ENOBUFS - no buffer space is available</p>
</li><li>
<p>Errno::ENOTSOCK - the <code>socket</code> argument does not refer to a socket</p>
</li><li>
<p>Errno::ETIMEDOUT - the attempt to connect timed out before a connection was made.</p>
</li><li>
<p>Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection cannot be completed immediately</p>
</li><li>
<p>Errno::EACCES - the attempt to connect the datagram socket to the broadcast address failed</p>
</li></ul>

<h3 id="method-i-connect-label-See">See</h3>
<ul><li>
<p>connect manual pages on unix-based systems</p>
</li><li>
<p>connect function in Microsoft’s Winsock functions reference</p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-connect_source')" id="l_method-i-connect_source">show</a>
                
              </p>
              <div id="method-i-connect_source" class="dyn-source">
                <pre>static VALUE
sock_connect(VALUE sock, VALUE addr)
{
    VALUE rai;
    rb_io_t *fptr;
    int fd, n;

    SockAddrStringValueWithAddrinfo(addr, rai);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    fd = fptr-&gt;fd;
    n = rsock_connect(fd, (struct sockaddr*)RSTRING_PTR(addr), RSTRING_SOCKLEN(addr), 0, NULL);
    if (n &lt; 0) {
        rsock_sys_fail_raddrinfo_or_sockaddr(&quot;connect(2)&quot;, addr, rai);
    }

    return INT2FIX(n);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-connect_nonblock">
            
              <b>socket.connect_nonblock(remote_sockaddr, [options]) => 0
</b>
            
            <a href="../classes/Socket.html#method-i-connect_nonblock" name="method-i-connect_nonblock" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Requests a connection to be made on the given <code>remote_sockaddr</code> after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful, otherwise an exception is raised.</p>

<h3 id="method-i-connect_nonblock-label-Parameter">Parameter</h3>

<pre><code># +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object
</code></pre>

<h3 id="method-i-connect_nonblock-label-Example-3A">Example:</h3>

<pre><code># Pull down Google&#39;s web page
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new(AF_INET, SOCK_STREAM, 0)
sockaddr = Socket.sockaddr_in(80, &#39;www.google.com&#39;)
begin # emulate blocking connect
  socket.connect_nonblock(sockaddr)
rescue IO::WaitWritable
  IO.select(nil, [socket]) # wait 3-way handshake completion
  begin
    socket.connect_nonblock(sockaddr) # check connection failure
  rescue Errno::EISCONN
  end
end
socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
results = socket.read
</code></pre>

<p>Refer to <a href="Socket.html#method-i-connect"><code>Socket#connect</code></a> for the exceptions that may be thrown if the call to <em>connect_nonblock</em> fails.</p>

<p><a href="Socket.html#method-i-connect_nonblock"><code>Socket#connect_nonblock</code></a> may raise any error corresponding to connect(2) failure, including Errno::EINPROGRESS.</p>

<p>If the exception is Errno::EINPROGRESS, it is extended by <a href="IO/WaitWritable.html"><code>IO::WaitWritable</code></a>. So <a href="IO/WaitWritable.html"><code>IO::WaitWritable</code></a> can be used to rescue the exceptions for retrying connect_nonblock.</p>

<p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="Socket.html#method-i-connect_nonblock"><code>connect_nonblock</code></a> should not raise an <a href="IO/WaitWritable.html"><code>IO::WaitWritable</code></a> exception, but return the symbol <code>:wait_writable</code> instead.</p>

<h3 id="method-i-connect_nonblock-label-See">See</h3>

<pre><code># Socket#connect
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-connect_nonblock_source')" id="l_method-i-connect_nonblock_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L1218" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-i-connect_nonblock_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 1218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">connect_nonblock</span>(<span class="ruby-identifier">addr</span>, <span class="ruby-value">exception:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">__connect_nonblock</span>(<span class="ruby-identifier">addr</span>, <span class="ruby-identifier">exception</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-ipv6only-21">
            
              <b>ipv6only!</b>()
            
            <a href="../classes/Socket.html#method-i-ipv6only-21" name="method-i-ipv6only-21" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-ipv6only-21_source')" id="l_method-i-ipv6only-21_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L468" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-i-ipv6only-21_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 468</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ipv6only!</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span> <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-constant">IPV6_V6ONLY</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">setsockopt</span>(<span class="ruby-value">:IPV6</span>, <span class="ruby-value">:V6ONLY</span>, <span class="ruby-value">1</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-listen">
            
              <b>socket.listen( int ) => 0
</b>
            
            <a href="../classes/Socket.html#method-i-listen" name="method-i-listen" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Listens for connections, using the specified <code>int</code> as the backlog. A call to <em>listen</em> only applies if the <code>socket</code> is of type SOCK_STREAM or SOCK_SEQPACKET.</p>

<h3 id="method-i-listen-label-Parameter">Parameter</h3>
<ul><li>
<p><code>backlog</code> - the maximum length of the queue for pending connections.</p>
</li></ul>

<h3 id="method-i-listen-label-Example+1">Example 1</h3>

<pre><code>require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.bind( sockaddr )
socket.listen( 5 )
</code></pre>

<h3 id="method-i-listen-label-Example+2+-28listening+on+an+arbitrary+port-2C+unix-based+systems+only-29-3A">Example 2 (listening on an arbitrary port, unix-based systems only):</h3>

<pre><code>require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
socket.listen( 1 )
</code></pre>

<h3 id="method-i-listen-label-Unix-based+Exceptions">Unix-based Exceptions</h3>

<p>On unix based systems the above will work because a new <code>sockaddr</code> struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the <code>socket</code> is bound by calling <em>bind</em> before it can <em>listen</em>.</p>

<p>If the <em>backlog</em> amount exceeds the implementation-dependent maximum queue length, the implementation’s maximum queue length will be used.</p>

<p>On unix-based based systems the following system exceptions may be raised if the call to <em>listen</em> fails:</p>
<ul><li>
<p>Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor</p>
</li><li>
<p>Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address, and the protocol does not support listening on an unbound socket</p>
</li><li>
<p>Errno::EINVAL - the <em>socket</em> is already connected</p>
</li><li>
<p>Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support listen</p>
</li><li>
<p>Errno::EACCES - the calling process does not have appropriate privileges</p>
</li><li>
<p>Errno::EINVAL - the <em>socket</em> has been shut down</p>
</li><li>
<p>Errno::ENOBUFS - insufficient resources are available in the system to complete the call</p>
</li></ul>

<h3 id="method-i-listen-label-Windows+Exceptions">Windows Exceptions</h3>

<p>On Windows systems the following system exceptions may be raised if the call to <em>listen</em> fails:</p>
<ul><li>
<p>Errno::ENETDOWN - the network is down</p>
</li><li>
<p>Errno::EADDRINUSE - the socket’s local address is already in use. This usually occurs during the execution of <em>bind</em> but could be delayed if the call to <em>bind</em> was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of the call to <em>listen</em></p>
</li><li>
<p>Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the service provider is still processing a callback function</p>
</li><li>
<p>Errno::EINVAL - the <code>socket</code> has not been bound with a call to <em>bind</em>.</p>
</li><li>
<p>Errno::EISCONN - the <code>socket</code> is already connected</p>
</li><li>
<p>Errno::EMFILE - no more socket descriptors are available</p>
</li><li>
<p>Errno::ENOBUFS - no buffer space is available</p>
</li><li>
<p>Errno::ENOTSOC - <code>socket</code> is not a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the referenced <code>socket</code> is not a type that supports the <em>listen</em> method</p>
</li></ul>

<h3 id="method-i-listen-label-See">See</h3>
<ul><li>
<p>listen manual pages on unix-based systems</p>
</li><li>
<p>listen function in Microsoft’s Winsock functions reference</p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-listen_source')" id="l_method-i-listen_source">show</a>
                
              </p>
              <div id="method-i-listen_source" class="dyn-source">
                <pre>VALUE
rsock_sock_listen(VALUE sock, VALUE log)
{
    rb_io_t *fptr;
    int backlog;

    backlog = NUM2INT(log);
    GetOpenFile(sock, fptr);
    if (listen(fptr-&gt;fd, backlog) &lt; 0)
        rb_sys_fail(&quot;listen(2)&quot;);

    return INT2FIX(0);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-recvfrom">
            
              <b>socket.recvfrom(maxlen) => [mesg, sender_addrinfo]<br />socket.recvfrom(maxlen, flags) => [mesg, sender_addrinfo]
</b>
            
            <a href="../classes/Socket.html#method-i-recvfrom" name="method-i-recvfrom" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Receives up to <em>maxlen</em> bytes from <code>socket</code>. <em>flags</em> is zero or more of the <code>MSG_</code> options. The first element of the results, <em>mesg</em>, is the data received. The second element, <em>sender_addrinfo</em>, contains protocol-specific address information of the sender.</p>

<h3 id="method-i-recvfrom-label-Parameters">Parameters</h3>
<ul><li>
<p><code>maxlen</code> - the maximum number of bytes to receive from the socket</p>
</li><li>
<p><code>flags</code> - zero or more of the <code>MSG_</code> options</p>
</li></ul>

<h3 id="method-i-recvfrom-label-Example">Example</h3>

<pre><code># In one file, start this first
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.bind( sockaddr )
socket.listen( 5 )
client, client_addrinfo = socket.accept
data = client.recvfrom( 20 )[0].chomp
puts &quot;I only received 20 bytes &#39;#{data}&#39;&quot;
sleep 1
socket.close

# In another file, start this second
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.connect( sockaddr )
socket.puts &quot;Watch this get cut short!&quot;
socket.close
</code></pre>

<h3 id="method-i-recvfrom-label-Unix-based+Exceptions">Unix-based Exceptions</h3>

<p>On unix-based based systems the following system exceptions may be raised if the call to <em>recvfrom</em> fails:</p>
<ul><li>
<p>Errno::EAGAIN - the <code>socket</code> file descriptor is marked as O_NONBLOCK and no data is waiting to be received; or MSG_OOB is set and no out-of-band data is available and either the <code>socket</code> file descriptor is marked as O_NONBLOCK or the <code>socket</code> does not support blocking to wait for out-of-band-data</p>
</li><li>
<p>Errno::EWOULDBLOCK - see Errno::EAGAIN</p>
</li><li>
<p>Errno::EBADF - the <code>socket</code> is not a valid file descriptor</p>
</li><li>
<p>Errno::ECONNRESET - a connection was forcibly closed by a peer</p>
</li><li>
<p>Errno::EFAULT - the socket’s internal buffer, address or address length cannot be accessed or written</p>
</li><li>
<p>Errno::EINTR - a signal interrupted <em>recvfrom</em> before any data was available</p>
</li><li>
<p>Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available</p>
</li><li>
<p>Errno::EIO - an i/o error occurred while reading from or writing to the filesystem</p>
</li><li>
<p>Errno::ENOBUFS - insufficient resources were available in the system to perform the operation</p>
</li><li>
<p>Errno::ENOMEM - insufficient memory was available to fulfill the request</p>
</li><li>
<p>Errno::ENOSR - there were insufficient STREAMS resources available to complete the operation</p>
</li><li>
<p>Errno::ENOTCONN - a receive is attempted on a connection-mode socket that is not connected</p>
</li><li>
<p>Errno::ENOTSOCK - the <code>socket</code> does not refer to a socket</p>
</li><li>
<p>Errno::EOPNOTSUPP - the specified flags are not supported for this socket type</p>
</li><li>
<p>Errno::ETIMEDOUT - the connection timed out during connection establishment or due to a transmission timeout on an active connection</p>
</li></ul>

<h3 id="method-i-recvfrom-label-Windows+Exceptions">Windows Exceptions</h3>

<p>On Windows systems the following system exceptions may be raised if the call to <em>recvfrom</em> fails:</p>
<ul><li>
<p>Errno::ENETDOWN - the network is down</p>
</li><li>
<p>Errno::EFAULT - the internal buffer and from parameters on <code>socket</code> are not part of the user address space, or the internal fromlen parameter is too small to accommodate the peer address</p>
</li><li>
<p>Errno::EINTR - the (blocking) call was cancelled by an internal call to the WinSock function WSACancelBlockingCall</p>
</li><li>
<p>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or the service provider is still processing a callback function</p>
</li><li>
<p>Errno::EINVAL - <code>socket</code> has not been bound with a call to <em>bind</em>, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal len parameter on <code>socket</code> was zero or negative</p>
</li><li>
<p>Errno::EISCONN - <code>socket</code> is already connected. The call to <em>recvfrom</em> is not permitted with a connected socket on a socket that is connection oriented or connectionless.</p>
</li><li>
<p>Errno::ENETRESET - the connection has been broken due to the keep-alive activity detecting a failure while the operation was in progress.</p>
</li><li>
<p>Errno::EOPNOTSUPP - MSG_OOB was specified, but <code>socket</code> is not stream-style such as type SOCK_STREAM. OOB data is not supported in the communication domain associated with <code>socket</code>, or <code>socket</code> is unidirectional and supports only send operations</p>
</li><li>
<p>Errno::ESHUTDOWN - <code>socket</code> has been shutdown. It is not possible to call <em>recvfrom</em> on a socket after <em>shutdown</em> has been invoked.</p>
</li><li>
<p>Errno::EWOULDBLOCK - <code>socket</code> is marked as nonblocking and a  call to <em>recvfrom</em> would block.</p>
</li><li>
<p>Errno::EMSGSIZE - the message was too large to fit into the specified buffer and was truncated.</p>
</li><li>
<p>Errno::ETIMEDOUT - the connection has been dropped, because of a network failure or because the system on the other end went down without notice</p>
</li><li>
<p>Errno::ECONNRESET - the virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket; it is no longer usable. On a UDP-datagram socket this error indicates a previous send operation resulted in an ICMP Port Unreachable message.</p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-recvfrom_source')" id="l_method-i-recvfrom_source">show</a>
                
              </p>
              <div id="method-i-recvfrom_source" class="dyn-source">
                <pre>static VALUE
sock_recvfrom(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom(sock, argc, argv, RECV_SOCKET);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-recvfrom_nonblock">
            
              <b>socket.recvfrom_nonblock(maxlen[, flags[, outbuf[, opts]]]) => [mesg, sender_addrinfo]
</b>
            
            <a href="../classes/Socket.html#method-i-recvfrom_nonblock" name="method-i-recvfrom_nonblock" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Receives up to <em>maxlen</em> bytes from <code>socket</code> using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em> is zero or more of the <code>MSG_</code> options. The first element of the results, <em>mesg</em>, is the data received. The second element, <em>sender_addrinfo</em>, contains protocol-specific address information of the sender.</p>

<p>When recvfrom(2) returns 0, <a href="BasicSocket.html#method-i-recv_nonblock"><code>Socket#recv_nonblock</code></a> returns nil. In most cases it means the connection was closed, but for UDP connections it may mean an empty packet was received, as the underlying API makes it impossible to distinguish these two cases.</p>

<h3 id="method-i-recvfrom_nonblock-label-Parameters">Parameters</h3>
<ul><li>
<p><code>maxlen</code> - the maximum number of bytes to receive from the socket</p>
</li><li>
<p><code>flags</code> - zero or more of the <code>MSG_</code> options</p>
</li><li>
<p><code>outbuf</code> - destination <a href="String.html"><code>String</code></a> buffer</p>
</li><li>
<p><code>opts</code> - keyword hash, supporting ‘exception: false`</p>
</li></ul>

<h3 id="method-i-recvfrom_nonblock-label-Example">Example</h3>

<pre><code># In one file, start this first
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new(AF_INET, SOCK_STREAM, 0)
sockaddr = Socket.sockaddr_in(2200, &#39;localhost&#39;)
socket.bind(sockaddr)
socket.listen(5)
client, client_addrinfo = socket.accept
begin # emulate blocking recvfrom
  pair = client.recvfrom_nonblock(20)
rescue IO::WaitReadable
  IO.select([client])
  retry
end
data = pair[0].chomp
puts &quot;I only received 20 bytes &#39;#{data}&#39;&quot;
sleep 1
socket.close

# In another file, start this second
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new(AF_INET, SOCK_STREAM, 0)
sockaddr = Socket.sockaddr_in(2200, &#39;localhost&#39;)
socket.connect(sockaddr)
socket.puts &quot;Watch this get cut short!&quot;
socket.close
</code></pre>

<p>Refer to <a href="Socket.html#method-i-recvfrom"><code>Socket#recvfrom</code></a> for the exceptions that may be thrown if the call to <em>recvfrom_nonblock</em> fails.</p>

<p><a href="Socket.html#method-i-recvfrom_nonblock"><code>Socket#recvfrom_nonblock</code></a> may raise any error corresponding to recvfrom(2) failure, including Errno::EWOULDBLOCK.</p>

<p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a>. So <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a> can be used to rescue the exceptions for retrying recvfrom_nonblock.</p>

<p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="Socket.html#method-i-recvfrom_nonblock"><code>recvfrom_nonblock</code></a> should not raise an <a href="IO/WaitReadable.html"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p>

<h3 id="method-i-recvfrom_nonblock-label-See">See</h3>
<ul><li>
<p><a href="Socket.html#method-i-recvfrom"><code>Socket#recvfrom</code></a></p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-recvfrom_nonblock_source')" id="l_method-i-recvfrom_nonblock_source">show</a>
                
                  | <a href="https://github.com/ruby/ruby/blob/49dc0a12f185d791f1826396035b54cf3fb1771e/ext/socket/lib/socket.rb#L541" target="_blank" class="github_url">on GitHub</a>
                
              </p>
              <div id="method-i-recvfrom_nonblock_source" class="dyn-source">
                <pre><span class="ruby-comment"># File ruby/ext/socket/lib/socket.rb, line 541</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">recvfrom_nonblock</span>(<span class="ruby-identifier">len</span>, <span class="ruby-identifier">flag</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">str</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-value">exception:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">__recvfrom_nonblock</span>(<span class="ruby-identifier">len</span>, <span class="ruby-identifier">flag</span>, <span class="ruby-identifier">str</span>, <span class="ruby-identifier">exception</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-sysaccept">
            
              <b>socket.sysaccept => [client_socket_fd, client_addrinfo]
</b>
            
            <a href="../classes/Socket.html#method-i-sysaccept" name="method-i-sysaccept" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Accepts an incoming connection returning an array containing the (integer) file descriptor for the incoming connection, <em>client_socket_fd</em>, and an <a href="Addrinfo.html"><code>Addrinfo</code></a>, <em>client_addrinfo</em>.</p>

<h3 id="method-i-sysaccept-label-Example">Example</h3>

<pre><code># In one script, start this first
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.bind( sockaddr )
socket.listen( 5 )
client_fd, client_addrinfo = socket.sysaccept
client_socket = Socket.for_fd( client_fd )
puts &quot;The client said, &#39;#{client_socket.readline.chomp}&#39;&quot;
client_socket.puts &quot;Hello from script one!&quot;
socket.close

# In another script, start this second
require &#39;socket&#39;
include Socket::Constants
socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
sockaddr = Socket.pack_sockaddr_in( 2200, &#39;localhost&#39; )
socket.connect( sockaddr )
socket.puts &quot;Hello from script 2.&quot;
puts &quot;The server said, &#39;#{socket.readline.chomp}&#39;&quot;
socket.close
</code></pre>

<p>Refer to <a href="Socket.html#method-i-accept"><code>Socket#accept</code></a> for the exceptions that may be thrown if the call to <em>sysaccept</em> fails.</p>

<h3 id="method-i-sysaccept-label-See">See</h3>
<ul><li>
<p><a href="Socket.html#method-i-accept"><code>Socket#accept</code></a></p>
</li></ul>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-sysaccept_source')" id="l_method-i-sysaccept_source">show</a>
                
              </p>
              <div id="method-i-sysaccept_source" class="dyn-source">
                <pre>static VALUE
sock_sysaccept(VALUE server)
{
    union_sockaddr buffer;
    socklen_t length = (socklen_t)sizeof(buffer);

    VALUE peer = rsock_s_accept(0, server, &amp;buffer.addr, &amp;length);

    return rb_assoc_new(peer, rsock_io_socket_addrinfo(peer, &amp;buffer.addr, length));
}</pre>
              </div>
            </div>
            
          </div>
        
      
    
  
</div>

    </main>
  </body>
</html>
