<!DOCTYPE html>
<html lang="en">
<head>
    <title>Method</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
<link rel="stylesheet" href="/css/reset.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/panel.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/github.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<script src="/js/jquery-3.5.1.min.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/main.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/highlight.pack.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/turbolinks.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/search_index.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searcher.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/panel/tree.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searchdoc.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>

<meta name="data-rel-prefix" content="/">
<meta name="data-tree-keys" content='["Method"]'>


    <meta property="og:title" value="Method">

  
    
    <meta name="description" content="Method objects are created by Object#method, and are associated with a particular object (not just with a class).">
    <meta property="og:description" content="Method objects are created by Object#method, and are associated with a particular object (not just with a class).">
  

    <meta name="keywords" content="Method class, ==, eql?, hash, clone, call, ===, curry, <<, >>, [], arity, inspect, to_s, to_proc, receiver, name, original_name, owner, unbind, source_location, parameters, super_method, public?, protected?, private?">
</head>

<body>
    <a class="sr-only sr-only-focusable" href="#content" data-turbolinks="false">Skip to Content</a>
    <a class="sr-only sr-only-focusable" href="#search" data-turbolinks="false">Skip to Search</a>

    <input type="checkbox" id="hamburger" class="panel_checkbox">
<label class="panel_mobile_button" for="hamburger"><span></span> Menu</label>
<nav class="panel panel_tree" id="panel" data-turbolinks-permanent>
  <div class="header">
    <input type="text" placeholder="Search (/) for a class, method, ..." autosave="searchdoc" results="10" id="search" autocomplete="off" tabindex="-1" />
    <label class="panel_mobile_button_close" for="hamburger"><span></span> Close</label>
  </div>
  <div class="tree">
    <ul>
    </ul>
  </div>
  <div class="result">
    <ul>
    </ul>
  </div>
  <a href="links.html" id="links">index</a>
</nav>


    <div class="banner">
        
        <h2>
            <span class="type">Class</span>
            Method
            
                <span class="parent">&lt;
                    
                    <a href="Object.html">Object</a>
                    
                </span>
            
        </h2>
        <ul class="files">
            
            <li><a href="../files/ruby/proc_c.html">ruby/proc.c</a></li>
            
        </ul>
    </div>

    <main id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p><a href="Method.html"><code>Method</code></a> objects are created by <a href="Object.html#method-i-method"><code>Object#method</code></a>, and are associated with a particular object (not just with a class).  They may be used to invoke the method within the object, and as a block associated with an iterator.  They may also be unbound from one object (creating an <a href="UnboundMethod.html"><code>UnboundMethod</code></a>) and bound to another.</p>

<pre><code>class Thing
  def square(n)
    n*n
  end
end
thing = Thing.new
meth  = thing.method(:square)

meth.call(9)                 #=&gt; 81
[ 1, 2, 3 ].collect(&amp;meth)   #=&gt; [1, 4, 9]

[ 1, 2, 3 ].each(&amp;method(:puts)) #=&gt; prints 1, 2, 3

require &#39;date&#39;
%w[2017-03-01 2017-03-02].collect(&amp;Date.method(:parse))
#=&gt; [#&lt;Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)&gt;, #&lt;Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)&gt;]
</code></pre>

    </div>
  


  


  
  


  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>#</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-3C-3C">&lt;&lt;</a>,
              </li>
            
              
              <li>
                <a href="#method-i-3D-3D">==</a>,
              </li>
            
              
              <li>
                <a href="#method-i-3D-3D-3D">===</a>,
              </li>
            
              
              <li>
                <a href="#method-i-3E-3E">&gt;&gt;</a>,
              </li>
            
              
              <li>
                <a href="#method-i-5B-5D">[]</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>A</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-arity">arity</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>C</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-call">call</a>,
              </li>
            
              
              <li>
                <a href="#method-i-clone">clone</a>,
              </li>
            
              
              <li>
                <a href="#method-i-curry">curry</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>E</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-eql-3F">eql?</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>H</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-hash">hash</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>I</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-inspect">inspect</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>N</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-name">name</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>O</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-original_name">original_name</a>,
              </li>
            
              
              <li>
                <a href="#method-i-owner">owner</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>P</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-parameters">parameters</a>,
              </li>
            
              
              <li>
                <a href="#method-i-private-3F">private?</a>,
              </li>
            
              
              <li>
                <a href="#method-i-protected-3F">protected?</a>,
              </li>
            
              
              <li>
                <a href="#method-i-public-3F">public?</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>R</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-receiver">receiver</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>S</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-source_location">source_location</a>,
              </li>
            
              
              <li>
                <a href="#method-i-super_method">super_method</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>T</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-to_proc">to_proc</a>,
              </li>
            
              
              <li>
                <a href="#method-i-to_s">to_s</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>U</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-unbind">unbind</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    


    


    <!-- Methods -->
    
    
      <h2 class="sectiontitle">Instance Public methods</h2>
      
        <div class="method">
          <h3 class="title method-title" id="method-i-3C-3C">
            
              <b>meth << g &rarr; a_proc
</b>
            
            <a href="../classes/Method.html#method-i-3C-3C" name="method-i-3C-3C" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a proc that is the composition of this method and the given <em>g</em>. The returned proc takes a variable number of arguments, calls <em>g</em> with them then calls this method with the result.</p>

<pre><code>def f(x)
  x * x
end

f = self.method(:f)
g = proc {|x| x + x }
p (f &lt;&lt; g).call(2) #=&gt; 16
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-3C-3C_source')" id="l_method-i-3C-3C_source">show</a>
                
              </p>
              <div id="method-i-3C-3C_source" class="dyn-source">
                <pre>static VALUE
rb_method_compose_to_left(VALUE self, VALUE g)
{
    g = to_callable(g);
    self = method_to_proc(self);
    return proc_compose_to_left(self, g);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-3D-3D">
            
              <b>meth == other_meth  &rarr; true or false</b>
            
            <a href="../classes/Method.html#method-i-3D-3D" name="method-i-3D-3D" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Two method objects are equal if they are bound to the same object and refer to the same method definition and the classes defining the methods are the same class or module.</p>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Method.html#method-i-eql-3F">eql?</a>
            </div>
          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-3D-3D_source')" id="l_method-i-3D-3D_source">show</a>
                
              </p>
              <div id="method-i-3D-3D_source" class="dyn-source">
                <pre>static VALUE
method_eq(VALUE method, VALUE other)
{
    struct METHOD *m1, *m2;
    VALUE klass1, klass2;

    if (!rb_obj_is_method(other))
        return Qfalse;
    if (CLASS_OF(method) != CLASS_OF(other))
        return Qfalse;

    Check_TypedStruct(method, &amp;method_data_type);
    m1 = (struct METHOD *)DATA_PTR(method);
    m2 = (struct METHOD *)DATA_PTR(other);

    klass1 = method_entry_defined_class(m1-&gt;me);
    klass2 = method_entry_defined_class(m2-&gt;me);

    if (!rb_method_entry_eq(m1-&gt;me, m2-&gt;me) ||
        klass1 != klass2 ||
        m1-&gt;klass != m2-&gt;klass ||
        m1-&gt;recv != m2-&gt;recv) {
        return Qfalse;
    }

    return Qtrue;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-3D-3D-3D">
            
              <b>===</b>(*args)
            
            <a href="../classes/Method.html#method-i-3D-3D-3D" name="method-i-3D-3D-3D" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the <em>meth</em> with the specified arguments, returning the method’s return value.</p>

<pre><code>m = 12.method(&quot;+&quot;)
m.call(3)    #=&gt; 15
m.call(20)   #=&gt; 32
</code></pre>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Method.html#method-i-call">call</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-3E-3E">
            
              <b>meth >> g &rarr; a_proc
</b>
            
            <a href="../classes/Method.html#method-i-3E-3E" name="method-i-3E-3E" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a proc that is the composition of this method and the given <em>g</em>. The returned proc takes a variable number of arguments, calls this method with them then calls <em>g</em> with the result.</p>

<pre><code>def f(x)
  x * x
end

f = self.method(:f)
g = proc {|x| x + x }
p (f &gt;&gt; g).call(2) #=&gt; 8
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-3E-3E_source')" id="l_method-i-3E-3E_source">show</a>
                
              </p>
              <div id="method-i-3E-3E_source" class="dyn-source">
                <pre>static VALUE
rb_method_compose_to_right(VALUE self, VALUE g)
{
    g = to_callable(g);
    self = method_to_proc(self);
    return proc_compose_to_right(self, g);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-5B-5D">
            
              <b>[]</b>(*args)
            
            <a href="../classes/Method.html#method-i-5B-5D" name="method-i-5B-5D" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the <em>meth</em> with the specified arguments, returning the method’s return value.</p>

<pre><code>m = 12.method(&quot;+&quot;)
m.call(3)    #=&gt; 15
m.call(20)   #=&gt; 32
</code></pre>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Method.html#method-i-call">call</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-arity">
            
              <b>meth.arity    &rarr; integer
</b>
            
            <a href="../classes/Method.html#method-i-arity" name="method-i-arity" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. Keyword arguments will be considered as a single additional argument, that argument being mandatory if any keyword argument is mandatory. For methods written in C, returns -1 if the call takes a variable number of arguments.</p>

<pre><code>class C
  def one;    end
  def two(a); end
  def three(*a);  end
  def four(a, b); end
  def five(a, b, *c);    end
  def six(a, b, *c, &amp;d); end
  def seven(a, b, x:0); end
  def eight(x:, y:); end
  def nine(x:, y:, **z); end
  def ten(*a, x:, y:); end
end
c = C.new
c.method(:one).arity     #=&gt; 0
c.method(:two).arity     #=&gt; 1
c.method(:three).arity   #=&gt; -1
c.method(:four).arity    #=&gt; 2
c.method(:five).arity    #=&gt; -3
c.method(:six).arity     #=&gt; -3
c.method(:seven).arity   #=&gt; -3
c.method(:eight).arity   #=&gt; 1
c.method(:nine).arity    #=&gt; 1
c.method(:ten).arity     #=&gt; -2

&quot;cat&quot;.method(:size).arity      #=&gt; 0
&quot;cat&quot;.method(:replace).arity   #=&gt; 1
&quot;cat&quot;.method(:squeeze).arity   #=&gt; -1
&quot;cat&quot;.method(:count).arity     #=&gt; -1
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-arity_source')" id="l_method-i-arity_source">show</a>
                
              </p>
              <div id="method-i-arity_source" class="dyn-source">
                <pre>static VALUE
method_arity_m(VALUE method)
{
    int n = method_arity(method);
    return INT2FIX(n);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-call">
            
              <b>meth.call(args, ...)    &rarr; obj</b>
            
            <a href="../classes/Method.html#method-i-call" name="method-i-call" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Invokes the <em>meth</em> with the specified arguments, returning the method’s return value.</p>

<pre><code>m = 12.method(&quot;+&quot;)
m.call(3)    #=&gt; 15
m.call(20)   #=&gt; 32
</code></pre>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Method.html#method-i-3D-3D-3D">===</a>, <a href="Method.html#method-i-5B-5D">[]</a>
            </div>
          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-call_source')" id="l_method-i-call_source">show</a>
                
              </p>
              <div id="method-i-call_source" class="dyn-source">
                <pre>static VALUE
rb_method_call_pass_called_kw(int argc, const VALUE *argv, VALUE method)
{
    VALUE procval = rb_block_given_p() ? rb_block_proc() : Qnil;
    return rb_method_call_with_block_kw(argc, argv, method, procval, RB_PASS_CALLED_KEYWORDS);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-clone">
            
              <b>method.clone &rarr; new_method
</b>
            
            <a href="../classes/Method.html#method-i-clone" name="method-i-clone" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a clone of this method.</p>

<pre><code>class A
  def foo
    return &quot;bar&quot;
  end
end

m = A.new.method(:foo)
m.call # =&gt; &quot;bar&quot;
n = m.clone.call # =&gt; &quot;bar&quot;
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-clone_source')" id="l_method-i-clone_source">show</a>
                
              </p>
              <div id="method-i-clone_source" class="dyn-source">
                <pre>static VALUE
method_clone(VALUE self)
{
    VALUE clone;
    struct METHOD *orig, *data;

    TypedData_Get_Struct(self, struct METHOD, &amp;method_data_type, orig);
    clone = TypedData_Make_Struct(CLASS_OF(self), struct METHOD, &amp;method_data_type, data);
    CLONESETUP(clone, self);
    RB_OBJ_WRITE(clone, &amp;data-&gt;recv, orig-&gt;recv);
    RB_OBJ_WRITE(clone, &amp;data-&gt;klass, orig-&gt;klass);
    RB_OBJ_WRITE(clone, &amp;data-&gt;iclass, orig-&gt;iclass);
    RB_OBJ_WRITE(clone, &amp;data-&gt;me, rb_method_entry_clone(orig-&gt;me));
    return clone;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-curry">
            
              <b>meth.curry        &rarr; proc<br />meth.curry(arity) &rarr; proc
</b>
            
            <a href="../classes/Method.html#method-i-curry" name="method-i-curry" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a curried proc based on the method. When the proc is called with a number of arguments that is lower than the method’s arity, then another curried proc is returned. Only when enough arguments have been supplied to satisfy the method signature, will the method actually be called.</p>

<p>The optional <em>arity</em> argument should be supplied when currying methods with variable arguments to determine how many arguments are needed before the method is called.</p>

<pre><code>def foo(a,b,c)
  [a, b, c]
end

proc  = self.method(:foo).curry
proc2 = proc.call(1, 2)          #=&gt; #&lt;Proc&gt;
proc2.call(3)                    #=&gt; [1,2,3]

def vararg(*args)
  args
end

proc = self.method(:vararg).curry(4)
proc2 = proc.call(:x)      #=&gt; #&lt;Proc&gt;
proc3 = proc2.call(:y, :z) #=&gt; #&lt;Proc&gt;
proc3.call(:a)             #=&gt; [:x, :y, :z, :a]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-curry_source')" id="l_method-i-curry_source">show</a>
                
              </p>
              <div id="method-i-curry_source" class="dyn-source">
                <pre>static VALUE
rb_method_curry(int argc, const VALUE *argv, VALUE self)
{
    VALUE proc = method_to_proc(self);
    return proc_curry(argc, argv, proc);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-eql-3F">
            
              <b>meth.eql?(other_meth)  &rarr; true or false</b>
            
            <a href="../classes/Method.html#method-i-eql-3F" name="method-i-eql-3F" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Two method objects are equal if they are bound to the same object and refer to the same method definition and the classes defining the methods are the same class or module.</p>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Method.html#method-i-3D-3D">==</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-hash">
            
              <b>meth.hash   &rarr; integer
</b>
            
            <a href="../classes/Method.html#method-i-hash" name="method-i-hash" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a hash value corresponding to the method object.</p>

<p>See also <a href="Object.html#method-i-hash"><code>Object#hash</code></a>.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-hash_source')" id="l_method-i-hash_source">show</a>
                
              </p>
              <div id="method-i-hash_source" class="dyn-source">
                <pre>static VALUE
method_hash(VALUE method)
{
    struct METHOD *m;
    st_index_t hash;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, m);
    hash = rb_hash_start((st_index_t)m-&gt;recv);
    hash = rb_hash_method_entry(hash, m-&gt;me);
    hash = rb_hash_end(hash);

    return ST2FIX(hash);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-inspect">
            
              <b>meth.inspect   &rarr;  string</b>
            
            <a href="../classes/Method.html#method-i-inspect" name="method-i-inspect" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a human-readable description of the underlying method.</p>

<pre><code>&quot;cat&quot;.method(:count).inspect   #=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;
(1..3).method(:map).inspect    #=&gt; &quot;#&lt;Method: Range(Enumerable)#map()&gt;&quot;
</code></pre>

<p>In the latter case, the method description includes the “owner” of the original method (<code>Enumerable</code> module, which is included into <code>Range</code>).</p>

<p><code>inspect</code> also provides, when possible, method argument names (call sequence) and source location.</p>

<pre><code>require &#39;net/http&#39;
Net::HTTP.method(:get).inspect
#=&gt; &quot;#&lt;Method: Net::HTTP.get(uri_or_host, path=..., port=...) &lt;skip&gt;/lib/ruby/2.7.0/net/http.rb:457&gt;&quot;
</code></pre>

<p><code>...</code> in argument definition means argument is optional (has some default value).</p>

<p>For methods defined in C (language core and extensions), location and argument names can’t be extracted, and only generic information is provided in form of <code>*</code> (any number of arguments) or <code>_</code> (some positional argument).</p>

<pre><code>&quot;cat&quot;.method(:count).inspect   #=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;
&quot;cat&quot;.method(:+).inspect       #=&gt; &quot;#&lt;Method: String#+(_)&gt;&quot;&quot;
</code></pre>
            </div>
          

          
            <div class="aka">
              Also aliased as: <a href="Method.html#method-i-to_s">to_s</a>
            </div>
          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-inspect_source')" id="l_method-i-inspect_source">show</a>
                
              </p>
              <div id="method-i-inspect_source" class="dyn-source">
                <pre>static VALUE
method_inspect(VALUE method)
{
    struct METHOD *data;
    VALUE str;
    const char *sharp = &quot;#&quot;;
    VALUE mklass;
    VALUE defined_class;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    str = rb_sprintf(&quot;#&lt;% &quot;PRIsVALUE&quot;: &quot;, rb_obj_class(method));

    mklass = data-&gt;iclass;
    if (!mklass) mklass = data-&gt;klass;

    if (RB_TYPE_P(mklass, T_ICLASS)) {
        /* TODO: I&#39;m not sure why mklass is T_ICLASS.
         * UnboundMethod#bind() can set it as T_ICLASS at convert_umethod_to_method_components()
         * but not sure it is needed.
         */
        mklass = RBASIC_CLASS(mklass);
    }

    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_ALIAS) {
        defined_class = data-&gt;me-&gt;def-&gt;body.alias.original_me-&gt;owner;
    }
    else {
        defined_class = method_entry_defined_class(data-&gt;me);
    }

    if (RB_TYPE_P(defined_class, T_ICLASS)) {
        defined_class = RBASIC_CLASS(defined_class);
    }

    if (FL_TEST(mklass, FL_SINGLETON)) {
        VALUE v = rb_ivar_get(mklass, attached);

        if (data-&gt;recv == Qundef) {
            rb_str_buf_append(str, rb_inspect(mklass));
        }
        else if (data-&gt;recv == v) {
            rb_str_buf_append(str, rb_inspect(v));
            sharp = &quot;.&quot;;
        }
        else {
            rb_str_buf_append(str, rb_inspect(data-&gt;recv));
            rb_str_buf_cat2(str, &quot;(&quot;);
            rb_str_buf_append(str, rb_inspect(v));
            rb_str_buf_cat2(str, &quot;)&quot;);
            sharp = &quot;.&quot;;
        }
    }
    else {
        mklass = data-&gt;klass;
        if (FL_TEST(mklass, FL_SINGLETON)) {
            VALUE v = rb_ivar_get(mklass, attached);
            if (!(RB_TYPE_P(v, T_CLASS) || RB_TYPE_P(v, T_MODULE))) {
                do {
                   mklass = RCLASS_SUPER(mklass);
                } while (RB_TYPE_P(mklass, T_ICLASS));
            }
        }
        rb_str_buf_append(str, rb_inspect(mklass));
        if (defined_class != mklass) {
            rb_str_catf(str, &quot;(% &quot;PRIsVALUE&quot;)&quot;, defined_class);
        }
    }
    rb_str_buf_cat2(str, sharp);
    rb_str_append(str, rb_id2str(data-&gt;me-&gt;called_id));
    if (data-&gt;me-&gt;called_id != data-&gt;me-&gt;def-&gt;original_id) {
        rb_str_catf(str, &quot;(%&quot;PRIsVALUE&quot;)&quot;,
                    rb_id2str(data-&gt;me-&gt;def-&gt;original_id));
    }
    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_NOTIMPLEMENTED) {
        rb_str_buf_cat2(str, &quot; (not-implemented)&quot;);
    }

    // parameter information
    {
        VALUE params = rb_method_parameters(method);
        VALUE pair, name, kind;
        const VALUE req = ID2SYM(rb_intern(&quot;req&quot;));
        const VALUE opt = ID2SYM(rb_intern(&quot;opt&quot;));
        const VALUE keyreq = ID2SYM(rb_intern(&quot;keyreq&quot;));
        const VALUE key = ID2SYM(rb_intern(&quot;key&quot;));
        const VALUE rest = ID2SYM(rb_intern(&quot;rest&quot;));
        const VALUE keyrest = ID2SYM(rb_intern(&quot;keyrest&quot;));
        const VALUE block = ID2SYM(rb_intern(&quot;block&quot;));
        const VALUE nokey = ID2SYM(rb_intern(&quot;nokey&quot;));
        int forwarding = 0;

        rb_str_buf_cat2(str, &quot;(&quot;);

        for (int i = 0; i &lt; RARRAY_LEN(params); i++) {
            pair = RARRAY_AREF(params, i);
            kind = RARRAY_AREF(pair, 0);
            name = RARRAY_AREF(pair, 1);
            // FIXME: in tests it turns out that kind, name = [:req] produces name to be false. Why?..
            if (NIL_P(name) || name == Qfalse) {
                // FIXME: can it be reduced to switch/case?
                if (kind == req || kind == opt) {
                    name = rb_str_new2(&quot;_&quot;);
                }
                else if (kind == rest || kind == keyrest) {
                    name = rb_str_new2(&quot;&quot;);
                }
                else if (kind == block) {
                    name = rb_str_new2(&quot;block&quot;);
                }
                else if (kind == nokey) {
                    name = rb_str_new2(&quot;nil&quot;);
                }
            }

            if (kind == req) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE, name);
            }
            else if (kind == opt) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;=...&quot;, name);
            }
            else if (kind == keyreq) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;:&quot;, name);
            }
            else if (kind == key) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;: ...&quot;, name);
            }
            else if (kind == rest) {
                if (name == ID2SYM(&#39;*&#39;)) {
                    forwarding = 1;
                    rb_str_cat_cstr(str, &quot;...&quot;);
                }
                else {
                    rb_str_catf(str, &quot;*%&quot;PRIsVALUE, name);
                }
            }
            else if (kind == keyrest) {
                if (name != ID2SYM(idPow)) {
                    rb_str_catf(str, &quot;**%&quot;PRIsVALUE, name);
                }
                else if (i &gt; 0) {
                    rb_str_set_len(str, RSTRING_LEN(str) - 2);
                }
            }
            else if (kind == block) {
                if (name == ID2SYM(&#39;&amp;&#39;)) {
                    if (forwarding) {
                        rb_str_set_len(str, RSTRING_LEN(str) - 2);
                    }
                    else {
                        rb_str_cat_cstr(str, &quot;...&quot;);
                    }
                }
                else {
                    rb_str_catf(str, &quot;&amp;%&quot;PRIsVALUE, name);
                }
            }
            else if (kind == nokey) {
                rb_str_buf_cat2(str, &quot;**nil&quot;);
            }

            if (i &lt; RARRAY_LEN(params) - 1) {
                rb_str_buf_cat2(str, &quot;, &quot;);
            }
        }
        rb_str_buf_cat2(str, &quot;)&quot;);
    }

    { // source location
        VALUE loc = rb_method_location(method);
        if (!NIL_P(loc)) {
            rb_str_catf(str, &quot; %&quot;PRIsVALUE&quot;:%&quot;PRIsVALUE,
                        RARRAY_AREF(loc, 0), RARRAY_AREF(loc, 1));
        }
    }

    rb_str_buf_cat2(str, &quot;&gt;&quot;);

    return str;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-name">
            
              <b>meth.name    &rarr; symbol
</b>
            
            <a href="../classes/Method.html#method-i-name" name="method-i-name" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the name of the method.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-name_source')" id="l_method-i-name_source">show</a>
                
              </p>
              <div id="method-i-name_source" class="dyn-source">
                <pre>static VALUE
method_name(VALUE obj)
{
    struct METHOD *data;

    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return ID2SYM(data-&gt;me-&gt;called_id);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-original_name">
            
              <b>meth.original_name    &rarr; symbol
</b>
            
            <a href="../classes/Method.html#method-i-original_name" name="method-i-original_name" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the original name of the method.</p>

<pre><code>class C
  def foo; end
  alias bar foo
end
C.instance_method(:bar).original_name # =&gt; :foo
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-original_name_source')" id="l_method-i-original_name_source">show</a>
                
              </p>
              <div id="method-i-original_name_source" class="dyn-source">
                <pre>static VALUE
method_original_name(VALUE obj)
{
    struct METHOD *data;

    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return ID2SYM(data-&gt;me-&gt;def-&gt;original_id);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-owner">
            
              <b>meth.owner    &rarr; class_or_module
</b>
            
            <a href="../classes/Method.html#method-i-owner" name="method-i-owner" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the class or module that defines the method. See also <a href="Method.html#method-i-receiver"><code>Method#receiver</code></a>.</p>

<pre><code>(1..3).method(:map).owner #=&gt; Enumerable
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-owner_source')" id="l_method-i-owner_source">show</a>
                
              </p>
              <div id="method-i-owner_source" class="dyn-source">
                <pre>static VALUE
method_owner(VALUE obj)
{
    struct METHOD *data;
    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return data-&gt;me-&gt;owner;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-parameters">
            
              <b>meth.parameters  &rarr; array
</b>
            
            <a href="../classes/Method.html#method-i-parameters" name="method-i-parameters" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the parameter information of this method.</p>

<pre><code>def foo(bar); end
method(:foo).parameters #=&gt; [[:req, :bar]]

def foo(bar, baz, bat, &amp;blk); end
method(:foo).parameters #=&gt; [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]

def foo(bar, *args); end
method(:foo).parameters #=&gt; [[:req, :bar], [:rest, :args]]

def foo(bar, baz, *args, &amp;blk); end
method(:foo).parameters #=&gt; [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-parameters_source')" id="l_method-i-parameters_source">show</a>
                
              </p>
              <div id="method-i-parameters_source" class="dyn-source">
                <pre>static VALUE
rb_method_parameters(VALUE method)
{
    return method_def_parameters(rb_method_def(method));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-private-3F">
            
              <b>meth.private? &rarr; true or false
</b>
            
            <a href="../classes/Method.html#method-i-private-3F" name="method-i-private-3F" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns whether the method is private.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-private-3F_source')" id="l_method-i-private-3F_source">show</a>
                
              </p>
              <div id="method-i-private-3F_source" class="dyn-source">
                <pre>static VALUE
method_private_p(VALUE method)
{
    const struct METHOD *data;
    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    return RBOOL(METHOD_ENTRY_VISI(data-&gt;me) == METHOD_VISI_PRIVATE);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-protected-3F">
            
              <b>meth.protected? &rarr; true or false
</b>
            
            <a href="../classes/Method.html#method-i-protected-3F" name="method-i-protected-3F" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns whether the method is protected.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-protected-3F_source')" id="l_method-i-protected-3F_source">show</a>
                
              </p>
              <div id="method-i-protected-3F_source" class="dyn-source">
                <pre>static VALUE
method_protected_p(VALUE method)
{
    const struct METHOD *data;
    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    return RBOOL(METHOD_ENTRY_VISI(data-&gt;me) == METHOD_VISI_PROTECTED);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-public-3F">
            
              <b>meth.public? &rarr; true or false
</b>
            
            <a href="../classes/Method.html#method-i-public-3F" name="method-i-public-3F" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns whether the method is public.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-public-3F_source')" id="l_method-i-public-3F_source">show</a>
                
              </p>
              <div id="method-i-public-3F_source" class="dyn-source">
                <pre>static VALUE
method_public_p(VALUE method)
{
    const struct METHOD *data;
    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    return RBOOL(METHOD_ENTRY_VISI(data-&gt;me) == METHOD_VISI_PUBLIC);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-receiver">
            
              <b>meth.receiver    &rarr; object
</b>
            
            <a href="../classes/Method.html#method-i-receiver" name="method-i-receiver" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the bound receiver of the method object.</p>

<pre><code>(1..3).method(:map).receiver # =&gt; 1..3
</code></pre>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-receiver_source')" id="l_method-i-receiver_source">show</a>
                
              </p>
              <div id="method-i-receiver_source" class="dyn-source">
                <pre>static VALUE
method_receiver(VALUE obj)
{
    struct METHOD *data;

    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return data-&gt;recv;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-source_location">
            
              <b>meth.source_location  &rarr; [String, Integer]
</b>
            
            <a href="../classes/Method.html#method-i-source_location" name="method-i-source_location" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns the Ruby source filename and line number containing this method or nil if this method was not defined in Ruby (i.e. native).</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-source_location_source')" id="l_method-i-source_location_source">show</a>
                
              </p>
              <div id="method-i-source_location_source" class="dyn-source">
                <pre>VALUE
rb_method_location(VALUE method)
{
    return method_def_location(rb_method_def(method));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-super_method">
            
              <b>meth.super_method  &rarr; method
</b>
            
            <a href="../classes/Method.html#method-i-super_method" name="method-i-super_method" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a <a href="Method.html"><code>Method</code></a> of superclass which would be called when super is used or nil if there is no method on superclass.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-super_method_source')" id="l_method-i-super_method_source">show</a>
                
              </p>
              <div id="method-i-super_method_source" class="dyn-source">
                <pre>static VALUE
method_super_method(VALUE method)
{
    const struct METHOD *data;
    VALUE super_class, iclass;
    ID mid;
    const rb_method_entry_t *me;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    iclass = data-&gt;iclass;
    if (!iclass) return Qnil;
    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_ALIAS &amp;&amp; data-&gt;me-&gt;defined_class) {
        super_class = RCLASS_SUPER(rb_find_defined_class_by_owner(data-&gt;me-&gt;defined_class,
            data-&gt;me-&gt;def-&gt;body.alias.original_me-&gt;owner));
        mid = data-&gt;me-&gt;def-&gt;body.alias.original_me-&gt;def-&gt;original_id;
    }
    else {
        super_class = RCLASS_SUPER(RCLASS_ORIGIN(iclass));
        mid = data-&gt;me-&gt;def-&gt;original_id;
    }
    if (!super_class) return Qnil;
    me = (rb_method_entry_t *)rb_callable_method_entry_with_refinements(super_class, mid, &amp;iclass);
    if (!me) return Qnil;
    return mnew_internal(me, me-&gt;owner, iclass, data-&gt;recv, mid, rb_obj_class(method), FALSE, FALSE);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-to_proc">
            
              <b>meth.to_proc    &rarr; proc
</b>
            
            <a href="../classes/Method.html#method-i-to_proc" name="method-i-to_proc" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a <a href="Proc.html"><code>Proc</code></a> object corresponding to this method.</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-to_proc_source')" id="l_method-i-to_proc_source">show</a>
                
              </p>
              <div id="method-i-to_proc_source" class="dyn-source">
                <pre>static VALUE
method_to_proc(VALUE method)
{
    VALUE procval;
    rb_proc_t *proc;

    /*
     * class Method
     *   def to_proc
     *     lambda{|*args|
     *       self.call(*args)
     *     }
     *   end
     * end
     */
    procval = rb_block_call(rb_mRubyVMFrozenCore, idLambda, 0, 0, bmcall, method);
    GetProcPtr(procval, proc);
    proc-&gt;is_from_method = 1;
    return procval;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-to_s">
            
              <b>meth.to_s      &rarr;  string</b>
            
            <a href="../classes/Method.html#method-i-to_s" name="method-i-to_s" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Returns a human-readable description of the underlying method.</p>

<pre><code>&quot;cat&quot;.method(:count).inspect   #=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;
(1..3).method(:map).inspect    #=&gt; &quot;#&lt;Method: Range(Enumerable)#map()&gt;&quot;
</code></pre>

<p>In the latter case, the method description includes the “owner” of the original method (<code>Enumerable</code> module, which is included into <code>Range</code>).</p>

<p><code>inspect</code> also provides, when possible, method argument names (call sequence) and source location.</p>

<pre><code>require &#39;net/http&#39;
Net::HTTP.method(:get).inspect
#=&gt; &quot;#&lt;Method: Net::HTTP.get(uri_or_host, path=..., port=...) &lt;skip&gt;/lib/ruby/2.7.0/net/http.rb:457&gt;&quot;
</code></pre>

<p><code>...</code> in argument definition means argument is optional (has some default value).</p>

<p>For methods defined in C (language core and extensions), location and argument names can’t be extracted, and only generic information is provided in form of <code>*</code> (any number of arguments) or <code>_</code> (some positional argument).</p>

<pre><code>&quot;cat&quot;.method(:count).inspect   #=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;
&quot;cat&quot;.method(:+).inspect       #=&gt; &quot;#&lt;Method: String#+(_)&gt;&quot;&quot;
</code></pre>
            </div>
          

          

          
            <div class="aka">
              Alias for: <a href="Method.html#method-i-inspect">inspect</a>
            </div>
          

          
          </div>
        
        <div class="method">
          <h3 class="title method-title" id="method-i-unbind">
            
              <b>meth.unbind    &rarr; unbound_method
</b>
            
            <a href="../classes/Method.html#method-i-unbind" name="method-i-unbind" class="permalink">Link</a>
          </h3>

          
            <div class="description">
              <p>Dissociates <em>meth</em> from its current receiver. The resulting <a href="UnboundMethod.html"><code>UnboundMethod</code></a> can subsequently be bound to a new object of the same class (see <a href="UnboundMethod.html"><code>UnboundMethod</code></a>).</p>
            </div>
          

          

          

          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source:
                <a href="javascript:toggleSource('method-i-unbind_source')" id="l_method-i-unbind_source">show</a>
                
              </p>
              <div id="method-i-unbind_source" class="dyn-source">
                <pre>static VALUE
method_unbind(VALUE obj)
{
    VALUE method;
    struct METHOD *orig, *data;

    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, orig);
    method = TypedData_Make_Struct(rb_cUnboundMethod, struct METHOD,
                                   &amp;method_data_type, data);
    RB_OBJ_WRITE(method, &amp;data-&gt;recv, Qundef);
    RB_OBJ_WRITE(method, &amp;data-&gt;klass, orig-&gt;klass);
    RB_OBJ_WRITE(method, &amp;data-&gt;iclass, orig-&gt;iclass);
    RB_OBJ_WRITE(method, &amp;data-&gt;me, rb_method_entry_clone(orig-&gt;me));

    return method;
}</pre>
              </div>
            </div>
            
          </div>
        
      
    
  
</div>

    </main>
  </body>
</html>
