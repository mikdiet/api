<!DOCTYPE html>
<html lang="en">
<head>
    <title>option_params.rdoc</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
<link rel="stylesheet" href="/css/reset.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/panel.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/main.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<link rel="stylesheet" href="/css/github.css" type="text/css" media="screen" data-turbolinks-track="reload" />
<script src="/js/jquery-3.5.1.min.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/main.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/highlight.pack.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/turbolinks.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/search_index.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searcher.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/panel/tree.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>
<script src="/js/searchdoc.js" type="text/javascript" charset="utf-8" data-turbolinks-track="reload"></script>

<meta name="data-rel-prefix" content="/">
<meta name="data-tree-keys" content='[]'>

</head>

<body>
    <a class="sr-only sr-only-focusable" href="#content" data-turbolinks="false">Skip to Content</a>
    <a class="sr-only sr-only-focusable" href="#search" data-turbolinks="false">Skip to Search</a>

    <input type="checkbox" id="hamburger" class="panel_checkbox">
<label class="panel_mobile_button" for="hamburger"><span></span> Menu</label>
<nav class="panel panel_tree" id="panel" data-turbolinks-permanent>
  <div class="header">
    <input type="text" placeholder="Search (/) for a class, method, ..." autosave="searchdoc" results="10" id="search" autocomplete="off" tabindex="-1" />
    <label class="panel_mobile_button_close" for="hamburger"><span></span> Close</label>
  </div>
  <div class="tree">
    <ul>
    </ul>
  </div>
  <div class="result">
    <ul>
    </ul>
  </div>
  <a href="links.html" id="links">index</a>
</nav>


    <div class="banner">
        
        <h2>
            option_params.rdoc
        </h2>
        <ul class="files">
            
            <li>
                ruby/doc/optparse/option_params.rdoc
                
                    <a href="https://github.com/ruby/ruby/blob/7b55c452b7d9a295d148ff882e0197cd139a9f8f/doc/optparse/option_params.rdoc" target="_blank" class="github_url">on GitHub</a>
                
            </li>
            <li>Last modified: 2024-05-24 23:57:53 +0300</li>
        </ul>
    </div>

    <main id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h2 id="label-Parameters+for+New+Options">Parameters for New Options</h2>

<p>Option-creating methods in <code>OptionParser</code> accept arguments that determine the behavior of a new option:</p>
<ul><li>
<p><a href="../../../../classes/OptionParser.html#method-i-on"><code>OptionParser#on</code></a></p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-on_head"><code>OptionParser#on_head</code></a></p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-on_tail"><code>OptionParser#on_tail</code></a></p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-define"><code>OptionParser#define</code></a></p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-define_head"><code>OptionParser#define_head</code></a></p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-define_tail"><code>OptionParser#define_tail</code></a></p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-make_switch"><code>OptionParser#make_switch</code></a></p>
</li></ul>

<p>The code examples on this page use:</p>
<ul><li>
<p><a href="../../../../classes/OptionParser.html#method-i-on"><code>OptionParser#on</code></a>, to define options.</p>
</li><li>
<p><a href="../../../../classes/OptionParser.html#method-i-parse-21"><code>OptionParser#parse!</code></a>, to parse the command line.</p>
</li><li>
<p>Built-in option <code>--help</code>, to display defined options.</p>
</li></ul>

<p>Contents:</p>
<ul><li>
<p><a href="#label-Option+Names">Option Names</a></p>
<ul><li>
<p><a href="#label-Short+Names">Short Names</a></p>
<ul><li>
<p><a href="#label-Simple+Short+Names">Simple Short Names</a></p>
</li><li>
<p><a href="#label-Short+Names+with+Required+Arguments">Short Names with Required Arguments</a></p>
</li><li>
<p><a href="#label-Short+Names+with+Optional+Arguments">Short Names with Optional Arguments</a></p>
</li><li>
<p><a href="#label-Short+Names+from+Range">Short Names from Range</a></p>
</li></ul>
</li><li>
<p><a href="#label-Long+Names">Long Names</a></p>
<ul><li>
<p><a href="#label-Simple+Long+Names">Simple Long Names</a></p>
</li><li>
<p><a href="#label-Long+Names+with+Required+Arguments">Long Names with Required Arguments</a></p>
</li><li>
<p><a href="#label-Long+Names+with+Optional+Arguments">Long Names with Optional Arguments</a></p>
</li><li>
<p><a href="#label-Long+Names+with+Negation">Long Names with Negation</a></p>
</li></ul>
</li><li>
<p><a href="#label-Mixed+Names">Mixed Names</a></p>
</li></ul>
</li><li>
<p><a href="#label-Argument+Styles">Argument Styles</a></p>
</li><li>
<p><a href="#label-Argument+Values">Argument Values</a></p>
<ul><li>
<p><a href="#label-Explicit+Argument+Values">Explicit Argument Values</a></p>
<ul><li>
<p><a href="#label-Explicit+Values+in+Array">Explicit Values in Array</a></p>
</li><li>
<p><a href="#label-Explicit+Values+in+Hash">Explicit Values in Hash</a></p>
</li></ul>
</li><li>
<p><a href="#label-Argument+Value+Patterns">Argument Value Patterns</a></p>
</li></ul>
</li><li>
<p><a href="#label-Argument+Converters">Argument Converters</a></p>
</li><li>
<p><a href="#label-Descriptions">Descriptions</a></p>
</li><li>
<p><a href="#label-Option+Handlers">Option Handlers</a></p>
<ul><li>
<p><a href="#label-Handler+Blocks">Handler Blocks</a></p>
</li><li>
<p><a href="#label-Handler+Procs">Handler Procs</a></p>
</li><li>
<p><a href="#label-Handler+Methods">Handler Methods</a></p>
</li></ul>
</li></ul>

<h3 id="label-Option+Names">Option Names</h3>

<p>There are two kinds of option names:</p>
<ul><li>
<p>Short option name, consisting of a single hyphen and a single character.</p>
</li><li>
<p>Long option name, consisting of two hyphens and one or more characters.</p>
</li></ul>

<h4 id="label-Short+Names">Short Names</h4>

<h5 id="label-Simple+Short+Names">Simple Short Names</h5>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>short_simple.rb</code> defines two options:</p>
<ul><li>
<p>One with short name <code>-x</code>.</p>
</li><li>
<p>The other with two short names, in effect, aliases, <code>-1</code> and <code>-%</code>.</p>
</li></ul>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-x&#39;, &#39;One short name&#39;) do |value|
  p [&#39;-x&#39;, value]
end
parser.on(&#39;-1&#39;, &#39;-%&#39;, &#39;Two short names (aliases)&#39;) do |value|
  p [&#39;-1 or -%&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby short_simple.rb --help
Usage: short_simple [options]
    -x                               One short name
    -1, -%                           Two short names (aliases)
$ ruby short_simple.rb -x
[&quot;-x&quot;, true]
$ ruby short_simple.rb -1 -x -%
[&quot;-1 or -%&quot;, true]
[&quot;-x&quot;, true]
[&quot;-1 or -%&quot;, true]
</code></pre>

<h5 id="label-Short+Names+with+Required+Arguments">Short Names with Required Arguments</h5>

<p>A short name followed (no whitespace) by a dummy word defines an option that requires an argument.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>short_required.rb</code> defines an option <code>-x</code> that requires an argument.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-xXXX&#39;, &#39;Short name with required argument&#39;) do |value|
  p [&#39;-x&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby short_required.rb --help
Usage: short_required [options]
    -xXXX                            Short name with required argument
$ ruby short_required.rb -x
short_required.rb:6:in `&lt;main&gt;&#39;: missing argument: -x (OptionParser::MissingArgument)
$ ruby short_required.rb -x FOO
[&quot;-x&quot;, &quot;FOO&quot;]
</code></pre>

<h5 id="label-Short+Names+with+Optional+Arguments">Short Names with Optional Arguments</h5>

<p>A short name followed (with whitespace) by a dummy word in square brackets defines an option that allows an optional argument.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>short_optional.rb</code> defines an option <code>-x</code> that allows an optional argument.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-x [XXX]&#39;, &#39;Short name with optional argument&#39;) do |value|
  p [&#39;-x&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby short_optional.rb --help
Usage: short_optional [options]
    -x [XXX]                         Short name with optional argument
$ ruby short_optional.rb -x
[&quot;-x&quot;, nil]
$ ruby short_optional.rb -x FOO
[&quot;-x&quot;, &quot;FOO&quot;]
</code></pre>

<h5 id="label-Short+Names+from+Range">Short Names from <a href="../../../../classes/Range.html"><code>Range</code></a></h5>

<p>You can define an option with multiple short names taken from a range of characters. The parser yields both the actual character cited and the value.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>short_range.rb</code> defines an option with short names for all printable characters from <code>!</code> to <code>~</code>:</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-[!-~]&#39;, &#39;Short names in (very large) range&#39;) do |name, value|
  p [&#39;!-~&#39;, name, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby short_range.rb --help
Usage: short_range [options]
    -[!-~]                           Short names in (very large) range
$ ruby short_range.rb -!
[&quot;!-~&quot;, &quot;!&quot;, nil]
$ ruby short_range.rb -!
[&quot;!-~&quot;, &quot;!&quot;, nil]
$ ruby short_range.rb -A
[&quot;!-~&quot;, &quot;A&quot;, nil]
$ ruby short_range.rb -z
[&quot;!-~&quot;, &quot;z&quot;, nil]
</code></pre>

<h4 id="label-Long+Names">Long Names</h4>

<h5 id="label-Simple+Long+Names">Simple Long Names</h5>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>long_simple.rb</code> defines two options:</p>
<ul><li>
<p>One with long name <code>-xxx</code>.</p>
</li><li>
<p>The other with two long names, in effect, aliases, <code>--y1%</code> and <code>--z2#</code>.</p>

<p>require ‘optparse’ parser = <a href="../../../../classes/OptionParser.html#method-c-new"><code>OptionParser.new</code></a> parser.on(‘–xxx’, ‘One long name’) do |value|</p>

<pre><code>p [&#39;--xxx&#39;, value]
</code></pre>

<p>end parser.on(‘–y1%’, ‘–z2#’, ‘Two long names (aliases)’) do |value|</p>

<pre><code>p [&#39;--y1% or --z2#&#39;, value]
</code></pre>

<p>end parser.parse!</p>
</li></ul>

<p>Executions:</p>

<pre><code>$ ruby long_simple.rb --help
Usage: long_simple [options]
        --xxx                        One long name
        --y1%, --z2#                 Two long names (aliases)
$ ruby long_simple.rb --xxx
[&quot;--xxx&quot;, true]
$ ruby long_simple.rb --y1% --xxx --z2#
[&quot;--y1% or --z2#&quot;, true]
[&quot;--xxx&quot;, true]
[&quot;--y1% or --z2#&quot;, true]
</code></pre>

<h5 id="label-Long+Names+with+Required+Arguments">Long Names with Required Arguments</h5>

<p>A long name followed (with whitespace) by a dummy word defines an option that requires an argument.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>long_required.rb</code> defines an option <code>--xxx</code> that requires an argument.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;--xxx XXX&#39;, &#39;Long name with required argument&#39;) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby long_required.rb --help
Usage: long_required [options]
        --xxx XXX                    Long name with required argument
$ ruby long_required.rb --xxx
long_required.rb:6:in `&lt;main&gt;&#39;: missing argument: --xxx (OptionParser::MissingArgument)
$ ruby long_required.rb --xxx FOO
[&quot;--xxx&quot;, &quot;FOO&quot;]
</code></pre>

<h5 id="label-Long+Names+with+Optional+Arguments">Long Names with Optional Arguments</h5>

<p>A long name followed (with whitespace) by a dummy word in square brackets defines an option that allows an optional argument.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>long_optional.rb</code> defines an option <code>--xxx</code> that allows an optional argument.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;--xxx [XXX]&#39;, &#39;Long name with optional argument&#39;) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby long_optional.rb --help
Usage: long_optional [options]
        --xxx [XXX]                  Long name with optional argument
$ ruby long_optional.rb --xxx
[&quot;--xxx&quot;, nil]
$ ruby long_optional.rb --xxx FOO
[&quot;--xxx&quot;, &quot;FOO&quot;]
</code></pre>

<h5 id="label-Long+Names+with+Negation">Long Names with Negation</h5>

<p>A long name may be defined with both positive and negative senses.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>long_with_negation.rb</code> defines an option that has both senses.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;--[no-]binary&#39;, &#39;Long name with negation&#39;) do |value|
  p [value, value.class]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby long_with_negation.rb --help
Usage: long_with_negation [options]
        --[no-]binary                Long name with negation
$ ruby long_with_negation.rb --binary
[true, TrueClass]
$ ruby long_with_negation.rb --no-binary
[false, FalseClass]
</code></pre>

<h4 id="label-Mixed+Names">Mixed Names</h4>

<p>An option may have both short and long names.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>mixed_names.rb</code> defines a mixture of short and long names.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-x&#39;, &#39;--xxx&#39;, &#39;Short and long, no argument&#39;) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.on(&#39;-yYYY&#39;, &#39;--yyy&#39;, &#39;Short and long, required argument&#39;) do |value|
  p [&#39;--yyy&#39;, value]
end
parser.on(&#39;-z [ZZZ]&#39;, &#39;--zzz&#39;, &#39;Short and long, optional argument&#39;) do |value|
  p [&#39;--zzz&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby mixed_names.rb --help
</code></pre>

<p>Usage: mixed_names [options]</p>

<pre><code>  -x, --xxx                        Short and long, no argument
  -y, --yyyYYY                     Short and long, required argument
  -z, --zzz [ZZZ]                  Short and long, optional argument
$ ruby mixed_names.rb -x
[&quot;--xxx&quot;, true]
$ ruby mixed_names.rb --xxx
[&quot;--xxx&quot;, true]
$ ruby mixed_names.rb -y
mixed_names.rb:12:in `&lt;main&gt;&#39;: missing argument: -y (OptionParser::MissingArgument)
$ ruby mixed_names.rb -y FOO
[&quot;--yyy&quot;, &quot;FOO&quot;]
$ ruby mixed_names.rb --yyy
mixed_names.rb:12:in `&lt;main&gt;&#39;: missing argument: --yyy (OptionParser::MissingArgument)
$ ruby mixed_names.rb --yyy BAR
[&quot;--yyy&quot;, &quot;BAR&quot;]
$ ruby mixed_names.rb -z
[&quot;--zzz&quot;, nil]
$ ruby mixed_names.rb -z BAZ
[&quot;--zzz&quot;, &quot;BAZ&quot;]
$ ruby mixed_names.rb --zzz
[&quot;--zzz&quot;, nil]
$ ruby mixed_names.rb --zzz BAT
[&quot;--zzz&quot;, &quot;BAT&quot;]
</code></pre>

<h3 id="label-Argument+Keywords">Argument Keywords</h3>

<p>As seen above, a given option name string may itself indicate whether the option has no argument, a required argument, or an optional argument.</p>

<p>An alternative is to use a separate symbol keyword, which is one of <code>:NONE</code> (the default), <code>:REQUIRED</code>, <code>:OPTIONAL</code>.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>argument_keywords.rb</code> defines an option with a required argument.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-x&#39;, &#39;--xxx&#39;, :REQUIRED, &#39;Required argument&#39;) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby argument_keywords.rb --help
Usage: argument_keywords [options]
    -x, --xxx                        Required argument
$ ruby argument_styles.rb --xxx
argument_styles.rb:6:in `&lt;main&gt;&#39;: missing argument: --xxx (OptionParser::MissingArgument)
$ ruby argument_styles.rb --xxx FOO
[&quot;--xxx&quot;, &quot;FOO&quot;]
</code></pre>

<h3 id="label-Argument+Strings">Argument Strings</h3>

<p>Still another way to specify a required argument is to define it in a string separate from the name string.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>argument_strings.rb</code> defines an option with a required argument.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-x&#39;, &#39;--xxx&#39;, &#39;=XXX&#39;, &#39;Required argument&#39;) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby argument_strings.rb --help
Usage: argument_strings [options]
    -x, --xxx=XXX                    Required argument
$ ruby argument_strings.rb --xxx
argument_strings.rb:9:in `&lt;main&gt;&#39;: missing argument: --xxx (OptionParser::MissingArgument)
$ ruby argument_strings.rb --xxx FOO
[&quot;--xxx&quot;, &quot;FOO&quot;]
</code></pre>

<h3 id="label-Argument+Values">Argument Values</h3>

<p>Permissible argument values may be restricted either by specifying explicit values or by providing a pattern that the given value must match.</p>

<h4 id="label-Explicit+Argument+Values">Explicit Argument Values</h4>

<p>You can specify argument values in either of two ways:</p>
<ul><li>
<p>Specify values an array of strings.</p>
</li><li>
<p>Specify values a hash.</p>
</li></ul>

<h5 id="label-Explicit+Values+in+Array">Explicit Values in <a href="../../../../classes/Array.html"><code>Array</code></a></h5>

<p>You can specify explicit argument values in an array of strings. The argument value must be one of those strings, or an unambiguous abbreviation.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>explicit_array_values.rb</code> defines options with explicit argument values.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-xXXX&#39;, [&#39;foo&#39;, &#39;bar&#39;], &#39;Values for required argument&#39; ) do |value|
  p [&#39;-x&#39;, value]
end
parser.on(&#39;-y [YYY]&#39;, [&#39;baz&#39;, &#39;bat&#39;], &#39;Values for optional argument&#39;) do |value|
  p [&#39;-y&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby explicit_array_values.rb --help
Usage: explicit_array_values [options]
    -xXXX                            Values for required argument
    -y [YYY]                         Values for optional argument
$ ruby explicit_array_values.rb -x
explicit_array_values.rb:9:in `&lt;main&gt;&#39;: missing argument: -x (OptionParser::MissingArgument)
$ ruby explicit_array_values.rb -x foo
[&quot;-x&quot;, &quot;foo&quot;]
$ ruby explicit_array_values.rb -x f
[&quot;-x&quot;, &quot;foo&quot;]
$ ruby explicit_array_values.rb -x bar
[&quot;-x&quot;, &quot;bar&quot;]
$ ruby explicit_array_values.rb -y ba
explicit_array_values.rb:9:in `&lt;main&gt;&#39;: ambiguous argument: -y ba (OptionParser::AmbiguousArgument)
$ ruby explicit_array_values.rb -x baz
explicit_array_values.rb:9:in `&lt;main&gt;&#39;: invalid argument: -x baz (OptionParser::InvalidArgument)
</code></pre>

<h5 id="label-Explicit+Values+in+Hash">Explicit Values in <a href="../../../../classes/Hash.html"><code>Hash</code></a></h5>

<p>You can specify explicit argument values in a hash with string keys. The value passed must be one of those keys, or an unambiguous abbreviation; the value yielded will be the value for that key.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>explicit_hash_values.rb</code> defines options with explicit argument values.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;-xXXX&#39;, {foo: 0, bar: 1}, &#39;Values for required argument&#39; ) do |value|
  p [&#39;-x&#39;, value]
end
parser.on(&#39;-y [YYY]&#39;, {baz: 2, bat: 3}, &#39;Values for optional argument&#39;) do |value|
  p [&#39;-y&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby explicit_hash_values.rb --help
Usage: explicit_hash_values [options]
    -xXXX                            Values for required argument
    -y [YYY]                         Values for optional argument
$ ruby explicit_hash_values.rb -x
explicit_hash_values.rb:9:in `&lt;main&gt;&#39;: missing argument: -x (OptionParser::MissingArgument)
$ ruby explicit_hash_values.rb -x foo
[&quot;-x&quot;, 0]
$ ruby explicit_hash_values.rb -x f
[&quot;-x&quot;, 0]
$ ruby explicit_hash_values.rb -x bar
[&quot;-x&quot;, 1]
$ ruby explicit_hash_values.rb -x baz
explicit_hash_values.rb:9:in `&lt;main&gt;&#39;: invalid argument: -x baz (OptionParser::InvalidArgument)
$ ruby explicit_hash_values.rb -y
[&quot;-y&quot;, nil]
$ ruby explicit_hash_values.rb -y baz
[&quot;-y&quot;, 2]
$ ruby explicit_hash_values.rb -y bat
[&quot;-y&quot;, 3]
$ ruby explicit_hash_values.rb -y ba
explicit_hash_values.rb:9:in `&lt;main&gt;&#39;: ambiguous argument: -y ba (OptionParser::AmbiguousArgument)
$ ruby explicit_hash_values.rb -y bam
[&quot;-y&quot;, nil]
</code></pre>

<h4 id="label-Argument+Value+Patterns">Argument Value Patterns</h4>

<p>You can restrict permissible argument values by specifying a <a href="../../../../classes/Regexp.html"><code>Regexp</code></a> that the given argument must match.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>matched_values.rb</code> defines options with matched argument values.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;--xxx XXX&#39;, /foo/i, &#39;Matched values&#39;) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby matched_values.rb --help
Usage: matched_values [options]
        --xxx XXX                    Matched values
$ ruby matched_values.rb --xxx foo
[&quot;--xxx&quot;, &quot;foo&quot;]
$ ruby matched_values.rb --xxx FOO
[&quot;--xxx&quot;, &quot;FOO&quot;]
$ ruby matched_values.rb --xxx bar
matched_values.rb:6:in `&lt;main&gt;&#39;: invalid argument: --xxx bar (OptionParser::InvalidArgument)
</code></pre>

<h3 id="label-Argument+Converters">Argument Converters</h3>

<p>An option can specify that its argument is to be converted from the default <code>String</code> to an instance of another class.</p>

<p>There are a number of built-in converters. You can also define custom converters.</p>

<p>See <a href="./argument_converters_rdoc.html">Argument Converters</a>.</p>

<h3 id="label-Descriptions">Descriptions</h3>

<p>A description parameter is any string parameter that is not recognized as an <a href="#label-Option+Names">option name</a> or a <a href="#label-Terminators">terminator</a>; in other words, it does not begin with a hyphen.</p>

<p>You may give any number of description parameters; each becomes a line in the text generated by option <code>--help</code>.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>descriptions.rb</code> has six strings in its array <code>descriptions</code>. These are all passed as parameters to <a href="../../../../classes/OptionParser.html#method-i-on"><code>OptionParser#on</code></a>, so that they all, line for line, become the option’s description.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
description = &lt;&lt;-EOT
Lorem ipsum dolor sit amet, consectetuer
adipiscing elit. Aenean commodo ligula eget.
Aenean massa. Cum sociis natoque penatibus
et magnis dis parturient montes, nascetur
ridiculus mus. Donec quam felis, ultricies
nec, pellentesque eu, pretium quis, sem.
EOT
descriptions = description.split($/)
parser.on(&#39;--xxx&#39;, *descriptions) do |value|
  p [&#39;--xxx&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby descriptions.rb --help
Usage: descriptions [options]
        --xxx                        Lorem ipsum dolor sit amet, consectetuer
                                     adipiscing elit. Aenean commodo ligula eget.
                                     Aenean massa. Cum sociis natoque penatibus
                                     et magnis dis parturient montes, nascetur
                                     ridiculus mus. Donec quam felis, ultricies
                                     nec, pellentesque eu, pretium quis, sem.
$ ruby descriptions.rb --xxx
[&quot;--xxx&quot;, true]
</code></pre>

<h3 id="label-Option+Handlers">Option Handlers</h3>

<p>The handler for an option is an executable that will be called when the option is encountered.  The handler may be:</p>
<ul><li>
<p>A block (this is most often seen).</p>
</li><li>
<p>A proc.</p>
</li><li>
<p>A method.</p>
</li></ul>

<h4 id="label-Handler+Blocks">Handler Blocks</h4>

<p>An option handler may be a block.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>block.rb</code> defines an option that has a handler block.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(&#39;--xxx&#39;, &#39;Option with no argument&#39;) do |value|
  p [&#39;Handler block for -xxx called with value:&#39;, value]
end
parser.on(&#39;--yyy YYY&#39;, &#39;Option with required argument&#39;) do |value|
  p [&#39;Handler block for -yyy called with value:&#39;, value]
end
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby block.rb --help
Usage: block [options]
        --xxx                        Option with no argument
        --yyy YYY                    Option with required argument
$ ruby block.rb --xxx
[&quot;Handler block for -xxx called with value:&quot;, true]
$ ruby block.rb --yyy FOO
[&quot;Handler block for -yyy called with value:&quot;, &quot;FOO&quot;]
</code></pre>

<h4 id="label-Handler+Procs">Handler Procs</h4>

<p>An option handler may be a <a href="../../../../classes/Proc.html"><code>Proc</code></a>.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>proc.rb</code> defines an option that has a handler proc.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
parser.on(
  &#39;--xxx&#39;,
  &#39;Option with no argument&#39;,
  -&gt;(value) {p [&#39;Handler proc for -xxx called with value:&#39;, value]}
)
parser.on(
  &#39;--yyy YYY&#39;,
  &#39;Option with required argument&#39;,
  -&gt;(value) {p [&#39;Handler proc for -yyy called with value:&#39;, value]}
)
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby proc.rb --help
Usage: proc [options]
        --xxx                        Option with no argument
        --yyy YYY                    Option with required argument
$ ruby proc.rb --xxx
[&quot;Handler proc for -xxx called with value:&quot;, true]
$ ruby proc.rb --yyy FOO
[&quot;Handler proc for -yyy called with value:&quot;, &quot;FOO&quot;]
</code></pre>

<h4 id="label-Handler+Methods">Handler Methods</h4>

<p>An option handler may be a <a href="../../../../classes/Method.html"><code>Method</code></a>.</p>

<p><a href="../../../../classes/File.html"><code>File</code></a> <code>proc.rb</code> defines an option that has a handler method.</p>

<pre><code>require &#39;optparse&#39;
parser = OptionParser.new
def xxx_handler(value)
  p [&#39;Handler method for -xxx called with value:&#39;, value]
end
parser.on(&#39;--xxx&#39;, &#39;Option with no argument&#39;, method(:xxx_handler))
def yyy_handler(value)
  p [&#39;Handler method for -yyy called with value:&#39;, value]
end
parser.on(&#39;--yyy YYY&#39;, &#39;Option with required argument&#39;, method(:yyy_handler))
parser.parse!
</code></pre>

<p>Executions:</p>

<pre><code>$ ruby method.rb --help
Usage: method [options]
        --xxx                        Option with no argument
        --yyy YYY                    Option with required argument
$ ruby method.rb --xxx
[&quot;Handler method for -xxx called with value:&quot;, true]
$ ruby method.rb --yyy FOO
[&quot;Handler method for -yyy called with value:&quot;, &quot;FOO&quot;]
</code></pre>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </main>
  </body>
</html>
